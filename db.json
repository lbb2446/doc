{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1602307297322},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1602307297322},{"_id":"themes/landscape/README.md","hash":"67fedfb66304f103c412f6be110bf3c40c75d4ac","modified":1602307297322},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1602307297322},{"_id":"themes/landscape/_config.yml","hash":"ce9d2939245209b8f5c5bbbdadc917d86057d032","modified":1602307297322},{"_id":"themes/landscape/package.json","hash":"6e567a9654e61eb3f548c75edef380c2e135c433","modified":1602307297334},{"_id":"source/_posts/Html.md","hash":"2a38a8af8fabced0b9a5f61393638a40916c6362","modified":1602307297318},{"_id":"source/_posts/form表单规范.md","hash":"d547ceb797d2824e6a9878a7ae3613cacf6cb002","modified":1602307297318},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1602307297318},{"_id":"source/_posts/less.md","hash":"fba6692e184cbd582a6893e97d34fc7b22355d0f","modified":1602307297318},{"_id":"source/_posts/每日一问.md","hash":"8228aa3278ca0ef404eb6b9366f43cc63518d12c","modified":1602307297320},{"_id":"source/_posts/小工具.md","hash":"61a7e0ceee52ce1ccd4b4844f4b4f32adcc99d8a","modified":1602307297318},{"_id":"source/_posts/设计模式.md","hash":"924e93d6bbe80609ee548e5e082eac43175c906e","modified":1602308308791},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1602307297332},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1602307297332},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1602307297333},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1602307297333},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1602307297333},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1602307297333},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1602307297334},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1602307297323},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1602307297323},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1602307297323},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1602307297324},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1602307297324},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1602307297324},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1602307297325},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1602307297325},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1602307297325},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1602307297325},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1602307297325},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1602307297326},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1602307297334},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"5e3b70c028d518b8f765e29a5e2020e7ba6ed589","modified":1602307297326},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1602307297327},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"017c412bd3d60d22e493f02918e436a32d96bb84","modified":1602307297327},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1602307297327},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1602307297327},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1602307297328},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1602307297328},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"cf755454675d13a0813a922b575c06b6b74ab9fd","modified":1602307297329},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a36cec48782782bac92622f369c750e5c7396510","modified":1602307297329},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1602307297329},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1602307297331},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1602307297331},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1602307297331},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1602307297332},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1602307297332},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1602307297332},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1602307297335},{"_id":"themes/landscape/source/css/_variables.styl","hash":"57bb02270eef16b4823a64ba663ccf2f247f34e5","modified":1602307297338},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1602307297345},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1602307297346},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1602307297347},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1602307297348},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1602307297348},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1602307297348},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1602307297367},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1602307297370},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1602307297370},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1602307297371},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1602307297371},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1602307297329},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1602307297330},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1602307297330},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1602307297330},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1602307297330},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1602307297331},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1602307297335},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1602307297335},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1602307297335},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1602307297336},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1602307297336},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1602307297336},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1602307297337},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1602307297337},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1602307297337},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1602307297337},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1602307297338},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1602307297338},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1602307297339},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1602307297339},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1602307297342},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1602307297367},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1602307297367},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1602307297368},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1602307297368},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1602307297369},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1602307297369},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1602307297341},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1602307297340},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1602307297344}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"\n\n![](C:\\Users\\linbinbin\\AppData\\Roaming\\Typora\\typora-user-images\\1562046444629.png)\n\n","source":"_posts/form表单规范.md","raw":"\n\n![](C:\\Users\\linbinbin\\AppData\\Roaming\\Typora\\typora-user-images\\1562046444629.png)\n\n","slug":"form表单规范","published":1,"date":"2020-10-10T05:21:37.318Z","updated":"2020-10-10T05:21:37.318Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckg39jbm400008ovpdvk3p1cw","content":"<p><img src=\"C:%5CUsers%5Clinbinbin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1562046444629.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"C:%5CUsers%5Clinbinbin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1562046444629.png\" alt></p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2020-10-10T05:21:37.318Z","updated":"2020-10-10T05:21:37.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckg39jbma00018ovpdlm88spb","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"_content":"# [喝水闹钟\n\n# 待办事项（与github api打通）\n\n# vue底层重构\n\n# 支持cdn地址的资源\n\n# 支持2dlive+unity+静态图片的方式\n\n极简模式\n\npck快速解压工具开发（底层要变化）\n\n","source":"_posts/小工具.md","raw":"# [喝水闹钟\n\n# 待办事项（与github api打通）\n\n# vue底层重构\n\n# 支持cdn地址的资源\n\n# 支持2dlive+unity+静态图片的方式\n\n极简模式\n\npck快速解压工具开发（底层要变化）\n\n","slug":"小工具","published":1,"date":"2020-10-10T05:21:37.318Z","updated":"2020-10-10T05:21:37.318Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckg39jbmc00028ovp1l3fybqt","content":"<h1 id=\"喝水闹钟\"><a href=\"#喝水闹钟\" class=\"headerlink\" title=\"[喝水闹钟\"></a>[喝水闹钟</h1><h1 id=\"待办事项（与github-api打通）\"><a href=\"#待办事项（与github-api打通）\" class=\"headerlink\" title=\"待办事项（与github api打通）\"></a>待办事项（与github api打通）</h1><h1 id=\"vue底层重构\"><a href=\"#vue底层重构\" class=\"headerlink\" title=\"vue底层重构\"></a>vue底层重构</h1><h1 id=\"支持cdn地址的资源\"><a href=\"#支持cdn地址的资源\" class=\"headerlink\" title=\"支持cdn地址的资源\"></a>支持cdn地址的资源</h1><h1 id=\"支持2dlive-unity-静态图片的方式\"><a href=\"#支持2dlive-unity-静态图片的方式\" class=\"headerlink\" title=\"支持2dlive+unity+静态图片的方式\"></a>支持2dlive+unity+静态图片的方式</h1><p>极简模式</p>\n<p>pck快速解压工具开发（底层要变化）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"喝水闹钟\"><a href=\"#喝水闹钟\" class=\"headerlink\" title=\"[喝水闹钟\"></a>[喝水闹钟</h1><h1 id=\"待办事项（与github-api打通）\"><a href=\"#待办事项（与github-api打通）\" class=\"headerlink\" title=\"待办事项（与github api打通）\"></a>待办事项（与github api打通）</h1><h1 id=\"vue底层重构\"><a href=\"#vue底层重构\" class=\"headerlink\" title=\"vue底层重构\"></a>vue底层重构</h1><h1 id=\"支持cdn地址的资源\"><a href=\"#支持cdn地址的资源\" class=\"headerlink\" title=\"支持cdn地址的资源\"></a>支持cdn地址的资源</h1><h1 id=\"支持2dlive-unity-静态图片的方式\"><a href=\"#支持2dlive-unity-静态图片的方式\" class=\"headerlink\" title=\"支持2dlive+unity+静态图片的方式\"></a>支持2dlive+unity+静态图片的方式</h1><p>极简模式</p>\n<p>pck快速解压工具开发（底层要变化）</p>\n"},{"_content":"#基础语法糖","source":"_posts/less.md","raw":"#基础语法糖","slug":"less","published":1,"date":"2020-10-10T05:21:37.318Z","updated":"2020-10-10T05:21:37.318Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckg39jbmd00038ovpyn7v7gru","content":"<p>#基础语法糖</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#基础语法糖</p>\n"},{"_content":"# 源\n\n以下内容摘自wiki百科\n\n> 1980年，物理学家[蒂姆·伯纳斯-李](https://zh.wikipedia.org/wiki/蒂姆·伯纳斯-李)在[欧洲核子研究中心](https://zh.wikipedia.org/wiki/歐洲核子研究組織)（CERN）在承包工程期间，为使CERN的研究人员使用并共享文档，他提出并创建原型系统[ENQUIRE](https://zh.wikipedia.org/wiki/ENQUIRE)。1989年，伯纳斯-李在一份备忘录中提出一个基于[互联网](https://zh.wikipedia.org/wiki/互联网)的[超文本](https://zh.wikipedia.org/wiki/超文本)系统[[5\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-5)。他规定HTML并在1990年底写出浏览器和服务器软件。同年，伯纳斯-李与CERN的数据系统工程师[罗伯特·卡里奥](https://zh.wikipedia.org/wiki/罗伯特·卡里奥)联合为项目申请资助，但未被CERN正式批准。在他的个人笔记中[[6\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-6)伯纳斯-李列举“一些使用超文本的领域”，并把百科全书列为首位[[7\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-7)。\n> HTML的首个公开描述出现于一个名为“HTML标签”的文件中，由蒂姆·伯纳斯-李于1991年底提及[[8\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-tagshtml-8)[[9\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-9)。它描述18个元素，包括HTML初始的、相对简单的设计。除了超链接标签外，其他设计都深受CERN内部一个以[标准通用标记语言](https://zh.wikipedia.org/wiki/SGML)（SGML）为基础的文件格式SGMLguid的影响。这些元素在HTML 4中仍有11个存在[[10\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-10)。\n> 伯纳斯-李认为HTML是SGML的一个应用程序。1993年中期[互联网工程任务组](https://zh.wikipedia.org/wiki/互联网工程任务组)（IETF）发布首个HTML规范的提案：[“超文本标记语言（HTML）”互联网草案](http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt)，由伯纳斯-李与[丹·康纳利](https://zh.wikipedia.org/w/index.php?title=丹·康纳利&action=edit&redlink=1)撰写。其中包括一个SGML[文档类型定义](https://zh.wikipedia.org/wiki/文件类型描述)来定义语法[[11\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-11)。草案于6个月后过期，不过值得注意的是其对[NCSA Mosaic](https://zh.wikipedia.org/wiki/NCSA_Mosaic)浏览器自定义标签从而将在线图像嵌入的行为的认可，这反映IETF把标准立足于成功原型的理念[[12\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-raymond-12)。同样，[戴夫·拉格特](https://zh.wikipedia.org/w/index.php?title=戴夫·拉格特&action=edit&redlink=1)在1993年末提出的与之竞争的互联网草案“HTML+（超文本标记格式）”建议规范已经实现的功能，如表格与填写表单[[13\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-html+-13)。\n>\n> 在HTML和HTML+的草案于1994年初到期后，IETF创建一个HTML工作组，并在1995年完成\"HTML 2.0\"，这是第一个旨在成为对其后续实现标准的依据的HTML规范[[14\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-14)。\n>\n> 在IETF的主持下，HTML标准的进一步发展因竞争利益而遭受停滞。自1996年起，HTML规范一直由[万维网联盟](https://zh.wikipedia.org/wiki/万维网联盟)（W3C）维护，并由商业软件厂商出资[[15\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-raggett-15)。不过在2000年，HTML也成为国际标准（[ISO](https://zh.wikipedia.org/wiki/國際標準化組織)/ [IEC](https://zh.wikipedia.org/wiki/IEC)15445：2000）。HTML 4.01于1999年末发布，进一步的勘误版本于2001年发布。2004年，[网页超文本应用技术工作小组](https://zh.wikipedia.org/wiki/網頁超文本技術工作小組)（WHATWG）开始开发HTML5，并在2008年与W3C共同交付，2014年10月28日完成标准化[[16\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-16)。https://en.wikipedia.org/wiki/HTML#cite_note-14)\n\n# 历史\n\n>1995年11月24日\n>HTML 2.0作为IETF RFC 1866发布。追加RFC的附加功能：\n>1995年11月25日：RFC 1867（基于表单的文件上传）\n>1996年5月：RFC 1942（表格）\n>1996年8月：RFC 1980（客户端图像映射）\n>1997年1月：RFC 2070（国际化）\n>1997年1月14日\n>HTML 3.2[17]作为W3C推荐标准发布。这是首个完全由W3C开发并标准化的版本，因IETF于1996年9月12日关闭它的HTML工作组[18]。\n>最初代号为“威尔伯”（Wilbur）[19]，HTML 3.2完全去除数学公式，协调各种专有扩展，并采用网景设计的大多数视觉标记标签。由于两家公司达成了协议，网景的闪烁元素和微软的滚动元素被移除[15]。HTML对数学公式的支持最后成为另外一种被称为MathML的标准。\n>1997年12月18日\n>HTML 4.0[20]作为W3C推荐标准发布。它提供三种变化：\n>严格，过时的元素被禁止。\n>过渡，过时的元素被允许。\n>框架集，大多只与框架相关的元素被允许。\n>最初代号“美洲狮”（Cougar）[19]， HTML 4.0采用许多特定浏览器的元素类型和属性，并试图淘汰网景的视觉标记功能，将其标记为不赞成使用。HTML 4是遵循ISO 8879 - SGML的SGML应用程序[21]。\n>1998年4月24日\n>HTML 4.0[22]进行微调，不增加版本号。\n>1999年12月24日\n>HTML 4.01[23]作为W3C推荐标准发布。它同样提供三种变化，最终勘误版于2001年5月12日发布。\n>2000年5月\n>ISO/IEC 15445:2000[24][25]（\"ISO HTML\"，基于HTML 4.01严格版）作为ISO/IEC国际标准发布。在ISO中这一标准位于ISO/IEC JTC 1/SC 34域（ISO/IEC联合技术委员会1、小组委员会34 – 文档描述与处理语言）[24]。\n>2014年10月28日\n>HTML 5[26]作为W3C推荐标准发布[27]。\n>草案时间线\n\n>HTML5的Logo\n>1991年10月\n>HTML标签[8]，一个非正式CERN文件首次公开18个HTML标签。\n>1992年6月\n>HTML DTD的首个非正式草案[28]， 后续有七个修订版[29][30][31]（7月15日，8月6日，8月18日，11月17日，11月19日，11月20日，11月22日）。\n>1992年11月\n>HTML DTD 1.1（首个版本号，基于RCS修订版，版本号从1.1开始而非1.0），非正式草案。[31]\n>1993年6月\n>超文本标记语言[32]由IETF IIIR工作小组作为互联网草案（一个粗略的建议标准）。在被第二版[33]取代一个月后，IETF又发布6个草案[34]，最终在RFC1866中发布HTML 2.0。\n>1993年11月\n>HTML+由IETF作为互联网草案发布，是超文本标记语言草案的一个竞争性提案。它于1994年5月到期。\n>1995年4月 （1995年3月编写）\n>HTML 3.0[35]被提议作为IETF的标准，但直到提案在五个月过期后（1995年9月28日）[36]仍没有进一步的行动。它包含许多拉格特HTML+提案的功能，如对表格的支持、围绕数据的文本流和复杂的数学公式的显示[36]。W3C开始开发自己的Arena浏览器作为HTML 3和层叠样式表的试验台[37][38][39]，但HTML 3.0并没有获得成功。浏览器厂商，包括微软和网景，选择实现HTML3草案功能的不同子集并引入它们自己的插件（见浏览器大战）[15]。\n>2008年1月\n>HTML5由W3C作为工作草案（链接）发布[40]。虽然HTML5的语法非常类似于SGML，但它已经放弃任何成为SGML应用程序的尝试，除了一种替代的基于XML的HTML5序列，它已明确定义自己的“HTML”序列[41]。\n>2011年 HTML5 – 最终征求\n>2011年5月，工作小组将HTML5推进至“最终征求”（Last Call）阶段，邀请W3C社区内外人士以确认本规范的技术可靠性。W3C开发一套综合性测试包来实现完整规范的广泛交互操作性，完整规范的目标日期为2014年[42]。2011年1月，WHATWG将其“HTML5”活动标准重命名为“HTML”。W3C仍然继续其发布HTML5的项目[43]。\n>2012年 HTML5 – 候选推荐\n>2012年7月，WHATWG和W3C的工作产生一定程度的分离。W3C继续HTML5规范工作，重点放在单一明确的标准上，这被WHATWG称为“快照”。WHATWG组织则将HTML5作为一个“活动标准”（Living Standard）。活动标准的概念是从未完成但永远保持更新与改进，可以蒂姆加新特性，但功能点不会被删除。[44]\n>2012年12月，W3C指定HTML5作为候选推荐[45]阶段。 该阶段的标准为“两个100％完成，完全实现交互操作”。\n>2014年 HTML5 – 提案推荐与推荐\n>2014年9月，HTML5进入提案推荐阶段。[46]\n>2014年10月28日，HTML5作为稳定W3C推荐标准发布[47]，这意味着HTML5的标准化已经完成[48]。\n>XHTML版本\n>主条目：XHTML\n>XHTML是使用XML 1.0改写自HTML 4.01的独立语言。它不再被作为单独标准开发。\n\n>XHTML 1.0[49]， 2000年1月26日作为W3C推荐标准发布。修订版于2002年8月1日发布，它提供与HTML 4.0和4.01相同的三个变化，这些变化被重新在XML中制定。\n>XHTML 1.1[50]，基于XHTML 1.0 严格版，2001年5月31日 作为W3C推荐标准发布。修订版可使用模块化XHTML的模块，2001年4月10日作为W3C推荐标准发布。\n>XHTML 2.0为工作草案，但为支持HTML5与XHTML5的工作，此草案被放弃[51][52][53]。 XHTML 2.0与XHTML 1.x不兼容，因此更确切的说这是一个XHTML风格的新语言而不是XHTML 1.x的更新。\n>在HTML5草案中规定一个XHTML语法，称为“XHTML5.1”[54]。\n# 定义（what）\n> **超文本标记语言**（英语：**H**yper**T**ext **M**arkup **L**anguage，简称：**HTML**）是一种用于创建[网页](https://zh.wikipedia.org/wiki/网页)的标准[标记语言](https://zh.wikipedia.org/wiki/标记语言)。HTML是一种基础技术，常与[CSS](https://zh.wikipedia.org/wiki/CSS)、[JavaScript](https://zh.wikipedia.org/wiki/JavaScript)一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面[[3\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-3)。[网页浏览器](https://zh.wikipedia.org/wiki/网页浏览器)可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非[编程语言](https://zh.wikipedia.org/wiki/编程语言)。\n>\n> [HTML元素](https://zh.wikipedia.org/wiki/HTML元素)是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和[语义](https://zh.wikipedia.org/wiki/语义)。HTML的语言形式为[尖括号](https://zh.wikipedia.org/wiki/括号)包围的HTML元素（如`<html>`），浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上。\n>\n> HTML可以嵌入如[JavaScript](https://zh.wikipedia.org/wiki/JavaScript)的[脚本语言](https://zh.wikipedia.org/wiki/脚本语言)，它们会影响HTML网页的行为。网页浏览器也可以引用[层叠样式表](https://zh.wikipedia.org/wiki/层叠样式表)（CSS）来定义文本和其它元素的外观与布局。维护HTML和CSS标准的组织[万维网联盟](https://zh.wikipedia.org/wiki/万维网联盟)（W3C）鼓励人们使用CSS替代一些用于表现的HTML元素[[4\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-deprecated-4)。\n\n\n# 标记（what）\n\n![img](https://tycn.gitbooks.io/css/assets/html.png)\n\n# 底层核心，dom的渲染过程（HOW）\n\n1. 解析HTML，构建DOM树（这里遇到外链，此时会发起请求）\n2. 解析CSS，生成CSS规则树\n3. 合并DOM树和CSS规则，生成render树\n4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n5. 绘制render树（paint），绘制页面像素信息\n6. 浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上\n\n* reflow(回流): 根据Render Tree布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；\n* repaint(重绘): 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；\n\n# 语义HTML，语义/标签的现状（WHY）\n\n>","source":"_posts/Html.md","raw":"# 源\n\n以下内容摘自wiki百科\n\n> 1980年，物理学家[蒂姆·伯纳斯-李](https://zh.wikipedia.org/wiki/蒂姆·伯纳斯-李)在[欧洲核子研究中心](https://zh.wikipedia.org/wiki/歐洲核子研究組織)（CERN）在承包工程期间，为使CERN的研究人员使用并共享文档，他提出并创建原型系统[ENQUIRE](https://zh.wikipedia.org/wiki/ENQUIRE)。1989年，伯纳斯-李在一份备忘录中提出一个基于[互联网](https://zh.wikipedia.org/wiki/互联网)的[超文本](https://zh.wikipedia.org/wiki/超文本)系统[[5\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-5)。他规定HTML并在1990年底写出浏览器和服务器软件。同年，伯纳斯-李与CERN的数据系统工程师[罗伯特·卡里奥](https://zh.wikipedia.org/wiki/罗伯特·卡里奥)联合为项目申请资助，但未被CERN正式批准。在他的个人笔记中[[6\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-6)伯纳斯-李列举“一些使用超文本的领域”，并把百科全书列为首位[[7\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-7)。\n> HTML的首个公开描述出现于一个名为“HTML标签”的文件中，由蒂姆·伯纳斯-李于1991年底提及[[8\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-tagshtml-8)[[9\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-9)。它描述18个元素，包括HTML初始的、相对简单的设计。除了超链接标签外，其他设计都深受CERN内部一个以[标准通用标记语言](https://zh.wikipedia.org/wiki/SGML)（SGML）为基础的文件格式SGMLguid的影响。这些元素在HTML 4中仍有11个存在[[10\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-10)。\n> 伯纳斯-李认为HTML是SGML的一个应用程序。1993年中期[互联网工程任务组](https://zh.wikipedia.org/wiki/互联网工程任务组)（IETF）发布首个HTML规范的提案：[“超文本标记语言（HTML）”互联网草案](http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt)，由伯纳斯-李与[丹·康纳利](https://zh.wikipedia.org/w/index.php?title=丹·康纳利&action=edit&redlink=1)撰写。其中包括一个SGML[文档类型定义](https://zh.wikipedia.org/wiki/文件类型描述)来定义语法[[11\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-11)。草案于6个月后过期，不过值得注意的是其对[NCSA Mosaic](https://zh.wikipedia.org/wiki/NCSA_Mosaic)浏览器自定义标签从而将在线图像嵌入的行为的认可，这反映IETF把标准立足于成功原型的理念[[12\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-raymond-12)。同样，[戴夫·拉格特](https://zh.wikipedia.org/w/index.php?title=戴夫·拉格特&action=edit&redlink=1)在1993年末提出的与之竞争的互联网草案“HTML+（超文本标记格式）”建议规范已经实现的功能，如表格与填写表单[[13\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-html+-13)。\n>\n> 在HTML和HTML+的草案于1994年初到期后，IETF创建一个HTML工作组，并在1995年完成\"HTML 2.0\"，这是第一个旨在成为对其后续实现标准的依据的HTML规范[[14\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-14)。\n>\n> 在IETF的主持下，HTML标准的进一步发展因竞争利益而遭受停滞。自1996年起，HTML规范一直由[万维网联盟](https://zh.wikipedia.org/wiki/万维网联盟)（W3C）维护，并由商业软件厂商出资[[15\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-raggett-15)。不过在2000年，HTML也成为国际标准（[ISO](https://zh.wikipedia.org/wiki/國際標準化組織)/ [IEC](https://zh.wikipedia.org/wiki/IEC)15445：2000）。HTML 4.01于1999年末发布，进一步的勘误版本于2001年发布。2004年，[网页超文本应用技术工作小组](https://zh.wikipedia.org/wiki/網頁超文本技術工作小組)（WHATWG）开始开发HTML5，并在2008年与W3C共同交付，2014年10月28日完成标准化[[16\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-16)。https://en.wikipedia.org/wiki/HTML#cite_note-14)\n\n# 历史\n\n>1995年11月24日\n>HTML 2.0作为IETF RFC 1866发布。追加RFC的附加功能：\n>1995年11月25日：RFC 1867（基于表单的文件上传）\n>1996年5月：RFC 1942（表格）\n>1996年8月：RFC 1980（客户端图像映射）\n>1997年1月：RFC 2070（国际化）\n>1997年1月14日\n>HTML 3.2[17]作为W3C推荐标准发布。这是首个完全由W3C开发并标准化的版本，因IETF于1996年9月12日关闭它的HTML工作组[18]。\n>最初代号为“威尔伯”（Wilbur）[19]，HTML 3.2完全去除数学公式，协调各种专有扩展，并采用网景设计的大多数视觉标记标签。由于两家公司达成了协议，网景的闪烁元素和微软的滚动元素被移除[15]。HTML对数学公式的支持最后成为另外一种被称为MathML的标准。\n>1997年12月18日\n>HTML 4.0[20]作为W3C推荐标准发布。它提供三种变化：\n>严格，过时的元素被禁止。\n>过渡，过时的元素被允许。\n>框架集，大多只与框架相关的元素被允许。\n>最初代号“美洲狮”（Cougar）[19]， HTML 4.0采用许多特定浏览器的元素类型和属性，并试图淘汰网景的视觉标记功能，将其标记为不赞成使用。HTML 4是遵循ISO 8879 - SGML的SGML应用程序[21]。\n>1998年4月24日\n>HTML 4.0[22]进行微调，不增加版本号。\n>1999年12月24日\n>HTML 4.01[23]作为W3C推荐标准发布。它同样提供三种变化，最终勘误版于2001年5月12日发布。\n>2000年5月\n>ISO/IEC 15445:2000[24][25]（\"ISO HTML\"，基于HTML 4.01严格版）作为ISO/IEC国际标准发布。在ISO中这一标准位于ISO/IEC JTC 1/SC 34域（ISO/IEC联合技术委员会1、小组委员会34 – 文档描述与处理语言）[24]。\n>2014年10月28日\n>HTML 5[26]作为W3C推荐标准发布[27]。\n>草案时间线\n\n>HTML5的Logo\n>1991年10月\n>HTML标签[8]，一个非正式CERN文件首次公开18个HTML标签。\n>1992年6月\n>HTML DTD的首个非正式草案[28]， 后续有七个修订版[29][30][31]（7月15日，8月6日，8月18日，11月17日，11月19日，11月20日，11月22日）。\n>1992年11月\n>HTML DTD 1.1（首个版本号，基于RCS修订版，版本号从1.1开始而非1.0），非正式草案。[31]\n>1993年6月\n>超文本标记语言[32]由IETF IIIR工作小组作为互联网草案（一个粗略的建议标准）。在被第二版[33]取代一个月后，IETF又发布6个草案[34]，最终在RFC1866中发布HTML 2.0。\n>1993年11月\n>HTML+由IETF作为互联网草案发布，是超文本标记语言草案的一个竞争性提案。它于1994年5月到期。\n>1995年4月 （1995年3月编写）\n>HTML 3.0[35]被提议作为IETF的标准，但直到提案在五个月过期后（1995年9月28日）[36]仍没有进一步的行动。它包含许多拉格特HTML+提案的功能，如对表格的支持、围绕数据的文本流和复杂的数学公式的显示[36]。W3C开始开发自己的Arena浏览器作为HTML 3和层叠样式表的试验台[37][38][39]，但HTML 3.0并没有获得成功。浏览器厂商，包括微软和网景，选择实现HTML3草案功能的不同子集并引入它们自己的插件（见浏览器大战）[15]。\n>2008年1月\n>HTML5由W3C作为工作草案（链接）发布[40]。虽然HTML5的语法非常类似于SGML，但它已经放弃任何成为SGML应用程序的尝试，除了一种替代的基于XML的HTML5序列，它已明确定义自己的“HTML”序列[41]。\n>2011年 HTML5 – 最终征求\n>2011年5月，工作小组将HTML5推进至“最终征求”（Last Call）阶段，邀请W3C社区内外人士以确认本规范的技术可靠性。W3C开发一套综合性测试包来实现完整规范的广泛交互操作性，完整规范的目标日期为2014年[42]。2011年1月，WHATWG将其“HTML5”活动标准重命名为“HTML”。W3C仍然继续其发布HTML5的项目[43]。\n>2012年 HTML5 – 候选推荐\n>2012年7月，WHATWG和W3C的工作产生一定程度的分离。W3C继续HTML5规范工作，重点放在单一明确的标准上，这被WHATWG称为“快照”。WHATWG组织则将HTML5作为一个“活动标准”（Living Standard）。活动标准的概念是从未完成但永远保持更新与改进，可以蒂姆加新特性，但功能点不会被删除。[44]\n>2012年12月，W3C指定HTML5作为候选推荐[45]阶段。 该阶段的标准为“两个100％完成，完全实现交互操作”。\n>2014年 HTML5 – 提案推荐与推荐\n>2014年9月，HTML5进入提案推荐阶段。[46]\n>2014年10月28日，HTML5作为稳定W3C推荐标准发布[47]，这意味着HTML5的标准化已经完成[48]。\n>XHTML版本\n>主条目：XHTML\n>XHTML是使用XML 1.0改写自HTML 4.01的独立语言。它不再被作为单独标准开发。\n\n>XHTML 1.0[49]， 2000年1月26日作为W3C推荐标准发布。修订版于2002年8月1日发布，它提供与HTML 4.0和4.01相同的三个变化，这些变化被重新在XML中制定。\n>XHTML 1.1[50]，基于XHTML 1.0 严格版，2001年5月31日 作为W3C推荐标准发布。修订版可使用模块化XHTML的模块，2001年4月10日作为W3C推荐标准发布。\n>XHTML 2.0为工作草案，但为支持HTML5与XHTML5的工作，此草案被放弃[51][52][53]。 XHTML 2.0与XHTML 1.x不兼容，因此更确切的说这是一个XHTML风格的新语言而不是XHTML 1.x的更新。\n>在HTML5草案中规定一个XHTML语法，称为“XHTML5.1”[54]。\n# 定义（what）\n> **超文本标记语言**（英语：**H**yper**T**ext **M**arkup **L**anguage，简称：**HTML**）是一种用于创建[网页](https://zh.wikipedia.org/wiki/网页)的标准[标记语言](https://zh.wikipedia.org/wiki/标记语言)。HTML是一种基础技术，常与[CSS](https://zh.wikipedia.org/wiki/CSS)、[JavaScript](https://zh.wikipedia.org/wiki/JavaScript)一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面[[3\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-3)。[网页浏览器](https://zh.wikipedia.org/wiki/网页浏览器)可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非[编程语言](https://zh.wikipedia.org/wiki/编程语言)。\n>\n> [HTML元素](https://zh.wikipedia.org/wiki/HTML元素)是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和[语义](https://zh.wikipedia.org/wiki/语义)。HTML的语言形式为[尖括号](https://zh.wikipedia.org/wiki/括号)包围的HTML元素（如`<html>`），浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上。\n>\n> HTML可以嵌入如[JavaScript](https://zh.wikipedia.org/wiki/JavaScript)的[脚本语言](https://zh.wikipedia.org/wiki/脚本语言)，它们会影响HTML网页的行为。网页浏览器也可以引用[层叠样式表](https://zh.wikipedia.org/wiki/层叠样式表)（CSS）来定义文本和其它元素的外观与布局。维护HTML和CSS标准的组织[万维网联盟](https://zh.wikipedia.org/wiki/万维网联盟)（W3C）鼓励人们使用CSS替代一些用于表现的HTML元素[[4\\]](https://zh.wikipedia.org/wiki/HTML#cite_note-deprecated-4)。\n\n\n# 标记（what）\n\n![img](https://tycn.gitbooks.io/css/assets/html.png)\n\n# 底层核心，dom的渲染过程（HOW）\n\n1. 解析HTML，构建DOM树（这里遇到外链，此时会发起请求）\n2. 解析CSS，生成CSS规则树\n3. 合并DOM树和CSS规则，生成render树\n4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算\n5. 绘制render树（paint），绘制页面像素信息\n6. 浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上\n\n* reflow(回流): 根据Render Tree布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；\n* repaint(重绘): 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；\n\n# 语义HTML，语义/标签的现状（WHY）\n\n>","slug":"Html","published":1,"date":"2020-10-10T05:21:37.317Z","updated":"2020-10-10T05:21:37.318Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckg39jbmo00048ovp998hvh9f","content":"<h1 id=\"源\"><a href=\"#源\" class=\"headerlink\" title=\"源\"></a>源</h1><p>以下内容摘自wiki百科</p>\n<blockquote>\n<p>1980年，物理学家<a href=\"https://zh.wikipedia.org/wiki/蒂姆·伯纳斯-李\" target=\"_blank\" rel=\"noopener\">蒂姆·伯纳斯-李</a>在<a href=\"https://zh.wikipedia.org/wiki/歐洲核子研究組織\" target=\"_blank\" rel=\"noopener\">欧洲核子研究中心</a>（CERN）在承包工程期间，为使CERN的研究人员使用并共享文档，他提出并创建原型系统<a href=\"https://zh.wikipedia.org/wiki/ENQUIRE\" target=\"_blank\" rel=\"noopener\">ENQUIRE</a>。1989年，伯纳斯-李在一份备忘录中提出一个基于<a href=\"https://zh.wikipedia.org/wiki/互联网\" target=\"_blank\" rel=\"noopener\">互联网</a>的<a href=\"https://zh.wikipedia.org/wiki/超文本\" target=\"_blank\" rel=\"noopener\">超文本</a>系统<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-5\" target=\"_blank\" rel=\"noopener\">[5]</a>。他规定HTML并在1990年底写出浏览器和服务器软件。同年，伯纳斯-李与CERN的数据系统工程师<a href=\"https://zh.wikipedia.org/wiki/罗伯特·卡里奥\" target=\"_blank\" rel=\"noopener\">罗伯特·卡里奥</a>联合为项目申请资助，但未被CERN正式批准。在他的个人笔记中<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-6\" target=\"_blank\" rel=\"noopener\">[6]</a>伯纳斯-李列举“一些使用超文本的领域”，并把百科全书列为首位<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-7\" target=\"_blank\" rel=\"noopener\">[7]</a>。<br>HTML的首个公开描述出现于一个名为“HTML标签”的文件中，由蒂姆·伯纳斯-李于1991年底提及<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-tagshtml-8\" target=\"_blank\" rel=\"noopener\">[8]</a><a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-9\" target=\"_blank\" rel=\"noopener\">[9]</a>。它描述18个元素，包括HTML初始的、相对简单的设计。除了超链接标签外，其他设计都深受CERN内部一个以<a href=\"https://zh.wikipedia.org/wiki/SGML\" target=\"_blank\" rel=\"noopener\">标准通用标记语言</a>（SGML）为基础的文件格式SGMLguid的影响。这些元素在HTML 4中仍有11个存在<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-10\" target=\"_blank\" rel=\"noopener\">[10]</a>。<br>伯纳斯-李认为HTML是SGML的一个应用程序。1993年中期<a href=\"https://zh.wikipedia.org/wiki/互联网工程任务组\" target=\"_blank\" rel=\"noopener\">互联网工程任务组</a>（IETF）发布首个HTML规范的提案：<a href=\"http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt\" target=\"_blank\" rel=\"noopener\">“超文本标记语言（HTML）”互联网草案</a>，由伯纳斯-李与<a href=\"https://zh.wikipedia.org/w/index.php?title=丹·康纳利&action=edit&redlink=1\" target=\"_blank\" rel=\"noopener\">丹·康纳利</a>撰写。其中包括一个SGML<a href=\"https://zh.wikipedia.org/wiki/文件类型描述\" target=\"_blank\" rel=\"noopener\">文档类型定义</a>来定义语法<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-11\" target=\"_blank\" rel=\"noopener\">[11]</a>。草案于6个月后过期，不过值得注意的是其对<a href=\"https://zh.wikipedia.org/wiki/NCSA_Mosaic\" target=\"_blank\" rel=\"noopener\">NCSA Mosaic</a>浏览器自定义标签从而将在线图像嵌入的行为的认可，这反映IETF把标准立足于成功原型的理念<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-raymond-12\" target=\"_blank\" rel=\"noopener\">[12]</a>。同样，<a href=\"https://zh.wikipedia.org/w/index.php?title=戴夫·拉格特&action=edit&redlink=1\" target=\"_blank\" rel=\"noopener\">戴夫·拉格特</a>在1993年末提出的与之竞争的互联网草案“HTML+（超文本标记格式）”建议规范已经实现的功能，如表格与填写表单<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-html+-13\" target=\"_blank\" rel=\"noopener\">[13]</a>。</p>\n<p>在HTML和HTML+的草案于1994年初到期后，IETF创建一个HTML工作组，并在1995年完成”HTML 2.0”，这是第一个旨在成为对其后续实现标准的依据的HTML规范<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-14\" target=\"_blank\" rel=\"noopener\">[14]</a>。</p>\n<p>在IETF的主持下，HTML标准的进一步发展因竞争利益而遭受停滞。自1996年起，HTML规范一直由<a href=\"https://zh.wikipedia.org/wiki/万维网联盟\" target=\"_blank\" rel=\"noopener\">万维网联盟</a>（W3C）维护，并由商业软件厂商出资<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-raggett-15\" target=\"_blank\" rel=\"noopener\">[15]</a>。不过在2000年，HTML也成为国际标准（<a href=\"https://zh.wikipedia.org/wiki/國際標準化組織\" target=\"_blank\" rel=\"noopener\">ISO</a>/ <a href=\"https://zh.wikipedia.org/wiki/IEC\" target=\"_blank\" rel=\"noopener\">IEC</a>15445：2000）。HTML 4.01于1999年末发布，进一步的勘误版本于2001年发布。2004年，<a href=\"https://zh.wikipedia.org/wiki/網頁超文本技術工作小組\" target=\"_blank\" rel=\"noopener\">网页超文本应用技术工作小组</a>（WHATWG）开始开发HTML5，并在2008年与W3C共同交付，2014年10月28日完成标准化<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-16\" target=\"_blank\" rel=\"noopener\">[16]</a>。<a href=\"https://en.wikipedia.org/wiki/HTML#cite_note-14\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/HTML#cite_note-14</a>)</p>\n</blockquote>\n<h1 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h1><blockquote>\n<p>1995年11月24日<br>HTML 2.0作为IETF RFC 1866发布。追加RFC的附加功能：<br>1995年11月25日：RFC 1867（基于表单的文件上传）<br>1996年5月：RFC 1942（表格）<br>1996年8月：RFC 1980（客户端图像映射）<br>1997年1月：RFC 2070（国际化）<br>1997年1月14日<br>HTML 3.2[17]作为W3C推荐标准发布。这是首个完全由W3C开发并标准化的版本，因IETF于1996年9月12日关闭它的HTML工作组[18]。<br>最初代号为“威尔伯”（Wilbur）[19]，HTML 3.2完全去除数学公式，协调各种专有扩展，并采用网景设计的大多数视觉标记标签。由于两家公司达成了协议，网景的闪烁元素和微软的滚动元素被移除[15]。HTML对数学公式的支持最后成为另外一种被称为MathML的标准。<br>1997年12月18日<br>HTML 4.0[20]作为W3C推荐标准发布。它提供三种变化：<br>严格，过时的元素被禁止。<br>过渡，过时的元素被允许。<br>框架集，大多只与框架相关的元素被允许。<br>最初代号“美洲狮”（Cougar）[19]， HTML 4.0采用许多特定浏览器的元素类型和属性，并试图淘汰网景的视觉标记功能，将其标记为不赞成使用。HTML 4是遵循ISO 8879 - SGML的SGML应用程序[21]。<br>1998年4月24日<br>HTML 4.0[22]进行微调，不增加版本号。<br>1999年12月24日<br>HTML 4.01[23]作为W3C推荐标准发布。它同样提供三种变化，最终勘误版于2001年5月12日发布。<br>2000年5月<br>ISO/IEC 15445:2000[24][25]（”ISO HTML”，基于HTML 4.01严格版）作为ISO/IEC国际标准发布。在ISO中这一标准位于ISO/IEC JTC 1/SC 34域（ISO/IEC联合技术委员会1、小组委员会34 – 文档描述与处理语言）[24]。<br>2014年10月28日<br>HTML 5[26]作为W3C推荐标准发布[27]。<br>草案时间线</p>\n</blockquote>\n<blockquote>\n<p>HTML5的Logo<br>1991年10月<br>HTML标签[8]，一个非正式CERN文件首次公开18个HTML标签。<br>1992年6月<br>HTML DTD的首个非正式草案[28]， 后续有七个修订版[29][30][31]（7月15日，8月6日，8月18日，11月17日，11月19日，11月20日，11月22日）。<br>1992年11月<br>HTML DTD 1.1（首个版本号，基于RCS修订版，版本号从1.1开始而非1.0），非正式草案。[31]<br>1993年6月<br>超文本标记语言[32]由IETF IIIR工作小组作为互联网草案（一个粗略的建议标准）。在被第二版[33]取代一个月后，IETF又发布6个草案[34]，最终在RFC1866中发布HTML 2.0。<br>1993年11月<br>HTML+由IETF作为互联网草案发布，是超文本标记语言草案的一个竞争性提案。它于1994年5月到期。<br>1995年4月 （1995年3月编写）<br>HTML 3.0[35]被提议作为IETF的标准，但直到提案在五个月过期后（1995年9月28日）[36]仍没有进一步的行动。它包含许多拉格特HTML+提案的功能，如对表格的支持、围绕数据的文本流和复杂的数学公式的显示[36]。W3C开始开发自己的Arena浏览器作为HTML 3和层叠样式表的试验台[37][38][39]，但HTML 3.0并没有获得成功。浏览器厂商，包括微软和网景，选择实现HTML3草案功能的不同子集并引入它们自己的插件（见浏览器大战）[15]。<br>2008年1月<br>HTML5由W3C作为工作草案（链接）发布[40]。虽然HTML5的语法非常类似于SGML，但它已经放弃任何成为SGML应用程序的尝试，除了一种替代的基于XML的HTML5序列，它已明确定义自己的“HTML”序列[41]。<br>2011年 HTML5 – 最终征求<br>2011年5月，工作小组将HTML5推进至“最终征求”（Last Call）阶段，邀请W3C社区内外人士以确认本规范的技术可靠性。W3C开发一套综合性测试包来实现完整规范的广泛交互操作性，完整规范的目标日期为2014年[42]。2011年1月，WHATWG将其“HTML5”活动标准重命名为“HTML”。W3C仍然继续其发布HTML5的项目[43]。<br>2012年 HTML5 – 候选推荐<br>2012年7月，WHATWG和W3C的工作产生一定程度的分离。W3C继续HTML5规范工作，重点放在单一明确的标准上，这被WHATWG称为“快照”。WHATWG组织则将HTML5作为一个“活动标准”（Living Standard）。活动标准的概念是从未完成但永远保持更新与改进，可以蒂姆加新特性，但功能点不会被删除。[44]<br>2012年12月，W3C指定HTML5作为候选推荐[45]阶段。 该阶段的标准为“两个100％完成，完全实现交互操作”。<br>2014年 HTML5 – 提案推荐与推荐<br>2014年9月，HTML5进入提案推荐阶段。[46]<br>2014年10月28日，HTML5作为稳定W3C推荐标准发布[47]，这意味着HTML5的标准化已经完成[48]。<br>XHTML版本<br>主条目：XHTML<br>XHTML是使用XML 1.0改写自HTML 4.01的独立语言。它不再被作为单独标准开发。</p>\n</blockquote>\n<blockquote>\n<p>XHTML 1.0[49]， 2000年1月26日作为W3C推荐标准发布。修订版于2002年8月1日发布，它提供与HTML 4.0和4.01相同的三个变化，这些变化被重新在XML中制定。<br>XHTML 1.1[50]，基于XHTML 1.0 严格版，2001年5月31日 作为W3C推荐标准发布。修订版可使用模块化XHTML的模块，2001年4月10日作为W3C推荐标准发布。<br>XHTML 2.0为工作草案，但为支持HTML5与XHTML5的工作，此草案被放弃[51][52][53]。 XHTML 2.0与XHTML 1.x不兼容，因此更确切的说这是一个XHTML风格的新语言而不是XHTML 1.x的更新。<br>在HTML5草案中规定一个XHTML语法，称为“XHTML5.1”[54]。</p>\n</blockquote>\n<h1 id=\"定义（what）\"><a href=\"#定义（what）\" class=\"headerlink\" title=\"定义（what）\"></a>定义（what）</h1><blockquote>\n<p><strong>超文本标记语言</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，简称：<strong>HTML</strong>）是一种用于创建<a href=\"https://zh.wikipedia.org/wiki/网页\" target=\"_blank\" rel=\"noopener\">网页</a>的标准<a href=\"https://zh.wikipedia.org/wiki/标记语言\" target=\"_blank\" rel=\"noopener\">标记语言</a>。HTML是一种基础技术，常与<a href=\"https://zh.wikipedia.org/wiki/CSS\" target=\"_blank\" rel=\"noopener\">CSS</a>、<a href=\"https://zh.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"noopener\">JavaScript</a>一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-3\" target=\"_blank\" rel=\"noopener\">[3]</a>。<a href=\"https://zh.wikipedia.org/wiki/网页浏览器\" target=\"_blank\" rel=\"noopener\">网页浏览器</a>可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非<a href=\"https://zh.wikipedia.org/wiki/编程语言\" target=\"_blank\" rel=\"noopener\">编程语言</a>。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTML元素\" target=\"_blank\" rel=\"noopener\">HTML元素</a>是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和<a href=\"https://zh.wikipedia.org/wiki/语义\" target=\"_blank\" rel=\"noopener\">语义</a>。HTML的语言形式为<a href=\"https://zh.wikipedia.org/wiki/括号\" target=\"_blank\" rel=\"noopener\">尖括号</a>包围的HTML元素（如<code>&lt;html&gt;</code>），浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上。</p>\n<p>HTML可以嵌入如<a href=\"https://zh.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"noopener\">JavaScript</a>的<a href=\"https://zh.wikipedia.org/wiki/脚本语言\" target=\"_blank\" rel=\"noopener\">脚本语言</a>，它们会影响HTML网页的行为。网页浏览器也可以引用<a href=\"https://zh.wikipedia.org/wiki/层叠样式表\" target=\"_blank\" rel=\"noopener\">层叠样式表</a>（CSS）来定义文本和其它元素的外观与布局。维护HTML和CSS标准的组织<a href=\"https://zh.wikipedia.org/wiki/万维网联盟\" target=\"_blank\" rel=\"noopener\">万维网联盟</a>（W3C）鼓励人们使用CSS替代一些用于表现的HTML元素<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-deprecated-4\" target=\"_blank\" rel=\"noopener\">[4]</a>。</p>\n</blockquote>\n<h1 id=\"标记（what）\"><a href=\"#标记（what）\" class=\"headerlink\" title=\"标记（what）\"></a>标记（what）</h1><p><img src=\"https://tycn.gitbooks.io/css/assets/html.png\" alt=\"img\"></p>\n<h1 id=\"底层核心，dom的渲染过程（HOW）\"><a href=\"#底层核心，dom的渲染过程（HOW）\" class=\"headerlink\" title=\"底层核心，dom的渲染过程（HOW）\"></a>底层核心，dom的渲染过程（HOW）</h1><ol>\n<li>解析HTML，构建DOM树（这里遇到外链，此时会发起请求）</li>\n<li>解析CSS，生成CSS规则树</li>\n<li>合并DOM树和CSS规则，生成render树</li>\n<li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li>\n<li>绘制render树（paint），绘制页面像素信息</li>\n<li>浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上</li>\n</ol>\n<ul>\n<li>reflow(回流): 根据Render Tree布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；</li>\n<li>repaint(重绘): 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；</li>\n</ul>\n<h1 id=\"语义HTML，语义-标签的现状（WHY）\"><a href=\"#语义HTML，语义-标签的现状（WHY）\" class=\"headerlink\" title=\"语义HTML，语义/标签的现状（WHY）\"></a>语义HTML，语义/标签的现状（WHY）</h1><blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"源\"><a href=\"#源\" class=\"headerlink\" title=\"源\"></a>源</h1><p>以下内容摘自wiki百科</p>\n<blockquote>\n<p>1980年，物理学家<a href=\"https://zh.wikipedia.org/wiki/蒂姆·伯纳斯-李\" target=\"_blank\" rel=\"noopener\">蒂姆·伯纳斯-李</a>在<a href=\"https://zh.wikipedia.org/wiki/歐洲核子研究組織\" target=\"_blank\" rel=\"noopener\">欧洲核子研究中心</a>（CERN）在承包工程期间，为使CERN的研究人员使用并共享文档，他提出并创建原型系统<a href=\"https://zh.wikipedia.org/wiki/ENQUIRE\" target=\"_blank\" rel=\"noopener\">ENQUIRE</a>。1989年，伯纳斯-李在一份备忘录中提出一个基于<a href=\"https://zh.wikipedia.org/wiki/互联网\" target=\"_blank\" rel=\"noopener\">互联网</a>的<a href=\"https://zh.wikipedia.org/wiki/超文本\" target=\"_blank\" rel=\"noopener\">超文本</a>系统<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-5\" target=\"_blank\" rel=\"noopener\">[5]</a>。他规定HTML并在1990年底写出浏览器和服务器软件。同年，伯纳斯-李与CERN的数据系统工程师<a href=\"https://zh.wikipedia.org/wiki/罗伯特·卡里奥\" target=\"_blank\" rel=\"noopener\">罗伯特·卡里奥</a>联合为项目申请资助，但未被CERN正式批准。在他的个人笔记中<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-6\" target=\"_blank\" rel=\"noopener\">[6]</a>伯纳斯-李列举“一些使用超文本的领域”，并把百科全书列为首位<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-7\" target=\"_blank\" rel=\"noopener\">[7]</a>。<br>HTML的首个公开描述出现于一个名为“HTML标签”的文件中，由蒂姆·伯纳斯-李于1991年底提及<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-tagshtml-8\" target=\"_blank\" rel=\"noopener\">[8]</a><a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-9\" target=\"_blank\" rel=\"noopener\">[9]</a>。它描述18个元素，包括HTML初始的、相对简单的设计。除了超链接标签外，其他设计都深受CERN内部一个以<a href=\"https://zh.wikipedia.org/wiki/SGML\" target=\"_blank\" rel=\"noopener\">标准通用标记语言</a>（SGML）为基础的文件格式SGMLguid的影响。这些元素在HTML 4中仍有11个存在<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-10\" target=\"_blank\" rel=\"noopener\">[10]</a>。<br>伯纳斯-李认为HTML是SGML的一个应用程序。1993年中期<a href=\"https://zh.wikipedia.org/wiki/互联网工程任务组\" target=\"_blank\" rel=\"noopener\">互联网工程任务组</a>（IETF）发布首个HTML规范的提案：<a href=\"http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt\" target=\"_blank\" rel=\"noopener\">“超文本标记语言（HTML）”互联网草案</a>，由伯纳斯-李与<a href=\"https://zh.wikipedia.org/w/index.php?title=丹·康纳利&action=edit&redlink=1\" target=\"_blank\" rel=\"noopener\">丹·康纳利</a>撰写。其中包括一个SGML<a href=\"https://zh.wikipedia.org/wiki/文件类型描述\" target=\"_blank\" rel=\"noopener\">文档类型定义</a>来定义语法<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-11\" target=\"_blank\" rel=\"noopener\">[11]</a>。草案于6个月后过期，不过值得注意的是其对<a href=\"https://zh.wikipedia.org/wiki/NCSA_Mosaic\" target=\"_blank\" rel=\"noopener\">NCSA Mosaic</a>浏览器自定义标签从而将在线图像嵌入的行为的认可，这反映IETF把标准立足于成功原型的理念<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-raymond-12\" target=\"_blank\" rel=\"noopener\">[12]</a>。同样，<a href=\"https://zh.wikipedia.org/w/index.php?title=戴夫·拉格特&action=edit&redlink=1\" target=\"_blank\" rel=\"noopener\">戴夫·拉格特</a>在1993年末提出的与之竞争的互联网草案“HTML+（超文本标记格式）”建议规范已经实现的功能，如表格与填写表单<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-html+-13\" target=\"_blank\" rel=\"noopener\">[13]</a>。</p>\n<p>在HTML和HTML+的草案于1994年初到期后，IETF创建一个HTML工作组，并在1995年完成”HTML 2.0”，这是第一个旨在成为对其后续实现标准的依据的HTML规范<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-14\" target=\"_blank\" rel=\"noopener\">[14]</a>。</p>\n<p>在IETF的主持下，HTML标准的进一步发展因竞争利益而遭受停滞。自1996年起，HTML规范一直由<a href=\"https://zh.wikipedia.org/wiki/万维网联盟\" target=\"_blank\" rel=\"noopener\">万维网联盟</a>（W3C）维护，并由商业软件厂商出资<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-raggett-15\" target=\"_blank\" rel=\"noopener\">[15]</a>。不过在2000年，HTML也成为国际标准（<a href=\"https://zh.wikipedia.org/wiki/國際標準化組織\" target=\"_blank\" rel=\"noopener\">ISO</a>/ <a href=\"https://zh.wikipedia.org/wiki/IEC\" target=\"_blank\" rel=\"noopener\">IEC</a>15445：2000）。HTML 4.01于1999年末发布，进一步的勘误版本于2001年发布。2004年，<a href=\"https://zh.wikipedia.org/wiki/網頁超文本技術工作小組\" target=\"_blank\" rel=\"noopener\">网页超文本应用技术工作小组</a>（WHATWG）开始开发HTML5，并在2008年与W3C共同交付，2014年10月28日完成标准化<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-16\" target=\"_blank\" rel=\"noopener\">[16]</a>。<a href=\"https://en.wikipedia.org/wiki/HTML#cite_note-14\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/HTML#cite_note-14</a>)</p>\n</blockquote>\n<h1 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h1><blockquote>\n<p>1995年11月24日<br>HTML 2.0作为IETF RFC 1866发布。追加RFC的附加功能：<br>1995年11月25日：RFC 1867（基于表单的文件上传）<br>1996年5月：RFC 1942（表格）<br>1996年8月：RFC 1980（客户端图像映射）<br>1997年1月：RFC 2070（国际化）<br>1997年1月14日<br>HTML 3.2[17]作为W3C推荐标准发布。这是首个完全由W3C开发并标准化的版本，因IETF于1996年9月12日关闭它的HTML工作组[18]。<br>最初代号为“威尔伯”（Wilbur）[19]，HTML 3.2完全去除数学公式，协调各种专有扩展，并采用网景设计的大多数视觉标记标签。由于两家公司达成了协议，网景的闪烁元素和微软的滚动元素被移除[15]。HTML对数学公式的支持最后成为另外一种被称为MathML的标准。<br>1997年12月18日<br>HTML 4.0[20]作为W3C推荐标准发布。它提供三种变化：<br>严格，过时的元素被禁止。<br>过渡，过时的元素被允许。<br>框架集，大多只与框架相关的元素被允许。<br>最初代号“美洲狮”（Cougar）[19]， HTML 4.0采用许多特定浏览器的元素类型和属性，并试图淘汰网景的视觉标记功能，将其标记为不赞成使用。HTML 4是遵循ISO 8879 - SGML的SGML应用程序[21]。<br>1998年4月24日<br>HTML 4.0[22]进行微调，不增加版本号。<br>1999年12月24日<br>HTML 4.01[23]作为W3C推荐标准发布。它同样提供三种变化，最终勘误版于2001年5月12日发布。<br>2000年5月<br>ISO/IEC 15445:2000[24][25]（”ISO HTML”，基于HTML 4.01严格版）作为ISO/IEC国际标准发布。在ISO中这一标准位于ISO/IEC JTC 1/SC 34域（ISO/IEC联合技术委员会1、小组委员会34 – 文档描述与处理语言）[24]。<br>2014年10月28日<br>HTML 5[26]作为W3C推荐标准发布[27]。<br>草案时间线</p>\n</blockquote>\n<blockquote>\n<p>HTML5的Logo<br>1991年10月<br>HTML标签[8]，一个非正式CERN文件首次公开18个HTML标签。<br>1992年6月<br>HTML DTD的首个非正式草案[28]， 后续有七个修订版[29][30][31]（7月15日，8月6日，8月18日，11月17日，11月19日，11月20日，11月22日）。<br>1992年11月<br>HTML DTD 1.1（首个版本号，基于RCS修订版，版本号从1.1开始而非1.0），非正式草案。[31]<br>1993年6月<br>超文本标记语言[32]由IETF IIIR工作小组作为互联网草案（一个粗略的建议标准）。在被第二版[33]取代一个月后，IETF又发布6个草案[34]，最终在RFC1866中发布HTML 2.0。<br>1993年11月<br>HTML+由IETF作为互联网草案发布，是超文本标记语言草案的一个竞争性提案。它于1994年5月到期。<br>1995年4月 （1995年3月编写）<br>HTML 3.0[35]被提议作为IETF的标准，但直到提案在五个月过期后（1995年9月28日）[36]仍没有进一步的行动。它包含许多拉格特HTML+提案的功能，如对表格的支持、围绕数据的文本流和复杂的数学公式的显示[36]。W3C开始开发自己的Arena浏览器作为HTML 3和层叠样式表的试验台[37][38][39]，但HTML 3.0并没有获得成功。浏览器厂商，包括微软和网景，选择实现HTML3草案功能的不同子集并引入它们自己的插件（见浏览器大战）[15]。<br>2008年1月<br>HTML5由W3C作为工作草案（链接）发布[40]。虽然HTML5的语法非常类似于SGML，但它已经放弃任何成为SGML应用程序的尝试，除了一种替代的基于XML的HTML5序列，它已明确定义自己的“HTML”序列[41]。<br>2011年 HTML5 – 最终征求<br>2011年5月，工作小组将HTML5推进至“最终征求”（Last Call）阶段，邀请W3C社区内外人士以确认本规范的技术可靠性。W3C开发一套综合性测试包来实现完整规范的广泛交互操作性，完整规范的目标日期为2014年[42]。2011年1月，WHATWG将其“HTML5”活动标准重命名为“HTML”。W3C仍然继续其发布HTML5的项目[43]。<br>2012年 HTML5 – 候选推荐<br>2012年7月，WHATWG和W3C的工作产生一定程度的分离。W3C继续HTML5规范工作，重点放在单一明确的标准上，这被WHATWG称为“快照”。WHATWG组织则将HTML5作为一个“活动标准”（Living Standard）。活动标准的概念是从未完成但永远保持更新与改进，可以蒂姆加新特性，但功能点不会被删除。[44]<br>2012年12月，W3C指定HTML5作为候选推荐[45]阶段。 该阶段的标准为“两个100％完成，完全实现交互操作”。<br>2014年 HTML5 – 提案推荐与推荐<br>2014年9月，HTML5进入提案推荐阶段。[46]<br>2014年10月28日，HTML5作为稳定W3C推荐标准发布[47]，这意味着HTML5的标准化已经完成[48]。<br>XHTML版本<br>主条目：XHTML<br>XHTML是使用XML 1.0改写自HTML 4.01的独立语言。它不再被作为单独标准开发。</p>\n</blockquote>\n<blockquote>\n<p>XHTML 1.0[49]， 2000年1月26日作为W3C推荐标准发布。修订版于2002年8月1日发布，它提供与HTML 4.0和4.01相同的三个变化，这些变化被重新在XML中制定。<br>XHTML 1.1[50]，基于XHTML 1.0 严格版，2001年5月31日 作为W3C推荐标准发布。修订版可使用模块化XHTML的模块，2001年4月10日作为W3C推荐标准发布。<br>XHTML 2.0为工作草案，但为支持HTML5与XHTML5的工作，此草案被放弃[51][52][53]。 XHTML 2.0与XHTML 1.x不兼容，因此更确切的说这是一个XHTML风格的新语言而不是XHTML 1.x的更新。<br>在HTML5草案中规定一个XHTML语法，称为“XHTML5.1”[54]。</p>\n</blockquote>\n<h1 id=\"定义（what）\"><a href=\"#定义（what）\" class=\"headerlink\" title=\"定义（what）\"></a>定义（what）</h1><blockquote>\n<p><strong>超文本标记语言</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，简称：<strong>HTML</strong>）是一种用于创建<a href=\"https://zh.wikipedia.org/wiki/网页\" target=\"_blank\" rel=\"noopener\">网页</a>的标准<a href=\"https://zh.wikipedia.org/wiki/标记语言\" target=\"_blank\" rel=\"noopener\">标记语言</a>。HTML是一种基础技术，常与<a href=\"https://zh.wikipedia.org/wiki/CSS\" target=\"_blank\" rel=\"noopener\">CSS</a>、<a href=\"https://zh.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"noopener\">JavaScript</a>一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-3\" target=\"_blank\" rel=\"noopener\">[3]</a>。<a href=\"https://zh.wikipedia.org/wiki/网页浏览器\" target=\"_blank\" rel=\"noopener\">网页浏览器</a>可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非<a href=\"https://zh.wikipedia.org/wiki/编程语言\" target=\"_blank\" rel=\"noopener\">编程语言</a>。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTML元素\" target=\"_blank\" rel=\"noopener\">HTML元素</a>是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和<a href=\"https://zh.wikipedia.org/wiki/语义\" target=\"_blank\" rel=\"noopener\">语义</a>。HTML的语言形式为<a href=\"https://zh.wikipedia.org/wiki/括号\" target=\"_blank\" rel=\"noopener\">尖括号</a>包围的HTML元素（如<code>&lt;html&gt;</code>），浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上。</p>\n<p>HTML可以嵌入如<a href=\"https://zh.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"noopener\">JavaScript</a>的<a href=\"https://zh.wikipedia.org/wiki/脚本语言\" target=\"_blank\" rel=\"noopener\">脚本语言</a>，它们会影响HTML网页的行为。网页浏览器也可以引用<a href=\"https://zh.wikipedia.org/wiki/层叠样式表\" target=\"_blank\" rel=\"noopener\">层叠样式表</a>（CSS）来定义文本和其它元素的外观与布局。维护HTML和CSS标准的组织<a href=\"https://zh.wikipedia.org/wiki/万维网联盟\" target=\"_blank\" rel=\"noopener\">万维网联盟</a>（W3C）鼓励人们使用CSS替代一些用于表现的HTML元素<a href=\"https://zh.wikipedia.org/wiki/HTML#cite_note-deprecated-4\" target=\"_blank\" rel=\"noopener\">[4]</a>。</p>\n</blockquote>\n<h1 id=\"标记（what）\"><a href=\"#标记（what）\" class=\"headerlink\" title=\"标记（what）\"></a>标记（what）</h1><p><img src=\"https://tycn.gitbooks.io/css/assets/html.png\" alt=\"img\"></p>\n<h1 id=\"底层核心，dom的渲染过程（HOW）\"><a href=\"#底层核心，dom的渲染过程（HOW）\" class=\"headerlink\" title=\"底层核心，dom的渲染过程（HOW）\"></a>底层核心，dom的渲染过程（HOW）</h1><ol>\n<li>解析HTML，构建DOM树（这里遇到外链，此时会发起请求）</li>\n<li>解析CSS，生成CSS规则树</li>\n<li>合并DOM树和CSS规则，生成render树</li>\n<li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li>\n<li>绘制render树（paint），绘制页面像素信息</li>\n<li>浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上</li>\n</ol>\n<ul>\n<li>reflow(回流): 根据Render Tree布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；</li>\n<li>repaint(重绘): 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；</li>\n</ul>\n<h1 id=\"语义HTML，语义-标签的现状（WHY）\"><a href=\"#语义HTML，语义-标签的现状（WHY）\" class=\"headerlink\" title=\"语义HTML，语义/标签的现状（WHY）\"></a>语义HTML，语义/标签的现状（WHY）</h1><blockquote>\n</blockquote>\n"},{"_content":"[TOC]\n\n\n\n# 变量和类型\n\n## JavaScript规定了几种类型\n\n> 基本数据类型：Null、Undefined、Number，String，Boolean。\n>\n> 复杂数据类型：Object，Array\n\n## JavaScript对象的底层数据结构是什么\n\n> \n\n## Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\n\n>  使用Symbol来替代常量,并且别人无法通过外部调用到内部的这个参数的值。主要还是作为对象属性名（key），特性是绝对唯一！\n```javascript\n(function() {\n var root = this;\n\n var generateName = (function(){\n     var postfix = 0;\n     return function(descString){\n         postfix++;\n         return '@@' + descString + '_' + postfix\n     }\n })()\n\n var SymbolPolyfill = function Symbol(description) {\n\n     if (this instanceof SymbolPolyfill) throw new TypeError('Symbol is not a constructor');\n\n     var descString = description === undefined ? undefined : String(description)\n\n     var symbol = Object.create({\n         toString: function() {\n             return this.__Name__;\n         },\n         valueOf: function() {\n             return this;\n         }\n     })\n\n     Object.defineProperties(symbol, {\n         '__Description__': {\n             value: descString,\n             writable: false,\n             enumerable: false,\n             configurable: false\n         },\n         '__Name__': {\n             value: generateName(descString),\n             writable: false,\n             enumerable: false,\n             configurable: false\n         }\n     });\n\n     return symbol;\n }\n\n var forMap = {};\n\n Object.defineProperties(SymbolPolyfill, {\n     'for': {\n         value: function(description) {\n             var descString = description === undefined ? undefined : String(description)\n             return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);\n         },\n         writable: true,\n         enumerable: false,\n         configurable: true\n     },\n     'keyFor': {\n         value: function(symbol) {\n             for (var key in forMap) {\n                 if (forMap[key] === symbol) return key;\n             }\n         },\n         writable: true,\n         enumerable: false,\n         configurable: true\n     }\n });\n\n root.SymbolPolyfill = SymbolPolyfill;\n })()\n```\n## JavaScript中的变量在内存中的具体存储形式\n\n\n\n> 值类型和引用类型。存在堆和栈中。 如图所示:![å¾çæè¿°](https://segmentfault.com/img/bVCuzt?w=579&h=182)\n>\n> ### 堆&栈:\n>\n> 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 \n> 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。 \n> 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； \n> 栈（数据结构）：一种先进后出的数据结构。\n>\n> 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\n> 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序\n## 基本类型对应的内置对象，以及他们之间的装箱拆箱操作\n\n装箱：所谓装箱，就是把基本类型转变为对应的对象。装箱分为隐式和显示。\nstring（显示装箱），bool（显示装箱）,number(隐式装箱),object,null.\n\n拆箱：拆箱与装箱相反，把对象转变为基本类型的值。拆箱过程内部调用了抽象操作 ToPrimitive 。ToPrimitive 先检查对象是否有 valueOf 方法，如果有则再检查 valueOf 方法是否有基本类型的返回值。如果没有 valueOf 方法或 valueOf 方法没有返回值，则调用 toString 方法。如果 toString 方法也没有返回值，产生 TypeError 错误。\n\n## 理解值类型和引用类型\n\n> 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。\n>\n> 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。\n\n## null和undefined的区别 \n\n> null表示\"没有对象\"，即该处不应该有值。undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。\n\n## 至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\n\n> **typeof** \n>\n> - 对于基本类型，除 null 以外，均可以返回正确的结果。\n>\n> - 对于引用类型，除 function 以外，一律返回 object 类型。\n>\n> - 对于 null ，返回 object 类型。\n>\n> - 对于 function 返回  function 类型。\n>\n>   \n\n> ### **instanceof**\n>\n> instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型\n\n> ### **constructor**\n>\n>  null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。\n>\n> 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object\n\n## 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\n\n> 隐式转换中主要涉及到三种转换：\n>\n> 1、将值转为原始值，ToPrimitive()。\n>\n> 2、将值转为数字，ToNumber()。\n>\n> 3、将值转为字符串，ToString()\n>\n>  如何避免：使用ts。巧妙应用：尽量不要用\n\n## 出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\n\n> 发生场景： 0.1 + 0.2 === 0.30000000000000004\n>\n> 细致分析原因：是浮点数存储本身固有的缺陷。浮点数无法精确表示其数值范围内的所有数值，只能精确表示可用科学计数法 m*2^e 表示的数值而已，比如0.5的科学计数法是2^(-1)，则可被精确存储；而0.1、0.2则无法被精确存储\n>\n> (0.1).toString('2') // \"0.0001100110011001100110011001100110011001100110011001101\" \n>\n> (0.2).toString('2') // \"0.001100110011001100110011001100110011001100110011001101\"\n>\n>  (0.1+0.2).toString('2') // \"0.0100110011001100110011001100110011001100110011001101\" \n>\n> (0.3).toString('2') // \"0.010011001100110011001100110011001100110011001100110011\"\n\n\n\n#### ES6解决方案\n\nES6在Number对象上新增了一个极小的常量——Number.EPSILON\n\n```\nNumber.EPSILON\n// 2.220446049250313e-16\nNumber.EPSILON.toFixed(20)\n// \"0.00000000000000022204\"\n复制代码\n```\n\n引入一个这么小的量，目的在于为浮点数计算设置一个误差范围，如果误差能够小于Number.EPSILON，我们就可以认为结果是可靠的。\n\n误差检查函数（出自《ES6标准入门》-阮一峰）\n\n```\nfunction withinErrorMargin (left, right) {\n    return Math.abs(left - right) < Number.EPSILON\n}\nwithinErrorMargin(0.1+0.2, 0.3)\n```\n\n\n\n\n# 原型和原型链\n\n## 理解原型设计模式以及JavaScript中的原型规则\n\n\n\n## instanceof的底层实现原理，手动实现一个instanceof\n\n```\nfunction my_instanceof(obj, constructor) {\n  let constuctProto = constructor.prototype\n  while (true) {\n    if (obj.__protp__ === null) {\n      // 遍历完对象的原型链\n      return false\n    }\n    if (obj.__proto__ === constuctProto) {\n      return true\n    }\n    obj = obj.__proto__\n  }\n}\n```\n\n\n\n4.实现继承的几种方式以及他们的优缺点\n\n> 1. prototype\n> 2. extend\n> 3. create\n\n5.至少说出一种开源项目(如Node)中应用原型继承的案例\n\n6.可以描述new一个对象的详细过程，手动实现一个new操作符\n\n> 首先新建一个 new Object() //这里是不是有问题， 如果新建一个{}还可以说说\n>\n> 然后吧argumentsy映射到新建的对象上（引用地址）\n>\n> 把原型链映射到新建的对象上\n\n7.理解es6 class构造以及继承的底层实现原理\n\n> 应该就是语法糖，对于prototype的优化把\n\n作用域和闭包\n1.理解词法作用域和动态作用域\n\n>作用域是指程序源代码中定义变量的区域。\n>\n>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n>\n>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。\n\n \n\n2.理解JavaScript的作用域和作用域链\n\n> ### 全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象\n>\n> ### 局部作用域(Local Scope)\n>\n> ## 作用域链(Scope Chain)：所有的变量都会向上寻找表示\n>\n> ### 代码优化\n>\n> 从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。\n>\n> \n\n3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题\n\n>\n>\n>无法叙述\n\n4.this的原理以及几种不同使用场景的取值\n\n>\n>\n>因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。\n>\n>\n\n#### 情况一：全局 & 调用普通函数\n\n在全局环境中，this 永远指向 window。\n\n```\nconsole.log(this === window);     //true\n```\n\n普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。\n\n```\nvar x = 10;\nfunction foo(){\n    console.log(this);     //Window\n    console.log(this.x);   //10\n}\nfoo();\n```\n\n#### 情况二：构造函数\n\n所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。\n\n```\nfunction Foo(){\n    this.x = 10;\n    console.log(this);    //Foo {x:10}\n}\nvar foo = new Foo();\nconsole.log(foo.x);      //10\n```\n\n上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。\n\n但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。\n\n```\nfunction Foo(){\n    this.x = 10;\n    console.log(this);    //Window\n}\nvar foo = Foo();\nconsole.log(foo.x);      //undefined\n```\n\n#### 情况三：对象方法\n\n如果函数作为对象的方法时，方法中的 this 指向该对象。\n\n```\nvar obj = {\n    x: 10,\n    foo: function () {\n        console.log(this);        //Object\n        console.log(this.x);      //10\n    }\n};\nobj.foo();\n```\n\n**注意：若是在对象方法中定义函数，那么情况就不同了。**\n\n```\nvar obj = {\n    x: 10,\n    foo: function () {\n        function f(){\n            console.log(this);      //Window\n            console.log(this.x);    //undefined\n        }\n        f();\n    }\n}\nobj.foo();\n```\n\n可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。\n\n在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。\n\n```\nvar obj = {\n    x: 10,\n    foo: function () {\n        var self = this;\n        function f(){\n            console.log(self);      //{x: 10}\n            console.log(self.x);    //10\n        }\n        f();\n    }\n}\nobj.foo();\n```\n\n如果 foo 函数不作为对象方法被调用：\n\n```\nvar obj = {\n    x: 10,\n    foo: function () {\n        console.log(this);       //Window\n        console.log(this.x);     //undefined\n    }\n};\nvar fn = obj.foo;\nfn();\n```\n\nobj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。\n\n#### 情况四：构造函数 prototype 属性\n\n```\nfunction Foo(){\n    this.x = 10;\n}\nFoo.prototype.getX = function () {\n    console.log(this);        //Foo {x: 10, getX: function}\n    console.log(this.x);      //10\n}\nvar foo = new Foo();\nfoo.getX();\n```\n\n在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。\n\n#### 情况五：函数用 call、apply或者 bind 调用。\n\n```\nvar obj = {\n    x: 10\n}\nfunction foo(){\n    console.log(this);     //{x: 10}\n    console.log(this.x);   //10\n}\nfoo.call(obj);\nfoo.apply(obj);\nfoo.bind(obj)();\n```\n\n当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。\n\n#### 情况六：DOM event this\n\n在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点：\n\n```\nfunction Listener(){   \n    document.getElementById('foo').addEventListener('click', this.handleClick);     //这里的 this 指向 Listener 这个对象。不是强调的是这里的 this\n}\nListener.prototype.handleClick = function (event) {\n    console.log(this);    //<div id=\"foo\"></div>\n}\nvar listener = new Listener();\ndocument.getElementById('foo').click();\n```\n\n这个很好理解，就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码：\n\n```\nvar obj = {\n    x: 10,\n    fn: function() {\n        console.log(this);         //Window\n        console.log(this.x);       //undefined\n    }\n};\nfunction foo(fn) {\n    fn();\n} \nfoo(obj.fn);\n```\n\n你也可以用通过 bind 切换上下文:\n\n```\nfunction  Listener(){\n    document.getElementById('foo').addEventListener('click',this.handleClick.bind(this));      \n}\nListener.prototype.handleClick = function (event) {\n    console.log(this);    //Listener {}\n}\nvar listener = new Listener();\ndocument.getElementById('foo').click();\n```\n\n前六种情况其实可以总结为： this 指向调用该方法的对象。\n\n#### 情况七：箭头函数中的 this\n\n当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。\n\n```\nvar obj = {\n    x: 10,\n    foo: function() {\n        var fn = () => {\n            return () => {\n                return () => {\n                    console.log(this);      //Object {x: 10}\n                    console.log(this.x);    //10\n                }\n            }\n        }\n        fn()()();\n    }\n}\nobj.foo();\n```\n\n现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。\n\n如果使用箭头函数，以前的这种 hack 写法：\n\n```\nvar self = this;\n```\n\n就不再需要了。\n\n```\nvar obj = {\n    x: 10,\n    foo: function() {\n        var fn = () => {\n            return () => {\n                return () => {\n                    console.log(this);    // Object {x: 10}\n                    console.log(this.x);  //10\n                }\n            }\n        }\n        fn.bind({x: 14})()()();\n        fn.call({x: 14})()();\n    }\n}\nobj.foo();\n```\n\n由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。\n\n## 5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\n\nJavaScript闭包的形成原理是基于函数变量作用域链的规则 和 垃圾回收机制的引用计数规则。 \nJavaScript闭包的本质是内存泄漏，指定内存不释放。 \n\n应用：私有变量\n\n##6.理解堆栈溢出和内存泄漏的原理，如何防止\n\n溢出：没有足够的内存空间供其使用，泄漏：GC没起作用，闭包。防止闭包\n\n# 7.如何处理循环的异步操作\n\npromise.all\n\n#8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理\n\namd cmd umd    -》sea require npm\n\n(function(a){\n\nreturm {\n\na:1\n\n}\n})(1)\n\n#执行机制\n##1.为何try里面放return，finally还会执行，理解其内部机制\n\n类似promise？\n\n##2.JavaScript如何实现异步编程，可以详细描述EventLoop机制\n\n一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。\n\n在[事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#Event_loop)期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\n\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。\n\n```js\nwhile (queue.waitForMessage()) {\n  queue.processNextMessage();\n}\n```\n\n##3.宏任务和微任务分别有哪些\n\n4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法\n\n分清楚 promise await settimeout的执行顺序\n\n5.使用Promise实现串行\n\n找一个第三方的缓存，把状态缓存住就行了\n\n6.Node与浏览器EventLoop的差异\n\n7.如何在保证页面运行流畅的情况下处理海量数据\n\n不加载海量dom\n\n语法和API\n1.理解ECMAScript和JavaScript的关系\n\nECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。(蹭热度)\n\n2.熟练运用es5、es6提供的语法规范，\n\n3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）\n\n4.熟练应用map、reduce、filter 等高阶函数解决问题\n\n5.setInterval需要注意的点，使用settimeout实现setInterval\n\n6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题\n\n7.JavaScript异常处理的方式，统一的异常处理方案\n\n\n\nHTML和CSS\n\nHTML\n1.从规范的角度理解HTML，从分类和语义的角度使用标签\n\n早期语义化是为SEO和规范，目前原生的语义化作用很弱，更多体现在js框架中组件的语义化\n\n2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式\n\n\n\n3.元信息类标签(head、title、meta)的使用目的和配置方法\n\n4.HTML5离线缓存原理\n\n5.可以使用Canvas API、SVG等绘制高性能的动画\n\nCSS\n1.CSS盒模型，在不同浏览器的差异\n\n2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则\n\n3.CSS伪类和伪元素有哪些，它们的区别和实际应用\n\n4.HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理\n\n5.水平垂直居中的方案、可以实现6种以上并对比它们的优缺点\n\n6.BFC实现原理，可以解决的问题，如何创建BFC\n\n7.可使用CSS函数复用代码，实现特殊效果\n\n8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种\n\n9.CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染\n\n10.熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等\n\n11.CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况\n\n12.掌握一套完整的响应式布局方案\n\n手写\n1.手写图片瀑布流效果\n\n2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）\n\n3.使用纯CSS实现曲线运动（贝塞尔曲线）\n\n4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点\n\n\n\n计算机基础\n关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要。\n编译原理\n1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序\n\n2.正则表达式的匹配原理和性能优化\n\n3.如何将JavaScript代码解析成抽象语法树(AST)\n\n4.base64的编码原理\n\n5.几种进制的相互转换计算方法，在JavaScript中如何表示和转换\n\n网络协议\n1.理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用\n\n2.三次握手和四次挥手详细原理，为什么要使用这种机制\n\n3.有哪些协议是可靠，TCP有哪些手段保证可靠交付\n\n4.DNS的作用、DNS解析的详细过程，DNS优化原理\n\n5.CDN的作用和原理\n\n6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么\n\n7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题\n\n8.HTTP1.1、HTTP2.0带来的改变\n\n9.HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求\n\n10.理解WebSocket协议的底层原理、与HTTP的区别\n\n设计模式\n1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等\n\n2.发布订阅模式和观察者模式的异同以及实际应用\n\n3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用\n\n\n\n数据结构和算法\n据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！\n\n\nJavaScript编码能力\n1.多种方式实现数组去重、扁平化、对比优缺点\n\n2.多种方式实现深拷贝、对比优缺点\n\n3.手写函数柯里化工具函数、并理解其应用场景和优势\n\n4.手写防抖和节流工具函数、并理解其内部原理和应用场景\n\n5.实现一个sleep函数\n\n手动实现前端轮子\n1.手动实现call、apply、bind\n\n2.手动实现符合Promise/A+规范的Promise、手动实现async await\n\n3.手写一个EventEmitter实现事件发布、订阅\n\n4.可以说出两种实现双向绑定的方案、可以手动实现\n\n5.手写JSON.stringify、JSON.parse\n\n6.手写一个模版引擎，并能解释其中原理\n\n7.手写懒加载、下拉刷新、上拉加载、预加载等效果\n\n数据结构\n1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点\n\n2.理解数组、字符串的存储原理，并熟练应用他们解决问题\n\n3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题\n\n4.了解图、堆的基本结构和使用场景\n\n算法\n1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗\n\n2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度\n\n3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用\n\n4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题\n\n5.前端处理海量数据的算法方案\n\n\n\n运行环境\n我们需要理清语言和环境的关系：\nECMAScript描述了JavaScript语言的语法和基本对象规范\n\n浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口\n\nNode也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API\n\n\n\n浏览器API\n1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性\n\n2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性\n\n3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)\n\n4.浏览器海量数据存储、操作性能优化\n\n5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理\n\n6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库\n\n7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型\n\n8.浏览器提供的几种存储机制、优缺点、开发中正确的选择\n\n9.浏览器跨标签通信\n\n浏览器原理\n1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分\n\n2.请求数据到请求结束与服务器进行了几次交互\n\n3.可详细描述浏览器从输入URL到页面展现的详细过程\n\n4.浏览器解析HTML代码的原理，以及构建DOM树的流程\n\n5.浏览器如何解析CSS规则，并将其应用到DOM树上\n\n6.浏览器如何将解析好的带有样式的DOM树进行绘制\n\n7.浏览器的运行机制，如何配置资源异步同步加载\n\n8.浏览器回流与重绘的底层原理，引发原因，如何有效避免\n\n9.浏览器的垃圾回收机制，如何避免内存泄漏\n\n10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案\n\nNode\n1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等\n\n2.掌握一种Node开发框架，如Express，Express和Koa的区别\n\n3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理\n\n4.Node的底层运行原理、和浏览器的异同\n\n5.Node事件驱动、非阻塞机制的实现原理\n\n\n\n框架和类库\n轮子层出不穷，从原理上理解才是正道\nTypeScript\n1.理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现\n\n2.理解使用TypeScript的好处，掌握TypeScript基础语法\n\n3.TypeScript的规则检测原理\n\n4.可以在React、Vue等框架中使用TypeScript进行开发\n\nReact\n1.React和vue 选型和优缺点、核心架构的区别\n\n2.React中setState的执行机制，如何有效的管理状态\n\n3.React的事件底层实现机制\n\n4.React的虚拟DOM和Diff算法的内部实现\n\n5.React的Fiber工作原理，解决了什么问题\n\n6.React Router和Vue Router的底层实现原理、动态加载实现原理\n\n7.可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题\n\n8.基于React的特性和原理，可以手动实现一个简单的React\n\nVue\n1.熟练使用Vue的API、生命周期、钩子函数\n\n2.MVVM框架设计理念\n\n3.Vue双向绑定实现原理、Diff算法的内部实现\n\n4.Vue的事件机制\n\n5.从template转换成真实DOM的实现机制\n\n多端开发\n1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案\n\n2.理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用\n\n3.移动端页面适配解决方案、不同机型适配方案\n\n4.掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配\n\n5.掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理\n\n6.掌握一种小程序开发框架或原生小程序开发\n\n7.理解多端框架的内部实现原理，至少了解一个多端框架的使用\n\n数据流管理\n1.掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同\n\n2.熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理\n\n3.熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势\n\n4.熟练使用Vuex管理数据流，并理解其实现原理\n\n5.以上数据流方案的异同和优缺点，不情况下的技术选型\n\n实用库\n1.至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现\n\n2.掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表\n\n3.掌握一种GIS开发框架，如百度地图API\n\n4.掌握一种可视化开发框架，如Three.js、D3\n\n5.工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理\n\n开发和调试\n1.熟练使用各浏览器提供的调试工具\n\n2.熟练使用一种代理工具实现请求代理、抓包，如charls\n\n3.可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案\n\n4.了解Vue、React等框架调试工具的使用\n\n\n\n前端工程\n前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度\n项目构建\n1.理解npm、yarn依赖包管理的原理，两者的区别\n\n2.可以使用npm运行自定义脚本\n\n3.理解Babel、ESLint、webpack等工具在项目中承担的作用\n\n4.ESLint规则检测原理，常用的ESLint配置\n\n5.Babel的核心原理，可以自己编写一个Babel插件\n\n6.可以配置一种前端代码兼容方案，如Polyfill\n\n7.Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用\n\n8.可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins\n\nnginx\n1.正向代理与反向代理的特点和实例\n\n2.可手动搭建一个简单的nginx服务器、\n\n3.熟练应用常用的nginx内置变量，掌握常用的匹配规则写法\n\n4.可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理\n\n开发提速\n1.熟练掌握一种接口管理、接口mock工具的使用，如yapi\n\n2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题\n\n3.理解TDD与BDD模式，至少会使用一种前端单元测试框架\n\n版本控制\n1.理解Git的核心原理、工作流程、和SVN的区别\n\n2.熟练使用常规的Git命令、git rebase、git stash等进阶命令\n\n3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题\n\n持续集成\n1.理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins\n\n2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）\n\n\n\n项目和业务\n\n\n后端技能\n1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言\n\n2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库\n\n性能优化\n1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案\n\n2.了解常见的Web、App性能优化方案\n\n3.SEO排名规则、SEO优化方案、前后端分离的SEO\n\n4.SSR实现方案、优缺点、及其性能优化\n\n5.Webpack的性能优化方案\n\n6.Canvas性能优化方案\n\n7.React、Vue等框架使用性能优化方案\n\n前端安全\n1.XSS攻击的原理、分类、具体案例，前端如何防御\n\n2.CSRF攻击的原理、具体案例，前端如何防御\n\n3.HTTP劫持、页面劫持的原理、防御措施\n\n业务相关\n1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题\n\n2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题\n\n3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性\n\n\n\n学习提升\n\n\nvczh大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答：\n\n这十几年我一共做了三件事：\n\n1、不以赚钱为目的选择学习的内容；\n\n2、以自己是否能造出轮子来衡量学习的效果；\n\n3、坚持每天写自己的代码，前10年每天至少6个小时，不包含学习和工作的时间。\n\n上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。\n\n关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多\n\n1.拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏\n\n2.定期的将知识进行总结，不断完善自己的知识体系\n\n3.尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用\n\n4.坚持输出自己的代码，不要盲目的扎进公司业\n\n\n\n技术之外\n\n\n这部分可能比上面九条加起来重要！\n\n1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS等\n\n2.了解互联网行业术语：B2B、B2C、C2C、O2O等\n\n3.掌握互联网行业沟通、问答、学习的\n\n4.有一定的\"PPT\"能力\n\n5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识\n\n6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系\n.如何理解 JS 中的this关键字？\n1. 由于 this 关键字很混乱，如何解决这个问题\n  3.什么是闭包\n  4.解释一下变量的提升\n2. JavaScript如何处理同步和异步情况\n3. 如何理解事件委托\n4. 如何理解高阶函数。\n5. 如何区分声明函数和表达式函数\n6. 解释一下严格模式(strict mode)\n","source":"_posts/每日一问.md","raw":"[TOC]\n\n\n\n# 变量和类型\n\n## JavaScript规定了几种类型\n\n> 基本数据类型：Null、Undefined、Number，String，Boolean。\n>\n> 复杂数据类型：Object，Array\n\n## JavaScript对象的底层数据结构是什么\n\n> \n\n## Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\n\n>  使用Symbol来替代常量,并且别人无法通过外部调用到内部的这个参数的值。主要还是作为对象属性名（key），特性是绝对唯一！\n```javascript\n(function() {\n var root = this;\n\n var generateName = (function(){\n     var postfix = 0;\n     return function(descString){\n         postfix++;\n         return '@@' + descString + '_' + postfix\n     }\n })()\n\n var SymbolPolyfill = function Symbol(description) {\n\n     if (this instanceof SymbolPolyfill) throw new TypeError('Symbol is not a constructor');\n\n     var descString = description === undefined ? undefined : String(description)\n\n     var symbol = Object.create({\n         toString: function() {\n             return this.__Name__;\n         },\n         valueOf: function() {\n             return this;\n         }\n     })\n\n     Object.defineProperties(symbol, {\n         '__Description__': {\n             value: descString,\n             writable: false,\n             enumerable: false,\n             configurable: false\n         },\n         '__Name__': {\n             value: generateName(descString),\n             writable: false,\n             enumerable: false,\n             configurable: false\n         }\n     });\n\n     return symbol;\n }\n\n var forMap = {};\n\n Object.defineProperties(SymbolPolyfill, {\n     'for': {\n         value: function(description) {\n             var descString = description === undefined ? undefined : String(description)\n             return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);\n         },\n         writable: true,\n         enumerable: false,\n         configurable: true\n     },\n     'keyFor': {\n         value: function(symbol) {\n             for (var key in forMap) {\n                 if (forMap[key] === symbol) return key;\n             }\n         },\n         writable: true,\n         enumerable: false,\n         configurable: true\n     }\n });\n\n root.SymbolPolyfill = SymbolPolyfill;\n })()\n```\n## JavaScript中的变量在内存中的具体存储形式\n\n\n\n> 值类型和引用类型。存在堆和栈中。 如图所示:![å¾çæè¿°](https://segmentfault.com/img/bVCuzt?w=579&h=182)\n>\n> ### 堆&栈:\n>\n> 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 \n> 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。 \n> 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； \n> 栈（数据结构）：一种先进后出的数据结构。\n>\n> 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\n> 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序\n## 基本类型对应的内置对象，以及他们之间的装箱拆箱操作\n\n装箱：所谓装箱，就是把基本类型转变为对应的对象。装箱分为隐式和显示。\nstring（显示装箱），bool（显示装箱）,number(隐式装箱),object,null.\n\n拆箱：拆箱与装箱相反，把对象转变为基本类型的值。拆箱过程内部调用了抽象操作 ToPrimitive 。ToPrimitive 先检查对象是否有 valueOf 方法，如果有则再检查 valueOf 方法是否有基本类型的返回值。如果没有 valueOf 方法或 valueOf 方法没有返回值，则调用 toString 方法。如果 toString 方法也没有返回值，产生 TypeError 错误。\n\n## 理解值类型和引用类型\n\n> 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。\n>\n> 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。\n\n## null和undefined的区别 \n\n> null表示\"没有对象\"，即该处不应该有值。undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。\n\n## 至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\n\n> **typeof** \n>\n> - 对于基本类型，除 null 以外，均可以返回正确的结果。\n>\n> - 对于引用类型，除 function 以外，一律返回 object 类型。\n>\n> - 对于 null ，返回 object 类型。\n>\n> - 对于 function 返回  function 类型。\n>\n>   \n\n> ### **instanceof**\n>\n> instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型\n\n> ### **constructor**\n>\n>  null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。\n>\n> 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object\n\n## 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\n\n> 隐式转换中主要涉及到三种转换：\n>\n> 1、将值转为原始值，ToPrimitive()。\n>\n> 2、将值转为数字，ToNumber()。\n>\n> 3、将值转为字符串，ToString()\n>\n>  如何避免：使用ts。巧妙应用：尽量不要用\n\n## 出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\n\n> 发生场景： 0.1 + 0.2 === 0.30000000000000004\n>\n> 细致分析原因：是浮点数存储本身固有的缺陷。浮点数无法精确表示其数值范围内的所有数值，只能精确表示可用科学计数法 m*2^e 表示的数值而已，比如0.5的科学计数法是2^(-1)，则可被精确存储；而0.1、0.2则无法被精确存储\n>\n> (0.1).toString('2') // \"0.0001100110011001100110011001100110011001100110011001101\" \n>\n> (0.2).toString('2') // \"0.001100110011001100110011001100110011001100110011001101\"\n>\n>  (0.1+0.2).toString('2') // \"0.0100110011001100110011001100110011001100110011001101\" \n>\n> (0.3).toString('2') // \"0.010011001100110011001100110011001100110011001100110011\"\n\n\n\n#### ES6解决方案\n\nES6在Number对象上新增了一个极小的常量——Number.EPSILON\n\n```\nNumber.EPSILON\n// 2.220446049250313e-16\nNumber.EPSILON.toFixed(20)\n// \"0.00000000000000022204\"\n复制代码\n```\n\n引入一个这么小的量，目的在于为浮点数计算设置一个误差范围，如果误差能够小于Number.EPSILON，我们就可以认为结果是可靠的。\n\n误差检查函数（出自《ES6标准入门》-阮一峰）\n\n```\nfunction withinErrorMargin (left, right) {\n    return Math.abs(left - right) < Number.EPSILON\n}\nwithinErrorMargin(0.1+0.2, 0.3)\n```\n\n\n\n\n# 原型和原型链\n\n## 理解原型设计模式以及JavaScript中的原型规则\n\n\n\n## instanceof的底层实现原理，手动实现一个instanceof\n\n```\nfunction my_instanceof(obj, constructor) {\n  let constuctProto = constructor.prototype\n  while (true) {\n    if (obj.__protp__ === null) {\n      // 遍历完对象的原型链\n      return false\n    }\n    if (obj.__proto__ === constuctProto) {\n      return true\n    }\n    obj = obj.__proto__\n  }\n}\n```\n\n\n\n4.实现继承的几种方式以及他们的优缺点\n\n> 1. prototype\n> 2. extend\n> 3. create\n\n5.至少说出一种开源项目(如Node)中应用原型继承的案例\n\n6.可以描述new一个对象的详细过程，手动实现一个new操作符\n\n> 首先新建一个 new Object() //这里是不是有问题， 如果新建一个{}还可以说说\n>\n> 然后吧argumentsy映射到新建的对象上（引用地址）\n>\n> 把原型链映射到新建的对象上\n\n7.理解es6 class构造以及继承的底层实现原理\n\n> 应该就是语法糖，对于prototype的优化把\n\n作用域和闭包\n1.理解词法作用域和动态作用域\n\n>作用域是指程序源代码中定义变量的区域。\n>\n>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n>\n>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。\n\n \n\n2.理解JavaScript的作用域和作用域链\n\n> ### 全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象\n>\n> ### 局部作用域(Local Scope)\n>\n> ## 作用域链(Scope Chain)：所有的变量都会向上寻找表示\n>\n> ### 代码优化\n>\n> 从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。\n>\n> \n\n3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题\n\n>\n>\n>无法叙述\n\n4.this的原理以及几种不同使用场景的取值\n\n>\n>\n>因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。\n>\n>\n\n#### 情况一：全局 & 调用普通函数\n\n在全局环境中，this 永远指向 window。\n\n```\nconsole.log(this === window);     //true\n```\n\n普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。\n\n```\nvar x = 10;\nfunction foo(){\n    console.log(this);     //Window\n    console.log(this.x);   //10\n}\nfoo();\n```\n\n#### 情况二：构造函数\n\n所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。\n\n```\nfunction Foo(){\n    this.x = 10;\n    console.log(this);    //Foo {x:10}\n}\nvar foo = new Foo();\nconsole.log(foo.x);      //10\n```\n\n上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。\n\n但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。\n\n```\nfunction Foo(){\n    this.x = 10;\n    console.log(this);    //Window\n}\nvar foo = Foo();\nconsole.log(foo.x);      //undefined\n```\n\n#### 情况三：对象方法\n\n如果函数作为对象的方法时，方法中的 this 指向该对象。\n\n```\nvar obj = {\n    x: 10,\n    foo: function () {\n        console.log(this);        //Object\n        console.log(this.x);      //10\n    }\n};\nobj.foo();\n```\n\n**注意：若是在对象方法中定义函数，那么情况就不同了。**\n\n```\nvar obj = {\n    x: 10,\n    foo: function () {\n        function f(){\n            console.log(this);      //Window\n            console.log(this.x);    //undefined\n        }\n        f();\n    }\n}\nobj.foo();\n```\n\n可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。\n\n在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。\n\n```\nvar obj = {\n    x: 10,\n    foo: function () {\n        var self = this;\n        function f(){\n            console.log(self);      //{x: 10}\n            console.log(self.x);    //10\n        }\n        f();\n    }\n}\nobj.foo();\n```\n\n如果 foo 函数不作为对象方法被调用：\n\n```\nvar obj = {\n    x: 10,\n    foo: function () {\n        console.log(this);       //Window\n        console.log(this.x);     //undefined\n    }\n};\nvar fn = obj.foo;\nfn();\n```\n\nobj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。\n\n#### 情况四：构造函数 prototype 属性\n\n```\nfunction Foo(){\n    this.x = 10;\n}\nFoo.prototype.getX = function () {\n    console.log(this);        //Foo {x: 10, getX: function}\n    console.log(this.x);      //10\n}\nvar foo = new Foo();\nfoo.getX();\n```\n\n在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。\n\n#### 情况五：函数用 call、apply或者 bind 调用。\n\n```\nvar obj = {\n    x: 10\n}\nfunction foo(){\n    console.log(this);     //{x: 10}\n    console.log(this.x);   //10\n}\nfoo.call(obj);\nfoo.apply(obj);\nfoo.bind(obj)();\n```\n\n当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。\n\n#### 情况六：DOM event this\n\n在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点：\n\n```\nfunction Listener(){   \n    document.getElementById('foo').addEventListener('click', this.handleClick);     //这里的 this 指向 Listener 这个对象。不是强调的是这里的 this\n}\nListener.prototype.handleClick = function (event) {\n    console.log(this);    //<div id=\"foo\"></div>\n}\nvar listener = new Listener();\ndocument.getElementById('foo').click();\n```\n\n这个很好理解，就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码：\n\n```\nvar obj = {\n    x: 10,\n    fn: function() {\n        console.log(this);         //Window\n        console.log(this.x);       //undefined\n    }\n};\nfunction foo(fn) {\n    fn();\n} \nfoo(obj.fn);\n```\n\n你也可以用通过 bind 切换上下文:\n\n```\nfunction  Listener(){\n    document.getElementById('foo').addEventListener('click',this.handleClick.bind(this));      \n}\nListener.prototype.handleClick = function (event) {\n    console.log(this);    //Listener {}\n}\nvar listener = new Listener();\ndocument.getElementById('foo').click();\n```\n\n前六种情况其实可以总结为： this 指向调用该方法的对象。\n\n#### 情况七：箭头函数中的 this\n\n当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。\n\n```\nvar obj = {\n    x: 10,\n    foo: function() {\n        var fn = () => {\n            return () => {\n                return () => {\n                    console.log(this);      //Object {x: 10}\n                    console.log(this.x);    //10\n                }\n            }\n        }\n        fn()()();\n    }\n}\nobj.foo();\n```\n\n现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。\n\n如果使用箭头函数，以前的这种 hack 写法：\n\n```\nvar self = this;\n```\n\n就不再需要了。\n\n```\nvar obj = {\n    x: 10,\n    foo: function() {\n        var fn = () => {\n            return () => {\n                return () => {\n                    console.log(this);    // Object {x: 10}\n                    console.log(this.x);  //10\n                }\n            }\n        }\n        fn.bind({x: 14})()()();\n        fn.call({x: 14})()();\n    }\n}\nobj.foo();\n```\n\n由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。\n\n## 5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\n\nJavaScript闭包的形成原理是基于函数变量作用域链的规则 和 垃圾回收机制的引用计数规则。 \nJavaScript闭包的本质是内存泄漏，指定内存不释放。 \n\n应用：私有变量\n\n##6.理解堆栈溢出和内存泄漏的原理，如何防止\n\n溢出：没有足够的内存空间供其使用，泄漏：GC没起作用，闭包。防止闭包\n\n# 7.如何处理循环的异步操作\n\npromise.all\n\n#8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理\n\namd cmd umd    -》sea require npm\n\n(function(a){\n\nreturm {\n\na:1\n\n}\n})(1)\n\n#执行机制\n##1.为何try里面放return，finally还会执行，理解其内部机制\n\n类似promise？\n\n##2.JavaScript如何实现异步编程，可以详细描述EventLoop机制\n\n一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。\n\n在[事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#Event_loop)期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\n\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。\n\n```js\nwhile (queue.waitForMessage()) {\n  queue.processNextMessage();\n}\n```\n\n##3.宏任务和微任务分别有哪些\n\n4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法\n\n分清楚 promise await settimeout的执行顺序\n\n5.使用Promise实现串行\n\n找一个第三方的缓存，把状态缓存住就行了\n\n6.Node与浏览器EventLoop的差异\n\n7.如何在保证页面运行流畅的情况下处理海量数据\n\n不加载海量dom\n\n语法和API\n1.理解ECMAScript和JavaScript的关系\n\nECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。(蹭热度)\n\n2.熟练运用es5、es6提供的语法规范，\n\n3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）\n\n4.熟练应用map、reduce、filter 等高阶函数解决问题\n\n5.setInterval需要注意的点，使用settimeout实现setInterval\n\n6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题\n\n7.JavaScript异常处理的方式，统一的异常处理方案\n\n\n\nHTML和CSS\n\nHTML\n1.从规范的角度理解HTML，从分类和语义的角度使用标签\n\n早期语义化是为SEO和规范，目前原生的语义化作用很弱，更多体现在js框架中组件的语义化\n\n2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式\n\n\n\n3.元信息类标签(head、title、meta)的使用目的和配置方法\n\n4.HTML5离线缓存原理\n\n5.可以使用Canvas API、SVG等绘制高性能的动画\n\nCSS\n1.CSS盒模型，在不同浏览器的差异\n\n2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则\n\n3.CSS伪类和伪元素有哪些，它们的区别和实际应用\n\n4.HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理\n\n5.水平垂直居中的方案、可以实现6种以上并对比它们的优缺点\n\n6.BFC实现原理，可以解决的问题，如何创建BFC\n\n7.可使用CSS函数复用代码，实现特殊效果\n\n8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种\n\n9.CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染\n\n10.熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等\n\n11.CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况\n\n12.掌握一套完整的响应式布局方案\n\n手写\n1.手写图片瀑布流效果\n\n2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）\n\n3.使用纯CSS实现曲线运动（贝塞尔曲线）\n\n4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点\n\n\n\n计算机基础\n关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要。\n编译原理\n1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序\n\n2.正则表达式的匹配原理和性能优化\n\n3.如何将JavaScript代码解析成抽象语法树(AST)\n\n4.base64的编码原理\n\n5.几种进制的相互转换计算方法，在JavaScript中如何表示和转换\n\n网络协议\n1.理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用\n\n2.三次握手和四次挥手详细原理，为什么要使用这种机制\n\n3.有哪些协议是可靠，TCP有哪些手段保证可靠交付\n\n4.DNS的作用、DNS解析的详细过程，DNS优化原理\n\n5.CDN的作用和原理\n\n6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么\n\n7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题\n\n8.HTTP1.1、HTTP2.0带来的改变\n\n9.HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求\n\n10.理解WebSocket协议的底层原理、与HTTP的区别\n\n设计模式\n1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等\n\n2.发布订阅模式和观察者模式的异同以及实际应用\n\n3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用\n\n\n\n数据结构和算法\n据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！\n\n\nJavaScript编码能力\n1.多种方式实现数组去重、扁平化、对比优缺点\n\n2.多种方式实现深拷贝、对比优缺点\n\n3.手写函数柯里化工具函数、并理解其应用场景和优势\n\n4.手写防抖和节流工具函数、并理解其内部原理和应用场景\n\n5.实现一个sleep函数\n\n手动实现前端轮子\n1.手动实现call、apply、bind\n\n2.手动实现符合Promise/A+规范的Promise、手动实现async await\n\n3.手写一个EventEmitter实现事件发布、订阅\n\n4.可以说出两种实现双向绑定的方案、可以手动实现\n\n5.手写JSON.stringify、JSON.parse\n\n6.手写一个模版引擎，并能解释其中原理\n\n7.手写懒加载、下拉刷新、上拉加载、预加载等效果\n\n数据结构\n1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点\n\n2.理解数组、字符串的存储原理，并熟练应用他们解决问题\n\n3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题\n\n4.了解图、堆的基本结构和使用场景\n\n算法\n1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗\n\n2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度\n\n3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用\n\n4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题\n\n5.前端处理海量数据的算法方案\n\n\n\n运行环境\n我们需要理清语言和环境的关系：\nECMAScript描述了JavaScript语言的语法和基本对象规范\n\n浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口\n\nNode也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API\n\n\n\n浏览器API\n1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性\n\n2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性\n\n3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)\n\n4.浏览器海量数据存储、操作性能优化\n\n5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理\n\n6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库\n\n7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型\n\n8.浏览器提供的几种存储机制、优缺点、开发中正确的选择\n\n9.浏览器跨标签通信\n\n浏览器原理\n1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分\n\n2.请求数据到请求结束与服务器进行了几次交互\n\n3.可详细描述浏览器从输入URL到页面展现的详细过程\n\n4.浏览器解析HTML代码的原理，以及构建DOM树的流程\n\n5.浏览器如何解析CSS规则，并将其应用到DOM树上\n\n6.浏览器如何将解析好的带有样式的DOM树进行绘制\n\n7.浏览器的运行机制，如何配置资源异步同步加载\n\n8.浏览器回流与重绘的底层原理，引发原因，如何有效避免\n\n9.浏览器的垃圾回收机制，如何避免内存泄漏\n\n10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案\n\nNode\n1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等\n\n2.掌握一种Node开发框架，如Express，Express和Koa的区别\n\n3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理\n\n4.Node的底层运行原理、和浏览器的异同\n\n5.Node事件驱动、非阻塞机制的实现原理\n\n\n\n框架和类库\n轮子层出不穷，从原理上理解才是正道\nTypeScript\n1.理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现\n\n2.理解使用TypeScript的好处，掌握TypeScript基础语法\n\n3.TypeScript的规则检测原理\n\n4.可以在React、Vue等框架中使用TypeScript进行开发\n\nReact\n1.React和vue 选型和优缺点、核心架构的区别\n\n2.React中setState的执行机制，如何有效的管理状态\n\n3.React的事件底层实现机制\n\n4.React的虚拟DOM和Diff算法的内部实现\n\n5.React的Fiber工作原理，解决了什么问题\n\n6.React Router和Vue Router的底层实现原理、动态加载实现原理\n\n7.可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题\n\n8.基于React的特性和原理，可以手动实现一个简单的React\n\nVue\n1.熟练使用Vue的API、生命周期、钩子函数\n\n2.MVVM框架设计理念\n\n3.Vue双向绑定实现原理、Diff算法的内部实现\n\n4.Vue的事件机制\n\n5.从template转换成真实DOM的实现机制\n\n多端开发\n1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案\n\n2.理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用\n\n3.移动端页面适配解决方案、不同机型适配方案\n\n4.掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配\n\n5.掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理\n\n6.掌握一种小程序开发框架或原生小程序开发\n\n7.理解多端框架的内部实现原理，至少了解一个多端框架的使用\n\n数据流管理\n1.掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同\n\n2.熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理\n\n3.熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势\n\n4.熟练使用Vuex管理数据流，并理解其实现原理\n\n5.以上数据流方案的异同和优缺点，不情况下的技术选型\n\n实用库\n1.至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现\n\n2.掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表\n\n3.掌握一种GIS开发框架，如百度地图API\n\n4.掌握一种可视化开发框架，如Three.js、D3\n\n5.工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理\n\n开发和调试\n1.熟练使用各浏览器提供的调试工具\n\n2.熟练使用一种代理工具实现请求代理、抓包，如charls\n\n3.可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案\n\n4.了解Vue、React等框架调试工具的使用\n\n\n\n前端工程\n前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度\n项目构建\n1.理解npm、yarn依赖包管理的原理，两者的区别\n\n2.可以使用npm运行自定义脚本\n\n3.理解Babel、ESLint、webpack等工具在项目中承担的作用\n\n4.ESLint规则检测原理，常用的ESLint配置\n\n5.Babel的核心原理，可以自己编写一个Babel插件\n\n6.可以配置一种前端代码兼容方案，如Polyfill\n\n7.Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用\n\n8.可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins\n\nnginx\n1.正向代理与反向代理的特点和实例\n\n2.可手动搭建一个简单的nginx服务器、\n\n3.熟练应用常用的nginx内置变量，掌握常用的匹配规则写法\n\n4.可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理\n\n开发提速\n1.熟练掌握一种接口管理、接口mock工具的使用，如yapi\n\n2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题\n\n3.理解TDD与BDD模式，至少会使用一种前端单元测试框架\n\n版本控制\n1.理解Git的核心原理、工作流程、和SVN的区别\n\n2.熟练使用常规的Git命令、git rebase、git stash等进阶命令\n\n3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题\n\n持续集成\n1.理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins\n\n2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）\n\n\n\n项目和业务\n\n\n后端技能\n1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言\n\n2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库\n\n性能优化\n1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案\n\n2.了解常见的Web、App性能优化方案\n\n3.SEO排名规则、SEO优化方案、前后端分离的SEO\n\n4.SSR实现方案、优缺点、及其性能优化\n\n5.Webpack的性能优化方案\n\n6.Canvas性能优化方案\n\n7.React、Vue等框架使用性能优化方案\n\n前端安全\n1.XSS攻击的原理、分类、具体案例，前端如何防御\n\n2.CSRF攻击的原理、具体案例，前端如何防御\n\n3.HTTP劫持、页面劫持的原理、防御措施\n\n业务相关\n1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题\n\n2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题\n\n3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性\n\n\n\n学习提升\n\n\nvczh大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答：\n\n这十几年我一共做了三件事：\n\n1、不以赚钱为目的选择学习的内容；\n\n2、以自己是否能造出轮子来衡量学习的效果；\n\n3、坚持每天写自己的代码，前10年每天至少6个小时，不包含学习和工作的时间。\n\n上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。\n\n关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多\n\n1.拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏\n\n2.定期的将知识进行总结，不断完善自己的知识体系\n\n3.尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用\n\n4.坚持输出自己的代码，不要盲目的扎进公司业\n\n\n\n技术之外\n\n\n这部分可能比上面九条加起来重要！\n\n1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS等\n\n2.了解互联网行业术语：B2B、B2C、C2C、O2O等\n\n3.掌握互联网行业沟通、问答、学习的\n\n4.有一定的\"PPT\"能力\n\n5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识\n\n6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系\n.如何理解 JS 中的this关键字？\n1. 由于 this 关键字很混乱，如何解决这个问题\n  3.什么是闭包\n  4.解释一下变量的提升\n2. JavaScript如何处理同步和异步情况\n3. 如何理解事件委托\n4. 如何理解高阶函数。\n5. 如何区分声明函数和表达式函数\n6. 解释一下严格模式(strict mode)\n","slug":"每日一问","published":1,"date":"2020-10-10T05:21:37.320Z","updated":"2020-10-10T05:21:37.320Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckg39jbn300058ovpgod4fo8c","content":"<p>[TOC]</p>\n<h1 id=\"变量和类型\"><a href=\"#变量和类型\" class=\"headerlink\" title=\"变量和类型\"></a>变量和类型</h1><h2 id=\"JavaScript规定了几种类型\"><a href=\"#JavaScript规定了几种类型\" class=\"headerlink\" title=\"JavaScript规定了几种类型\"></a>JavaScript规定了几种类型</h2><blockquote>\n<p>基本数据类型：Null、Undefined、Number，String，Boolean。</p>\n<p>复杂数据类型：Object，Array</p>\n</blockquote>\n<h2 id=\"JavaScript对象的底层数据结构是什么\"><a href=\"#JavaScript对象的底层数据结构是什么\" class=\"headerlink\" title=\"JavaScript对象的底层数据结构是什么\"></a>JavaScript对象的底层数据结构是什么</h2><blockquote>\n</blockquote>\n<h2 id=\"Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\"><a href=\"#Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\" class=\"headerlink\" title=\"Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\"></a>Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</h2><blockquote>\n<p> 使用Symbol来替代常量,并且别人无法通过外部调用到内部的这个参数的值。主要还是作为对象属性名（key），特性是绝对唯一！</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> root = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> generateName = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> postfix = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">descString</span>)</span>&#123;</span><br><span class=\"line\">         postfix++;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">'@@'</span> + descString + <span class=\"string\">'_'</span> + postfix</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> SymbolPolyfill = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Symbol</span>(<span class=\"params\">description</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> SymbolPolyfill) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Symbol is not a constructor'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">var</span> descString = description === <span class=\"literal\">undefined</span> ? <span class=\"literal\">undefined</span> : <span class=\"built_in\">String</span>(description)</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">var</span> symbol = <span class=\"built_in\">Object</span>.create(&#123;</span><br><span class=\"line\">         toString: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.__Name__;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         valueOf: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"built_in\">Object</span>.defineProperties(symbol, &#123;</span><br><span class=\"line\">         <span class=\"string\">'__Description__'</span>: &#123;</span><br><span class=\"line\">             value: descString,</span><br><span class=\"line\">             writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">             enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">             configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         <span class=\"string\">'__Name__'</span>: &#123;</span><br><span class=\"line\">             value: generateName(descString),</span><br><span class=\"line\">             writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">             enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">             configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> symbol;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> forMap = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">Object</span>.defineProperties(SymbolPolyfill, &#123;</span><br><span class=\"line\">     <span class=\"string\">'for'</span>: &#123;</span><br><span class=\"line\">         value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">description</span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">var</span> descString = description === <span class=\"literal\">undefined</span> ? <span class=\"literal\">undefined</span> : <span class=\"built_in\">String</span>(description)</span><br><span class=\"line\">             <span class=\"keyword\">return</span> forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">         configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"string\">'keyFor'</span>: &#123;</span><br><span class=\"line\">         value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">symbol</span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> forMap) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (forMap[key] === symbol) <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">         configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"> root.SymbolPolyfill = SymbolPolyfill;</span><br><span class=\"line\"> &#125;)()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JavaScript中的变量在内存中的具体存储形式\"><a href=\"#JavaScript中的变量在内存中的具体存储形式\" class=\"headerlink\" title=\"JavaScript中的变量在内存中的具体存储形式\"></a>JavaScript中的变量在内存中的具体存储形式</h2><blockquote>\n<p>值类型和引用类型。存在堆和栈中。 如图所示:<img src=\"https://segmentfault.com/img/bVCuzt?w=579&h=182\" alt=\"å¾çæè¿°\"></p>\n<h3 id=\"堆-amp-栈\"><a href=\"#堆-amp-栈\" class=\"headerlink\" title=\"堆&amp;栈:\"></a>堆&amp;栈:</h3><p>栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。<br>堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。<br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>栈（数据结构）：一种先进后出的数据结构。</p>\n<p>栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。<br>堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序</p>\n</blockquote>\n<h2 id=\"基本类型对应的内置对象，以及他们之间的装箱拆箱操作\"><a href=\"#基本类型对应的内置对象，以及他们之间的装箱拆箱操作\" class=\"headerlink\" title=\"基本类型对应的内置对象，以及他们之间的装箱拆箱操作\"></a>基本类型对应的内置对象，以及他们之间的装箱拆箱操作</h2><p>装箱：所谓装箱，就是把基本类型转变为对应的对象。装箱分为隐式和显示。<br>string（显示装箱），bool（显示装箱）,number(隐式装箱),object,null.</p>\n<p>拆箱：拆箱与装箱相反，把对象转变为基本类型的值。拆箱过程内部调用了抽象操作 ToPrimitive 。ToPrimitive 先检查对象是否有 valueOf 方法，如果有则再检查 valueOf 方法是否有基本类型的返回值。如果没有 valueOf 方法或 valueOf 方法没有返回值，则调用 toString 方法。如果 toString 方法也没有返回值，产生 TypeError 错误。</p>\n<h2 id=\"理解值类型和引用类型\"><a href=\"#理解值类型和引用类型\" class=\"headerlink\" title=\"理解值类型和引用类型\"></a>理解值类型和引用类型</h2><blockquote>\n<p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。</p>\n<p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。</p>\n</blockquote>\n<h2 id=\"null和undefined的区别\"><a href=\"#null和undefined的区别\" class=\"headerlink\" title=\"null和undefined的区别\"></a>null和undefined的区别</h2><blockquote>\n<p>null表示”没有对象”，即该处不应该有值。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>\n</blockquote>\n<h2 id=\"至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\"><a href=\"#至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\" class=\"headerlink\" title=\"至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\"></a>至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</h2><blockquote>\n<p><strong>typeof</strong> </p>\n<ul>\n<li><p>对于基本类型，除 null 以外，均可以返回正确的结果。</p>\n</li>\n<li><p>对于引用类型，除 function 以外，一律返回 object 类型。</p>\n</li>\n<li><p>对于 null ，返回 object 类型。</p>\n</li>\n<li><p>对于 function 返回  function 类型。</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a><strong>instanceof</strong></h3><p>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型</p>\n</blockquote>\n<blockquote>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a><strong>constructor</strong></h3><p> null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p>\n<p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p>\n</blockquote>\n<h2 id=\"可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\"><a href=\"#可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\" class=\"headerlink\" title=\"可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\"></a>可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用</h2><blockquote>\n<p>隐式转换中主要涉及到三种转换：</p>\n<p>1、将值转为原始值，ToPrimitive()。</p>\n<p>2、将值转为数字，ToNumber()。</p>\n<p>3、将值转为字符串，ToString()</p>\n<p> 如何避免：使用ts。巧妙应用：尽量不要用</p>\n</blockquote>\n<h2 id=\"出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\"><a href=\"#出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\" class=\"headerlink\" title=\"出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\"></a>出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法</h2><blockquote>\n<p>发生场景： 0.1 + 0.2 === 0.30000000000000004</p>\n<p>细致分析原因：是浮点数存储本身固有的缺陷。浮点数无法精确表示其数值范围内的所有数值，只能精确表示可用科学计数法 m*2^e 表示的数值而已，比如0.5的科学计数法是2^(-1)，则可被精确存储；而0.1、0.2则无法被精确存储</p>\n<p>(0.1).toString(‘2’) // “0.0001100110011001100110011001100110011001100110011001101” </p>\n<p>(0.2).toString(‘2’) // “0.001100110011001100110011001100110011001100110011001101”</p>\n<p> (0.1+0.2).toString(‘2’) // “0.0100110011001100110011001100110011001100110011001101” </p>\n<p>(0.3).toString(‘2’) // “0.010011001100110011001100110011001100110011001100110011”</p>\n</blockquote>\n<h4 id=\"ES6解决方案\"><a href=\"#ES6解决方案\" class=\"headerlink\" title=\"ES6解决方案\"></a>ES6解决方案</h4><p>ES6在Number对象上新增了一个极小的常量——Number.EPSILON</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number.EPSILON</span><br><span class=\"line\">// 2.220446049250313e-16</span><br><span class=\"line\">Number.EPSILON.toFixed(20)</span><br><span class=\"line\">// &quot;0.00000000000000022204&quot;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>引入一个这么小的量，目的在于为浮点数计算设置一个误差范围，如果误差能够小于Number.EPSILON，我们就可以认为结果是可靠的。</p>\n<p>误差检查函数（出自《ES6标准入门》-阮一峰）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function withinErrorMargin (left, right) &#123;</span><br><span class=\"line\">    return Math.abs(left - right) &lt; Number.EPSILON</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">withinErrorMargin(0.1+0.2, 0.3)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"原型和原型链\"><a href=\"#原型和原型链\" class=\"headerlink\" title=\"原型和原型链\"></a>原型和原型链</h1><h2 id=\"理解原型设计模式以及JavaScript中的原型规则\"><a href=\"#理解原型设计模式以及JavaScript中的原型规则\" class=\"headerlink\" title=\"理解原型设计模式以及JavaScript中的原型规则\"></a>理解原型设计模式以及JavaScript中的原型规则</h2><h2 id=\"instanceof的底层实现原理，手动实现一个instanceof\"><a href=\"#instanceof的底层实现原理，手动实现一个instanceof\" class=\"headerlink\" title=\"instanceof的底层实现原理，手动实现一个instanceof\"></a>instanceof的底层实现原理，手动实现一个instanceof</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function my_instanceof(obj, constructor) &#123;</span><br><span class=\"line\">  let constuctProto = constructor.prototype</span><br><span class=\"line\">  while (true) &#123;</span><br><span class=\"line\">    if (obj.__protp__ === null) &#123;</span><br><span class=\"line\">      // 遍历完对象的原型链</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (obj.__proto__ === constuctProto) &#123;</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    obj = obj.__proto__</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.实现继承的几种方式以及他们的优缺点</p>\n<blockquote>\n<ol>\n<li>prototype</li>\n<li>extend</li>\n<li>create</li>\n</ol>\n</blockquote>\n<p>5.至少说出一种开源项目(如Node)中应用原型继承的案例</p>\n<p>6.可以描述new一个对象的详细过程，手动实现一个new操作符</p>\n<blockquote>\n<p>首先新建一个 new Object() //这里是不是有问题， 如果新建一个{}还可以说说</p>\n<p>然后吧argumentsy映射到新建的对象上（引用地址）</p>\n<p>把原型链映射到新建的对象上</p>\n</blockquote>\n<p>7.理解es6 class构造以及继承的底层实现原理</p>\n<blockquote>\n<p>应该就是语法糖，对于prototype的优化把</p>\n</blockquote>\n<p>作用域和闭包<br>1.理解词法作用域和动态作用域</p>\n<blockquote>\n<p>作用域是指程序源代码中定义变量的区域。</p>\n<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>\n<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>\n</blockquote>\n<p>2.理解JavaScript的作用域和作用域链</p>\n<blockquote>\n<h3 id=\"全局作用域-Global-Scope-最外层函数和最外层函数定义的变量，未使用var赋值，window对象\"><a href=\"#全局作用域-Global-Scope-最外层函数和最外层函数定义的变量，未使用var赋值，window对象\" class=\"headerlink\" title=\"全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象\"></a>全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象</h3><h3 id=\"局部作用域-Local-Scope\"><a href=\"#局部作用域-Local-Scope\" class=\"headerlink\" title=\"局部作用域(Local Scope)\"></a>局部作用域(Local Scope)</h3><h2 id=\"作用域链-Scope-Chain-：所有的变量都会向上寻找表示\"><a href=\"#作用域链-Scope-Chain-：所有的变量都会向上寻找表示\" class=\"headerlink\" title=\"作用域链(Scope Chain)：所有的变量都会向上寻找表示\"></a>作用域链(Scope Chain)：所有的变量都会向上寻找表示</h2><h3 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h3><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</p>\n</blockquote>\n<p>3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题</p>\n<blockquote>\n<p>无法叙述</p>\n</blockquote>\n<p>4.this的原理以及几种不同使用场景的取值</p>\n<blockquote>\n<p>因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。</p>\n</blockquote>\n<h4 id=\"情况一：全局-amp-调用普通函数\"><a href=\"#情况一：全局-amp-调用普通函数\" class=\"headerlink\" title=\"情况一：全局 &amp; 调用普通函数\"></a>情况一：全局 &amp; 调用普通函数</h4><p>在全局环境中，this 永远指向 window。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this === window);     //true</span><br></pre></td></tr></table></figure>\n\n<p>普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = 10;</span><br><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    console.log(this);     //Window</span><br><span class=\"line\">    console.log(this.x);   //10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"情况二：构造函数\"><a href=\"#情况二：构造函数\" class=\"headerlink\" title=\"情况二：构造函数\"></a>情况二：构造函数</h4><p>所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo()&#123;</span><br><span class=\"line\">    this.x = 10;</span><br><span class=\"line\">    console.log(this);    //Foo &#123;x:10&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = new Foo();</span><br><span class=\"line\">console.log(foo.x);      //10</span><br></pre></td></tr></table></figure>\n\n<p>上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。</p>\n<p>但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo()&#123;</span><br><span class=\"line\">    this.x = 10;</span><br><span class=\"line\">    console.log(this);    //Window</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = Foo();</span><br><span class=\"line\">console.log(foo.x);      //undefined</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"情况三：对象方法\"><a href=\"#情况三：对象方法\" class=\"headerlink\" title=\"情况三：对象方法\"></a>情况三：对象方法</h4><p>如果函数作为对象的方法时，方法中的 this 指向该对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function () &#123;</span><br><span class=\"line\">        console.log(this);        //Object</span><br><span class=\"line\">        console.log(this.x);      //10</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：若是在对象方法中定义函数，那么情况就不同了。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function () &#123;</span><br><span class=\"line\">        function f()&#123;</span><br><span class=\"line\">            console.log(this);      //Window</span><br><span class=\"line\">            console.log(this.x);    //undefined</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        f();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p>可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。</p>\n<p>在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function () &#123;</span><br><span class=\"line\">        var self = this;</span><br><span class=\"line\">        function f()&#123;</span><br><span class=\"line\">            console.log(self);      //&#123;x: 10&#125;</span><br><span class=\"line\">            console.log(self.x);    //10</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        f();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p>如果 foo 函数不作为对象方法被调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function () &#123;</span><br><span class=\"line\">        console.log(this);       //Window</span><br><span class=\"line\">        console.log(this.x);     //undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var fn = obj.foo;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n\n<p>obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。</p>\n<h4 id=\"情况四：构造函数-prototype-属性\"><a href=\"#情况四：构造函数-prototype-属性\" class=\"headerlink\" title=\"情况四：构造函数 prototype 属性\"></a>情况四：构造函数 prototype 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo()&#123;</span><br><span class=\"line\">    this.x = 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype.getX = function () &#123;</span><br><span class=\"line\">    console.log(this);        //Foo &#123;x: 10, getX: function&#125;</span><br><span class=\"line\">    console.log(this.x);      //10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = new Foo();</span><br><span class=\"line\">foo.getX();</span><br></pre></td></tr></table></figure>\n\n<p>在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。</p>\n<h4 id=\"情况五：函数用-call、apply或者-bind-调用。\"><a href=\"#情况五：函数用-call、apply或者-bind-调用。\" class=\"headerlink\" title=\"情况五：函数用 call、apply或者 bind 调用。\"></a>情况五：函数用 call、apply或者 bind 调用。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    console.log(this);     //&#123;x: 10&#125;</span><br><span class=\"line\">    console.log(this.x);   //10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.call(obj);</span><br><span class=\"line\">foo.apply(obj);</span><br><span class=\"line\">foo.bind(obj)();</span><br></pre></td></tr></table></figure>\n\n<p>当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。</p>\n<h4 id=\"情况六：DOM-event-this\"><a href=\"#情况六：DOM-event-this\" class=\"headerlink\" title=\"情况六：DOM event this\"></a>情况六：DOM event this</h4><p>在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Listener()&#123;   </span><br><span class=\"line\">    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;, this.handleClick);     //这里的 this 指向 Listener 这个对象。不是强调的是这里的 this</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Listener.prototype.handleClick = function (event) &#123;</span><br><span class=\"line\">    console.log(this);    //&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var listener = new Listener();</span><br><span class=\"line\">document.getElementById(&apos;foo&apos;).click();</span><br></pre></td></tr></table></figure>\n\n<p>这个很好理解，就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    fn: function() &#123;</span><br><span class=\"line\">        console.log(this);         //Window</span><br><span class=\"line\">        console.log(this.x);       //undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function foo(fn) &#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">foo(obj.fn);</span><br></pre></td></tr></table></figure>\n\n<p>你也可以用通过 bind 切换上下文:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function  Listener()&#123;</span><br><span class=\"line\">    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;,this.handleClick.bind(this));      </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Listener.prototype.handleClick = function (event) &#123;</span><br><span class=\"line\">    console.log(this);    //Listener &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var listener = new Listener();</span><br><span class=\"line\">document.getElementById(&apos;foo&apos;).click();</span><br></pre></td></tr></table></figure>\n\n<p>前六种情况其实可以总结为： this 指向调用该方法的对象。</p>\n<h4 id=\"情况七：箭头函数中的-this\"><a href=\"#情况七：箭头函数中的-this\" class=\"headerlink\" title=\"情况七：箭头函数中的 this\"></a>情况七：箭头函数中的 this</h4><p>当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function() &#123;</span><br><span class=\"line\">        var fn = () =&gt; &#123;</span><br><span class=\"line\">            return () =&gt; &#123;</span><br><span class=\"line\">                return () =&gt; &#123;</span><br><span class=\"line\">                    console.log(this);      //Object &#123;x: 10&#125;</span><br><span class=\"line\">                    console.log(this.x);    //10</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fn()()();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p>现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。</p>\n<p>如果使用箭头函数，以前的这种 hack 写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var self = this;</span><br></pre></td></tr></table></figure>\n\n<p>就不再需要了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function() &#123;</span><br><span class=\"line\">        var fn = () =&gt; &#123;</span><br><span class=\"line\">            return () =&gt; &#123;</span><br><span class=\"line\">                return () =&gt; &#123;</span><br><span class=\"line\">                    console.log(this);    // Object &#123;x: 10&#125;</span><br><span class=\"line\">                    console.log(this.x);  //10</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fn.bind(&#123;x: 14&#125;)()()();</span><br><span class=\"line\">        fn.call(&#123;x: 14&#125;)()();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p>由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。</p>\n<h2 id=\"5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\"><a href=\"#5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\" class=\"headerlink\" title=\"5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\"></a>5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用</h2><p>JavaScript闭包的形成原理是基于函数变量作用域链的规则 和 垃圾回收机制的引用计数规则。<br>JavaScript闭包的本质是内存泄漏，指定内存不释放。 </p>\n<p>应用：私有变量</p>\n<p>##6.理解堆栈溢出和内存泄漏的原理，如何防止</p>\n<p>溢出：没有足够的内存空间供其使用，泄漏：GC没起作用，闭包。防止闭包</p>\n<h1 id=\"7-如何处理循环的异步操作\"><a href=\"#7-如何处理循环的异步操作\" class=\"headerlink\" title=\"7.如何处理循环的异步操作\"></a>7.如何处理循环的异步操作</h1><p>promise.all</p>\n<p>#8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理</p>\n<p>amd cmd umd    -》sea require npm</p>\n<p>(function(a){</p>\n<p>returm {</p>\n<p>a:1</p>\n<p>}<br>})(1)</p>\n<p>#执行机制</p>\n<p>##1.为何try里面放return，finally还会执行，理解其内部机制</p>\n<p>类似promise？</p>\n<p>##2.JavaScript如何实现异步编程，可以详细描述EventLoop机制</p>\n<p>一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。</p>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#Event_loop\" target=\"_blank\" rel=\"noopener\">事件循环</a>期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。</p>\n<p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</span><br><span class=\"line\">  queue.processNextMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##3.宏任务和微任务分别有哪些</p>\n<p>4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法</p>\n<p>分清楚 promise await settimeout的执行顺序</p>\n<p>5.使用Promise实现串行</p>\n<p>找一个第三方的缓存，把状态缓存住就行了</p>\n<p>6.Node与浏览器EventLoop的差异</p>\n<p>7.如何在保证页面运行流畅的情况下处理海量数据</p>\n<p>不加载海量dom</p>\n<p>语法和API<br>1.理解ECMAScript和JavaScript的关系</p>\n<p>ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。(蹭热度)</p>\n<p>2.熟练运用es5、es6提供的语法规范，</p>\n<p>3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）</p>\n<p>4.熟练应用map、reduce、filter 等高阶函数解决问题</p>\n<p>5.setInterval需要注意的点，使用settimeout实现setInterval</p>\n<p>6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题</p>\n<p>7.JavaScript异常处理的方式，统一的异常处理方案</p>\n<p>HTML和CSS</p>\n<p>HTML<br>1.从规范的角度理解HTML，从分类和语义的角度使用标签</p>\n<p>早期语义化是为SEO和规范，目前原生的语义化作用很弱，更多体现在js框架中组件的语义化</p>\n<p>2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式</p>\n<p>3.元信息类标签(head、title、meta)的使用目的和配置方法</p>\n<p>4.HTML5离线缓存原理</p>\n<p>5.可以使用Canvas API、SVG等绘制高性能的动画</p>\n<p>CSS<br>1.CSS盒模型，在不同浏览器的差异</p>\n<p>2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则</p>\n<p>3.CSS伪类和伪元素有哪些，它们的区别和实际应用</p>\n<p>4.HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理</p>\n<p>5.水平垂直居中的方案、可以实现6种以上并对比它们的优缺点</p>\n<p>6.BFC实现原理，可以解决的问题，如何创建BFC</p>\n<p>7.可使用CSS函数复用代码，实现特殊效果</p>\n<p>8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种</p>\n<p>9.CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染</p>\n<p>10.熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等</p>\n<p>11.CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况</p>\n<p>12.掌握一套完整的响应式布局方案</p>\n<p>手写<br>1.手写图片瀑布流效果</p>\n<p>2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）</p>\n<p>3.使用纯CSS实现曲线运动（贝塞尔曲线）</p>\n<p>4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点</p>\n<p>计算机基础<br>关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要。<br>编译原理<br>1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序</p>\n<p>2.正则表达式的匹配原理和性能优化</p>\n<p>3.如何将JavaScript代码解析成抽象语法树(AST)</p>\n<p>4.base64的编码原理</p>\n<p>5.几种进制的相互转换计算方法，在JavaScript中如何表示和转换</p>\n<p>网络协议<br>1.理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用</p>\n<p>2.三次握手和四次挥手详细原理，为什么要使用这种机制</p>\n<p>3.有哪些协议是可靠，TCP有哪些手段保证可靠交付</p>\n<p>4.DNS的作用、DNS解析的详细过程，DNS优化原理</p>\n<p>5.CDN的作用和原理</p>\n<p>6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么</p>\n<p>7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题</p>\n<p>8.HTTP1.1、HTTP2.0带来的改变</p>\n<p>9.HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求</p>\n<p>10.理解WebSocket协议的底层原理、与HTTP的区别</p>\n<p>设计模式<br>1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等</p>\n<p>2.发布订阅模式和观察者模式的异同以及实际应用</p>\n<p>3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用</p>\n<p>数据结构和算法<br>据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！</p>\n<p>JavaScript编码能力<br>1.多种方式实现数组去重、扁平化、对比优缺点</p>\n<p>2.多种方式实现深拷贝、对比优缺点</p>\n<p>3.手写函数柯里化工具函数、并理解其应用场景和优势</p>\n<p>4.手写防抖和节流工具函数、并理解其内部原理和应用场景</p>\n<p>5.实现一个sleep函数</p>\n<p>手动实现前端轮子<br>1.手动实现call、apply、bind</p>\n<p>2.手动实现符合Promise/A+规范的Promise、手动实现async await</p>\n<p>3.手写一个EventEmitter实现事件发布、订阅</p>\n<p>4.可以说出两种实现双向绑定的方案、可以手动实现</p>\n<p>5.手写JSON.stringify、JSON.parse</p>\n<p>6.手写一个模版引擎，并能解释其中原理</p>\n<p>7.手写懒加载、下拉刷新、上拉加载、预加载等效果</p>\n<p>数据结构<br>1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点</p>\n<p>2.理解数组、字符串的存储原理，并熟练应用他们解决问题</p>\n<p>3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题</p>\n<p>4.了解图、堆的基本结构和使用场景</p>\n<p>算法<br>1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗</p>\n<p>2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度</p>\n<p>3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用</p>\n<p>4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题</p>\n<p>5.前端处理海量数据的算法方案</p>\n<p>运行环境<br>我们需要理清语言和环境的关系：<br>ECMAScript描述了JavaScript语言的语法和基本对象规范</p>\n<p>浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口</p>\n<p>Node也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API</p>\n<p>浏览器API<br>1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性</p>\n<p>2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性</p>\n<p>3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)</p>\n<p>4.浏览器海量数据存储、操作性能优化</p>\n<p>5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理</p>\n<p>6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库</p>\n<p>7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型</p>\n<p>8.浏览器提供的几种存储机制、优缺点、开发中正确的选择</p>\n<p>9.浏览器跨标签通信</p>\n<p>浏览器原理<br>1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分</p>\n<p>2.请求数据到请求结束与服务器进行了几次交互</p>\n<p>3.可详细描述浏览器从输入URL到页面展现的详细过程</p>\n<p>4.浏览器解析HTML代码的原理，以及构建DOM树的流程</p>\n<p>5.浏览器如何解析CSS规则，并将其应用到DOM树上</p>\n<p>6.浏览器如何将解析好的带有样式的DOM树进行绘制</p>\n<p>7.浏览器的运行机制，如何配置资源异步同步加载</p>\n<p>8.浏览器回流与重绘的底层原理，引发原因，如何有效避免</p>\n<p>9.浏览器的垃圾回收机制，如何避免内存泄漏</p>\n<p>10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案</p>\n<p>Node<br>1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等</p>\n<p>2.掌握一种Node开发框架，如Express，Express和Koa的区别</p>\n<p>3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理</p>\n<p>4.Node的底层运行原理、和浏览器的异同</p>\n<p>5.Node事件驱动、非阻塞机制的实现原理</p>\n<p>框架和类库<br>轮子层出不穷，从原理上理解才是正道<br>TypeScript<br>1.理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现</p>\n<p>2.理解使用TypeScript的好处，掌握TypeScript基础语法</p>\n<p>3.TypeScript的规则检测原理</p>\n<p>4.可以在React、Vue等框架中使用TypeScript进行开发</p>\n<p>React<br>1.React和vue 选型和优缺点、核心架构的区别</p>\n<p>2.React中setState的执行机制，如何有效的管理状态</p>\n<p>3.React的事件底层实现机制</p>\n<p>4.React的虚拟DOM和Diff算法的内部实现</p>\n<p>5.React的Fiber工作原理，解决了什么问题</p>\n<p>6.React Router和Vue Router的底层实现原理、动态加载实现原理</p>\n<p>7.可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题</p>\n<p>8.基于React的特性和原理，可以手动实现一个简单的React</p>\n<p>Vue<br>1.熟练使用Vue的API、生命周期、钩子函数</p>\n<p>2.MVVM框架设计理念</p>\n<p>3.Vue双向绑定实现原理、Diff算法的内部实现</p>\n<p>4.Vue的事件机制</p>\n<p>5.从template转换成真实DOM的实现机制</p>\n<p>多端开发<br>1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案</p>\n<p>2.理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用</p>\n<p>3.移动端页面适配解决方案、不同机型适配方案</p>\n<p>4.掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配</p>\n<p>5.掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理</p>\n<p>6.掌握一种小程序开发框架或原生小程序开发</p>\n<p>7.理解多端框架的内部实现原理，至少了解一个多端框架的使用</p>\n<p>数据流管理<br>1.掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同</p>\n<p>2.熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理</p>\n<p>3.熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势</p>\n<p>4.熟练使用Vuex管理数据流，并理解其实现原理</p>\n<p>5.以上数据流方案的异同和优缺点，不情况下的技术选型</p>\n<p>实用库<br>1.至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现</p>\n<p>2.掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表</p>\n<p>3.掌握一种GIS开发框架，如百度地图API</p>\n<p>4.掌握一种可视化开发框架，如Three.js、D3</p>\n<p>5.工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理</p>\n<p>开发和调试<br>1.熟练使用各浏览器提供的调试工具</p>\n<p>2.熟练使用一种代理工具实现请求代理、抓包，如charls</p>\n<p>3.可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案</p>\n<p>4.了解Vue、React等框架调试工具的使用</p>\n<p>前端工程<br>前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度<br>项目构建<br>1.理解npm、yarn依赖包管理的原理，两者的区别</p>\n<p>2.可以使用npm运行自定义脚本</p>\n<p>3.理解Babel、ESLint、webpack等工具在项目中承担的作用</p>\n<p>4.ESLint规则检测原理，常用的ESLint配置</p>\n<p>5.Babel的核心原理，可以自己编写一个Babel插件</p>\n<p>6.可以配置一种前端代码兼容方案，如Polyfill</p>\n<p>7.Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用</p>\n<p>8.可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins</p>\n<p>nginx<br>1.正向代理与反向代理的特点和实例</p>\n<p>2.可手动搭建一个简单的nginx服务器、</p>\n<p>3.熟练应用常用的nginx内置变量，掌握常用的匹配规则写法</p>\n<p>4.可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理</p>\n<p>开发提速<br>1.熟练掌握一种接口管理、接口mock工具的使用，如yapi</p>\n<p>2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题</p>\n<p>3.理解TDD与BDD模式，至少会使用一种前端单元测试框架</p>\n<p>版本控制<br>1.理解Git的核心原理、工作流程、和SVN的区别</p>\n<p>2.熟练使用常规的Git命令、git rebase、git stash等进阶命令</p>\n<p>3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题</p>\n<p>持续集成<br>1.理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins</p>\n<p>2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）</p>\n<p>项目和业务</p>\n<p>后端技能<br>1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言</p>\n<p>2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库</p>\n<p>性能优化<br>1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案</p>\n<p>2.了解常见的Web、App性能优化方案</p>\n<p>3.SEO排名规则、SEO优化方案、前后端分离的SEO</p>\n<p>4.SSR实现方案、优缺点、及其性能优化</p>\n<p>5.Webpack的性能优化方案</p>\n<p>6.Canvas性能优化方案</p>\n<p>7.React、Vue等框架使用性能优化方案</p>\n<p>前端安全<br>1.XSS攻击的原理、分类、具体案例，前端如何防御</p>\n<p>2.CSRF攻击的原理、具体案例，前端如何防御</p>\n<p>3.HTTP劫持、页面劫持的原理、防御措施</p>\n<p>业务相关<br>1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题</p>\n<p>2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题</p>\n<p>3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性</p>\n<p>学习提升</p>\n<p>vczh大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答：</p>\n<p>这十几年我一共做了三件事：</p>\n<p>1、不以赚钱为目的选择学习的内容；</p>\n<p>2、以自己是否能造出轮子来衡量学习的效果；</p>\n<p>3、坚持每天写自己的代码，前10年每天至少6个小时，不包含学习和工作的时间。</p>\n<p>上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。</p>\n<p>关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多</p>\n<p>1.拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏</p>\n<p>2.定期的将知识进行总结，不断完善自己的知识体系</p>\n<p>3.尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用</p>\n<p>4.坚持输出自己的代码，不要盲目的扎进公司业</p>\n<p>技术之外</p>\n<p>这部分可能比上面九条加起来重要！</p>\n<p>1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS等</p>\n<p>2.了解互联网行业术语：B2B、B2C、C2C、O2O等</p>\n<p>3.掌握互联网行业沟通、问答、学习的</p>\n<p>4.有一定的”PPT”能力</p>\n<p>5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识</p>\n<p>6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系<br>.如何理解 JS 中的this关键字？</p>\n<ol>\n<li>由于 this 关键字很混乱，如何解决这个问题<br>3.什么是闭包<br>4.解释一下变量的提升</li>\n<li>JavaScript如何处理同步和异步情况</li>\n<li>如何理解事件委托</li>\n<li>如何理解高阶函数。</li>\n<li>如何区分声明函数和表达式函数</li>\n<li>解释一下严格模式(strict mode)</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"变量和类型\"><a href=\"#变量和类型\" class=\"headerlink\" title=\"变量和类型\"></a>变量和类型</h1><h2 id=\"JavaScript规定了几种类型\"><a href=\"#JavaScript规定了几种类型\" class=\"headerlink\" title=\"JavaScript规定了几种类型\"></a>JavaScript规定了几种类型</h2><blockquote>\n<p>基本数据类型：Null、Undefined、Number，String，Boolean。</p>\n<p>复杂数据类型：Object，Array</p>\n</blockquote>\n<h2 id=\"JavaScript对象的底层数据结构是什么\"><a href=\"#JavaScript对象的底层数据结构是什么\" class=\"headerlink\" title=\"JavaScript对象的底层数据结构是什么\"></a>JavaScript对象的底层数据结构是什么</h2><blockquote>\n</blockquote>\n<h2 id=\"Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\"><a href=\"#Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\" class=\"headerlink\" title=\"Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\"></a>Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</h2><blockquote>\n<p> 使用Symbol来替代常量,并且别人无法通过外部调用到内部的这个参数的值。主要还是作为对象属性名（key），特性是绝对唯一！</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> root = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> generateName = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> postfix = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">descString</span>)</span>&#123;</span><br><span class=\"line\">         postfix++;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">'@@'</span> + descString + <span class=\"string\">'_'</span> + postfix</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> SymbolPolyfill = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Symbol</span>(<span class=\"params\">description</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> SymbolPolyfill) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Symbol is not a constructor'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">var</span> descString = description === <span class=\"literal\">undefined</span> ? <span class=\"literal\">undefined</span> : <span class=\"built_in\">String</span>(description)</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">var</span> symbol = <span class=\"built_in\">Object</span>.create(&#123;</span><br><span class=\"line\">         toString: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.__Name__;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         valueOf: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"built_in\">Object</span>.defineProperties(symbol, &#123;</span><br><span class=\"line\">         <span class=\"string\">'__Description__'</span>: &#123;</span><br><span class=\"line\">             value: descString,</span><br><span class=\"line\">             writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">             enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">             configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         <span class=\"string\">'__Name__'</span>: &#123;</span><br><span class=\"line\">             value: generateName(descString),</span><br><span class=\"line\">             writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">             enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">             configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> symbol;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> forMap = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">Object</span>.defineProperties(SymbolPolyfill, &#123;</span><br><span class=\"line\">     <span class=\"string\">'for'</span>: &#123;</span><br><span class=\"line\">         value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">description</span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">var</span> descString = description === <span class=\"literal\">undefined</span> ? <span class=\"literal\">undefined</span> : <span class=\"built_in\">String</span>(description)</span><br><span class=\"line\">             <span class=\"keyword\">return</span> forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">         configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"string\">'keyFor'</span>: &#123;</span><br><span class=\"line\">         value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">symbol</span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> forMap) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (forMap[key] === symbol) <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">         configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"> root.SymbolPolyfill = SymbolPolyfill;</span><br><span class=\"line\"> &#125;)()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JavaScript中的变量在内存中的具体存储形式\"><a href=\"#JavaScript中的变量在内存中的具体存储形式\" class=\"headerlink\" title=\"JavaScript中的变量在内存中的具体存储形式\"></a>JavaScript中的变量在内存中的具体存储形式</h2><blockquote>\n<p>值类型和引用类型。存在堆和栈中。 如图所示:<img src=\"https://segmentfault.com/img/bVCuzt?w=579&h=182\" alt=\"å¾çæè¿°\"></p>\n<h3 id=\"堆-amp-栈\"><a href=\"#堆-amp-栈\" class=\"headerlink\" title=\"堆&amp;栈:\"></a>堆&amp;栈:</h3><p>栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。<br>堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。<br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>栈（数据结构）：一种先进后出的数据结构。</p>\n<p>栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。<br>堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序</p>\n</blockquote>\n<h2 id=\"基本类型对应的内置对象，以及他们之间的装箱拆箱操作\"><a href=\"#基本类型对应的内置对象，以及他们之间的装箱拆箱操作\" class=\"headerlink\" title=\"基本类型对应的内置对象，以及他们之间的装箱拆箱操作\"></a>基本类型对应的内置对象，以及他们之间的装箱拆箱操作</h2><p>装箱：所谓装箱，就是把基本类型转变为对应的对象。装箱分为隐式和显示。<br>string（显示装箱），bool（显示装箱）,number(隐式装箱),object,null.</p>\n<p>拆箱：拆箱与装箱相反，把对象转变为基本类型的值。拆箱过程内部调用了抽象操作 ToPrimitive 。ToPrimitive 先检查对象是否有 valueOf 方法，如果有则再检查 valueOf 方法是否有基本类型的返回值。如果没有 valueOf 方法或 valueOf 方法没有返回值，则调用 toString 方法。如果 toString 方法也没有返回值，产生 TypeError 错误。</p>\n<h2 id=\"理解值类型和引用类型\"><a href=\"#理解值类型和引用类型\" class=\"headerlink\" title=\"理解值类型和引用类型\"></a>理解值类型和引用类型</h2><blockquote>\n<p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。</p>\n<p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。</p>\n</blockquote>\n<h2 id=\"null和undefined的区别\"><a href=\"#null和undefined的区别\" class=\"headerlink\" title=\"null和undefined的区别\"></a>null和undefined的区别</h2><blockquote>\n<p>null表示”没有对象”，即该处不应该有值。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p>\n</blockquote>\n<h2 id=\"至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\"><a href=\"#至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\" class=\"headerlink\" title=\"至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\"></a>至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</h2><blockquote>\n<p><strong>typeof</strong> </p>\n<ul>\n<li><p>对于基本类型，除 null 以外，均可以返回正确的结果。</p>\n</li>\n<li><p>对于引用类型，除 function 以外，一律返回 object 类型。</p>\n</li>\n<li><p>对于 null ，返回 object 类型。</p>\n</li>\n<li><p>对于 function 返回  function 类型。</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a><strong>instanceof</strong></h3><p>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型</p>\n</blockquote>\n<blockquote>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a><strong>constructor</strong></h3><p> null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p>\n<p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p>\n</blockquote>\n<h2 id=\"可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\"><a href=\"#可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\" class=\"headerlink\" title=\"可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\"></a>可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用</h2><blockquote>\n<p>隐式转换中主要涉及到三种转换：</p>\n<p>1、将值转为原始值，ToPrimitive()。</p>\n<p>2、将值转为数字，ToNumber()。</p>\n<p>3、将值转为字符串，ToString()</p>\n<p> 如何避免：使用ts。巧妙应用：尽量不要用</p>\n</blockquote>\n<h2 id=\"出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\"><a href=\"#出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\" class=\"headerlink\" title=\"出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\"></a>出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法</h2><blockquote>\n<p>发生场景： 0.1 + 0.2 === 0.30000000000000004</p>\n<p>细致分析原因：是浮点数存储本身固有的缺陷。浮点数无法精确表示其数值范围内的所有数值，只能精确表示可用科学计数法 m*2^e 表示的数值而已，比如0.5的科学计数法是2^(-1)，则可被精确存储；而0.1、0.2则无法被精确存储</p>\n<p>(0.1).toString(‘2’) // “0.0001100110011001100110011001100110011001100110011001101” </p>\n<p>(0.2).toString(‘2’) // “0.001100110011001100110011001100110011001100110011001101”</p>\n<p> (0.1+0.2).toString(‘2’) // “0.0100110011001100110011001100110011001100110011001101” </p>\n<p>(0.3).toString(‘2’) // “0.010011001100110011001100110011001100110011001100110011”</p>\n</blockquote>\n<h4 id=\"ES6解决方案\"><a href=\"#ES6解决方案\" class=\"headerlink\" title=\"ES6解决方案\"></a>ES6解决方案</h4><p>ES6在Number对象上新增了一个极小的常量——Number.EPSILON</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number.EPSILON</span><br><span class=\"line\">// 2.220446049250313e-16</span><br><span class=\"line\">Number.EPSILON.toFixed(20)</span><br><span class=\"line\">// &quot;0.00000000000000022204&quot;</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>引入一个这么小的量，目的在于为浮点数计算设置一个误差范围，如果误差能够小于Number.EPSILON，我们就可以认为结果是可靠的。</p>\n<p>误差检查函数（出自《ES6标准入门》-阮一峰）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function withinErrorMargin (left, right) &#123;</span><br><span class=\"line\">    return Math.abs(left - right) &lt; Number.EPSILON</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">withinErrorMargin(0.1+0.2, 0.3)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"原型和原型链\"><a href=\"#原型和原型链\" class=\"headerlink\" title=\"原型和原型链\"></a>原型和原型链</h1><h2 id=\"理解原型设计模式以及JavaScript中的原型规则\"><a href=\"#理解原型设计模式以及JavaScript中的原型规则\" class=\"headerlink\" title=\"理解原型设计模式以及JavaScript中的原型规则\"></a>理解原型设计模式以及JavaScript中的原型规则</h2><h2 id=\"instanceof的底层实现原理，手动实现一个instanceof\"><a href=\"#instanceof的底层实现原理，手动实现一个instanceof\" class=\"headerlink\" title=\"instanceof的底层实现原理，手动实现一个instanceof\"></a>instanceof的底层实现原理，手动实现一个instanceof</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function my_instanceof(obj, constructor) &#123;</span><br><span class=\"line\">  let constuctProto = constructor.prototype</span><br><span class=\"line\">  while (true) &#123;</span><br><span class=\"line\">    if (obj.__protp__ === null) &#123;</span><br><span class=\"line\">      // 遍历完对象的原型链</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (obj.__proto__ === constuctProto) &#123;</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    obj = obj.__proto__</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.实现继承的几种方式以及他们的优缺点</p>\n<blockquote>\n<ol>\n<li>prototype</li>\n<li>extend</li>\n<li>create</li>\n</ol>\n</blockquote>\n<p>5.至少说出一种开源项目(如Node)中应用原型继承的案例</p>\n<p>6.可以描述new一个对象的详细过程，手动实现一个new操作符</p>\n<blockquote>\n<p>首先新建一个 new Object() //这里是不是有问题， 如果新建一个{}还可以说说</p>\n<p>然后吧argumentsy映射到新建的对象上（引用地址）</p>\n<p>把原型链映射到新建的对象上</p>\n</blockquote>\n<p>7.理解es6 class构造以及继承的底层实现原理</p>\n<blockquote>\n<p>应该就是语法糖，对于prototype的优化把</p>\n</blockquote>\n<p>作用域和闭包<br>1.理解词法作用域和动态作用域</p>\n<blockquote>\n<p>作用域是指程序源代码中定义变量的区域。</p>\n<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>\n<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>\n</blockquote>\n<p>2.理解JavaScript的作用域和作用域链</p>\n<blockquote>\n<h3 id=\"全局作用域-Global-Scope-最外层函数和最外层函数定义的变量，未使用var赋值，window对象\"><a href=\"#全局作用域-Global-Scope-最外层函数和最外层函数定义的变量，未使用var赋值，window对象\" class=\"headerlink\" title=\"全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象\"></a>全局作用域(Global Scope):最外层函数和最外层函数定义的变量，未使用var赋值，window对象</h3><h3 id=\"局部作用域-Local-Scope\"><a href=\"#局部作用域-Local-Scope\" class=\"headerlink\" title=\"局部作用域(Local Scope)\"></a>局部作用域(Local Scope)</h3><h2 id=\"作用域链-Scope-Chain-：所有的变量都会向上寻找表示\"><a href=\"#作用域链-Scope-Chain-：所有的变量都会向上寻找表示\" class=\"headerlink\" title=\"作用域链(Scope Chain)：所有的变量都会向上寻找表示\"></a>作用域链(Scope Chain)：所有的变量都会向上寻找表示</h2><h3 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h3><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</p>\n</blockquote>\n<p>3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题</p>\n<blockquote>\n<p>无法叙述</p>\n</blockquote>\n<p>4.this的原理以及几种不同使用场景的取值</p>\n<blockquote>\n<p>因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。</p>\n</blockquote>\n<h4 id=\"情况一：全局-amp-调用普通函数\"><a href=\"#情况一：全局-amp-调用普通函数\" class=\"headerlink\" title=\"情况一：全局 &amp; 调用普通函数\"></a>情况一：全局 &amp; 调用普通函数</h4><p>在全局环境中，this 永远指向 window。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this === window);     //true</span><br></pre></td></tr></table></figure>\n\n<p>普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = 10;</span><br><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    console.log(this);     //Window</span><br><span class=\"line\">    console.log(this.x);   //10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"情况二：构造函数\"><a href=\"#情况二：构造函数\" class=\"headerlink\" title=\"情况二：构造函数\"></a>情况二：构造函数</h4><p>所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo()&#123;</span><br><span class=\"line\">    this.x = 10;</span><br><span class=\"line\">    console.log(this);    //Foo &#123;x:10&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = new Foo();</span><br><span class=\"line\">console.log(foo.x);      //10</span><br></pre></td></tr></table></figure>\n\n<p>上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。</p>\n<p>但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo()&#123;</span><br><span class=\"line\">    this.x = 10;</span><br><span class=\"line\">    console.log(this);    //Window</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = Foo();</span><br><span class=\"line\">console.log(foo.x);      //undefined</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"情况三：对象方法\"><a href=\"#情况三：对象方法\" class=\"headerlink\" title=\"情况三：对象方法\"></a>情况三：对象方法</h4><p>如果函数作为对象的方法时，方法中的 this 指向该对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function () &#123;</span><br><span class=\"line\">        console.log(this);        //Object</span><br><span class=\"line\">        console.log(this.x);      //10</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：若是在对象方法中定义函数，那么情况就不同了。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function () &#123;</span><br><span class=\"line\">        function f()&#123;</span><br><span class=\"line\">            console.log(this);      //Window</span><br><span class=\"line\">            console.log(this.x);    //undefined</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        f();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p>可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。</p>\n<p>在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function () &#123;</span><br><span class=\"line\">        var self = this;</span><br><span class=\"line\">        function f()&#123;</span><br><span class=\"line\">            console.log(self);      //&#123;x: 10&#125;</span><br><span class=\"line\">            console.log(self.x);    //10</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        f();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p>如果 foo 函数不作为对象方法被调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function () &#123;</span><br><span class=\"line\">        console.log(this);       //Window</span><br><span class=\"line\">        console.log(this.x);     //undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var fn = obj.foo;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n\n<p>obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。</p>\n<h4 id=\"情况四：构造函数-prototype-属性\"><a href=\"#情况四：构造函数-prototype-属性\" class=\"headerlink\" title=\"情况四：构造函数 prototype 属性\"></a>情况四：构造函数 prototype 属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo()&#123;</span><br><span class=\"line\">    this.x = 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype.getX = function () &#123;</span><br><span class=\"line\">    console.log(this);        //Foo &#123;x: 10, getX: function&#125;</span><br><span class=\"line\">    console.log(this.x);      //10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = new Foo();</span><br><span class=\"line\">foo.getX();</span><br></pre></td></tr></table></figure>\n\n<p>在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。</p>\n<h4 id=\"情况五：函数用-call、apply或者-bind-调用。\"><a href=\"#情况五：函数用-call、apply或者-bind-调用。\" class=\"headerlink\" title=\"情况五：函数用 call、apply或者 bind 调用。\"></a>情况五：函数用 call、apply或者 bind 调用。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    console.log(this);     //&#123;x: 10&#125;</span><br><span class=\"line\">    console.log(this.x);   //10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.call(obj);</span><br><span class=\"line\">foo.apply(obj);</span><br><span class=\"line\">foo.bind(obj)();</span><br></pre></td></tr></table></figure>\n\n<p>当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。</p>\n<h4 id=\"情况六：DOM-event-this\"><a href=\"#情况六：DOM-event-this\" class=\"headerlink\" title=\"情况六：DOM event this\"></a>情况六：DOM event this</h4><p>在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Listener()&#123;   </span><br><span class=\"line\">    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;, this.handleClick);     //这里的 this 指向 Listener 这个对象。不是强调的是这里的 this</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Listener.prototype.handleClick = function (event) &#123;</span><br><span class=\"line\">    console.log(this);    //&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var listener = new Listener();</span><br><span class=\"line\">document.getElementById(&apos;foo&apos;).click();</span><br></pre></td></tr></table></figure>\n\n<p>这个很好理解，就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    fn: function() &#123;</span><br><span class=\"line\">        console.log(this);         //Window</span><br><span class=\"line\">        console.log(this.x);       //undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function foo(fn) &#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">foo(obj.fn);</span><br></pre></td></tr></table></figure>\n\n<p>你也可以用通过 bind 切换上下文:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function  Listener()&#123;</span><br><span class=\"line\">    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;,this.handleClick.bind(this));      </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Listener.prototype.handleClick = function (event) &#123;</span><br><span class=\"line\">    console.log(this);    //Listener &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var listener = new Listener();</span><br><span class=\"line\">document.getElementById(&apos;foo&apos;).click();</span><br></pre></td></tr></table></figure>\n\n<p>前六种情况其实可以总结为： this 指向调用该方法的对象。</p>\n<h4 id=\"情况七：箭头函数中的-this\"><a href=\"#情况七：箭头函数中的-this\" class=\"headerlink\" title=\"情况七：箭头函数中的 this\"></a>情况七：箭头函数中的 this</h4><p>当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function() &#123;</span><br><span class=\"line\">        var fn = () =&gt; &#123;</span><br><span class=\"line\">            return () =&gt; &#123;</span><br><span class=\"line\">                return () =&gt; &#123;</span><br><span class=\"line\">                    console.log(this);      //Object &#123;x: 10&#125;</span><br><span class=\"line\">                    console.log(this.x);    //10</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fn()()();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p>现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。</p>\n<p>如果使用箭头函数，以前的这种 hack 写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var self = this;</span><br></pre></td></tr></table></figure>\n\n<p>就不再需要了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 10,</span><br><span class=\"line\">    foo: function() &#123;</span><br><span class=\"line\">        var fn = () =&gt; &#123;</span><br><span class=\"line\">            return () =&gt; &#123;</span><br><span class=\"line\">                return () =&gt; &#123;</span><br><span class=\"line\">                    console.log(this);    // Object &#123;x: 10&#125;</span><br><span class=\"line\">                    console.log(this.x);  //10</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fn.bind(&#123;x: 14&#125;)()()();</span><br><span class=\"line\">        fn.call(&#123;x: 14&#125;)()();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo();</span><br></pre></td></tr></table></figure>\n\n<p>由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。</p>\n<h2 id=\"5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\"><a href=\"#5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\" class=\"headerlink\" title=\"5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\"></a>5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用</h2><p>JavaScript闭包的形成原理是基于函数变量作用域链的规则 和 垃圾回收机制的引用计数规则。<br>JavaScript闭包的本质是内存泄漏，指定内存不释放。 </p>\n<p>应用：私有变量</p>\n<p>##6.理解堆栈溢出和内存泄漏的原理，如何防止</p>\n<p>溢出：没有足够的内存空间供其使用，泄漏：GC没起作用，闭包。防止闭包</p>\n<h1 id=\"7-如何处理循环的异步操作\"><a href=\"#7-如何处理循环的异步操作\" class=\"headerlink\" title=\"7.如何处理循环的异步操作\"></a>7.如何处理循环的异步操作</h1><p>promise.all</p>\n<p>#8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理</p>\n<p>amd cmd umd    -》sea require npm</p>\n<p>(function(a){</p>\n<p>returm {</p>\n<p>a:1</p>\n<p>}<br>})(1)</p>\n<p>#执行机制</p>\n<p>##1.为何try里面放return，finally还会执行，理解其内部机制</p>\n<p>类似promise？</p>\n<p>##2.JavaScript如何实现异步编程，可以详细描述EventLoop机制</p>\n<p>一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。</p>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#Event_loop\" target=\"_blank\" rel=\"noopener\">事件循环</a>期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。</p>\n<p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (queue.waitForMessage()) &#123;</span><br><span class=\"line\">  queue.processNextMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##3.宏任务和微任务分别有哪些</p>\n<p>4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法</p>\n<p>分清楚 promise await settimeout的执行顺序</p>\n<p>5.使用Promise实现串行</p>\n<p>找一个第三方的缓存，把状态缓存住就行了</p>\n<p>6.Node与浏览器EventLoop的差异</p>\n<p>7.如何在保证页面运行流畅的情况下处理海量数据</p>\n<p>不加载海量dom</p>\n<p>语法和API<br>1.理解ECMAScript和JavaScript的关系</p>\n<p>ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。(蹭热度)</p>\n<p>2.熟练运用es5、es6提供的语法规范，</p>\n<p>3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）</p>\n<p>4.熟练应用map、reduce、filter 等高阶函数解决问题</p>\n<p>5.setInterval需要注意的点，使用settimeout实现setInterval</p>\n<p>6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题</p>\n<p>7.JavaScript异常处理的方式，统一的异常处理方案</p>\n<p>HTML和CSS</p>\n<p>HTML<br>1.从规范的角度理解HTML，从分类和语义的角度使用标签</p>\n<p>早期语义化是为SEO和规范，目前原生的语义化作用很弱，更多体现在js框架中组件的语义化</p>\n<p>2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式</p>\n<p>3.元信息类标签(head、title、meta)的使用目的和配置方法</p>\n<p>4.HTML5离线缓存原理</p>\n<p>5.可以使用Canvas API、SVG等绘制高性能的动画</p>\n<p>CSS<br>1.CSS盒模型，在不同浏览器的差异</p>\n<p>2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则</p>\n<p>3.CSS伪类和伪元素有哪些，它们的区别和实际应用</p>\n<p>4.HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理</p>\n<p>5.水平垂直居中的方案、可以实现6种以上并对比它们的优缺点</p>\n<p>6.BFC实现原理，可以解决的问题，如何创建BFC</p>\n<p>7.可使用CSS函数复用代码，实现特殊效果</p>\n<p>8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种</p>\n<p>9.CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染</p>\n<p>10.熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等</p>\n<p>11.CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况</p>\n<p>12.掌握一套完整的响应式布局方案</p>\n<p>手写<br>1.手写图片瀑布流效果</p>\n<p>2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）</p>\n<p>3.使用纯CSS实现曲线运动（贝塞尔曲线）</p>\n<p>4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点</p>\n<p>计算机基础<br>关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要。<br>编译原理<br>1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序</p>\n<p>2.正则表达式的匹配原理和性能优化</p>\n<p>3.如何将JavaScript代码解析成抽象语法树(AST)</p>\n<p>4.base64的编码原理</p>\n<p>5.几种进制的相互转换计算方法，在JavaScript中如何表示和转换</p>\n<p>网络协议<br>1.理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用</p>\n<p>2.三次握手和四次挥手详细原理，为什么要使用这种机制</p>\n<p>3.有哪些协议是可靠，TCP有哪些手段保证可靠交付</p>\n<p>4.DNS的作用、DNS解析的详细过程，DNS优化原理</p>\n<p>5.CDN的作用和原理</p>\n<p>6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么</p>\n<p>7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题</p>\n<p>8.HTTP1.1、HTTP2.0带来的改变</p>\n<p>9.HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求</p>\n<p>10.理解WebSocket协议的底层原理、与HTTP的区别</p>\n<p>设计模式<br>1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等</p>\n<p>2.发布订阅模式和观察者模式的异同以及实际应用</p>\n<p>3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用</p>\n<p>数据结构和算法<br>据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！</p>\n<p>JavaScript编码能力<br>1.多种方式实现数组去重、扁平化、对比优缺点</p>\n<p>2.多种方式实现深拷贝、对比优缺点</p>\n<p>3.手写函数柯里化工具函数、并理解其应用场景和优势</p>\n<p>4.手写防抖和节流工具函数、并理解其内部原理和应用场景</p>\n<p>5.实现一个sleep函数</p>\n<p>手动实现前端轮子<br>1.手动实现call、apply、bind</p>\n<p>2.手动实现符合Promise/A+规范的Promise、手动实现async await</p>\n<p>3.手写一个EventEmitter实现事件发布、订阅</p>\n<p>4.可以说出两种实现双向绑定的方案、可以手动实现</p>\n<p>5.手写JSON.stringify、JSON.parse</p>\n<p>6.手写一个模版引擎，并能解释其中原理</p>\n<p>7.手写懒加载、下拉刷新、上拉加载、预加载等效果</p>\n<p>数据结构<br>1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点</p>\n<p>2.理解数组、字符串的存储原理，并熟练应用他们解决问题</p>\n<p>3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题</p>\n<p>4.了解图、堆的基本结构和使用场景</p>\n<p>算法<br>1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗</p>\n<p>2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度</p>\n<p>3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用</p>\n<p>4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题</p>\n<p>5.前端处理海量数据的算法方案</p>\n<p>运行环境<br>我们需要理清语言和环境的关系：<br>ECMAScript描述了JavaScript语言的语法和基本对象规范</p>\n<p>浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口</p>\n<p>Node也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API</p>\n<p>浏览器API<br>1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性</p>\n<p>2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性</p>\n<p>3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)</p>\n<p>4.浏览器海量数据存储、操作性能优化</p>\n<p>5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理</p>\n<p>6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库</p>\n<p>7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型</p>\n<p>8.浏览器提供的几种存储机制、优缺点、开发中正确的选择</p>\n<p>9.浏览器跨标签通信</p>\n<p>浏览器原理<br>1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分</p>\n<p>2.请求数据到请求结束与服务器进行了几次交互</p>\n<p>3.可详细描述浏览器从输入URL到页面展现的详细过程</p>\n<p>4.浏览器解析HTML代码的原理，以及构建DOM树的流程</p>\n<p>5.浏览器如何解析CSS规则，并将其应用到DOM树上</p>\n<p>6.浏览器如何将解析好的带有样式的DOM树进行绘制</p>\n<p>7.浏览器的运行机制，如何配置资源异步同步加载</p>\n<p>8.浏览器回流与重绘的底层原理，引发原因，如何有效避免</p>\n<p>9.浏览器的垃圾回收机制，如何避免内存泄漏</p>\n<p>10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案</p>\n<p>Node<br>1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等</p>\n<p>2.掌握一种Node开发框架，如Express，Express和Koa的区别</p>\n<p>3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理</p>\n<p>4.Node的底层运行原理、和浏览器的异同</p>\n<p>5.Node事件驱动、非阻塞机制的实现原理</p>\n<p>框架和类库<br>轮子层出不穷，从原理上理解才是正道<br>TypeScript<br>1.理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现</p>\n<p>2.理解使用TypeScript的好处，掌握TypeScript基础语法</p>\n<p>3.TypeScript的规则检测原理</p>\n<p>4.可以在React、Vue等框架中使用TypeScript进行开发</p>\n<p>React<br>1.React和vue 选型和优缺点、核心架构的区别</p>\n<p>2.React中setState的执行机制，如何有效的管理状态</p>\n<p>3.React的事件底层实现机制</p>\n<p>4.React的虚拟DOM和Diff算法的内部实现</p>\n<p>5.React的Fiber工作原理，解决了什么问题</p>\n<p>6.React Router和Vue Router的底层实现原理、动态加载实现原理</p>\n<p>7.可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题</p>\n<p>8.基于React的特性和原理，可以手动实现一个简单的React</p>\n<p>Vue<br>1.熟练使用Vue的API、生命周期、钩子函数</p>\n<p>2.MVVM框架设计理念</p>\n<p>3.Vue双向绑定实现原理、Diff算法的内部实现</p>\n<p>4.Vue的事件机制</p>\n<p>5.从template转换成真实DOM的实现机制</p>\n<p>多端开发<br>1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案</p>\n<p>2.理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用</p>\n<p>3.移动端页面适配解决方案、不同机型适配方案</p>\n<p>4.掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配</p>\n<p>5.掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理</p>\n<p>6.掌握一种小程序开发框架或原生小程序开发</p>\n<p>7.理解多端框架的内部实现原理，至少了解一个多端框架的使用</p>\n<p>数据流管理<br>1.掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同</p>\n<p>2.熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理</p>\n<p>3.熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势</p>\n<p>4.熟练使用Vuex管理数据流，并理解其实现原理</p>\n<p>5.以上数据流方案的异同和优缺点，不情况下的技术选型</p>\n<p>实用库<br>1.至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现</p>\n<p>2.掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表</p>\n<p>3.掌握一种GIS开发框架，如百度地图API</p>\n<p>4.掌握一种可视化开发框架，如Three.js、D3</p>\n<p>5.工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理</p>\n<p>开发和调试<br>1.熟练使用各浏览器提供的调试工具</p>\n<p>2.熟练使用一种代理工具实现请求代理、抓包，如charls</p>\n<p>3.可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案</p>\n<p>4.了解Vue、React等框架调试工具的使用</p>\n<p>前端工程<br>前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度<br>项目构建<br>1.理解npm、yarn依赖包管理的原理，两者的区别</p>\n<p>2.可以使用npm运行自定义脚本</p>\n<p>3.理解Babel、ESLint、webpack等工具在项目中承担的作用</p>\n<p>4.ESLint规则检测原理，常用的ESLint配置</p>\n<p>5.Babel的核心原理，可以自己编写一个Babel插件</p>\n<p>6.可以配置一种前端代码兼容方案，如Polyfill</p>\n<p>7.Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用</p>\n<p>8.可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins</p>\n<p>nginx<br>1.正向代理与反向代理的特点和实例</p>\n<p>2.可手动搭建一个简单的nginx服务器、</p>\n<p>3.熟练应用常用的nginx内置变量，掌握常用的匹配规则写法</p>\n<p>4.可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理</p>\n<p>开发提速<br>1.熟练掌握一种接口管理、接口mock工具的使用，如yapi</p>\n<p>2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题</p>\n<p>3.理解TDD与BDD模式，至少会使用一种前端单元测试框架</p>\n<p>版本控制<br>1.理解Git的核心原理、工作流程、和SVN的区别</p>\n<p>2.熟练使用常规的Git命令、git rebase、git stash等进阶命令</p>\n<p>3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题</p>\n<p>持续集成<br>1.理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins</p>\n<p>2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）</p>\n<p>项目和业务</p>\n<p>后端技能<br>1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言</p>\n<p>2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库</p>\n<p>性能优化<br>1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案</p>\n<p>2.了解常见的Web、App性能优化方案</p>\n<p>3.SEO排名规则、SEO优化方案、前后端分离的SEO</p>\n<p>4.SSR实现方案、优缺点、及其性能优化</p>\n<p>5.Webpack的性能优化方案</p>\n<p>6.Canvas性能优化方案</p>\n<p>7.React、Vue等框架使用性能优化方案</p>\n<p>前端安全<br>1.XSS攻击的原理、分类、具体案例，前端如何防御</p>\n<p>2.CSRF攻击的原理、具体案例，前端如何防御</p>\n<p>3.HTTP劫持、页面劫持的原理、防御措施</p>\n<p>业务相关<br>1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题</p>\n<p>2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题</p>\n<p>3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性</p>\n<p>学习提升</p>\n<p>vczh大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答：</p>\n<p>这十几年我一共做了三件事：</p>\n<p>1、不以赚钱为目的选择学习的内容；</p>\n<p>2、以自己是否能造出轮子来衡量学习的效果；</p>\n<p>3、坚持每天写自己的代码，前10年每天至少6个小时，不包含学习和工作的时间。</p>\n<p>上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。</p>\n<p>关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多</p>\n<p>1.拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏</p>\n<p>2.定期的将知识进行总结，不断完善自己的知识体系</p>\n<p>3.尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用</p>\n<p>4.坚持输出自己的代码，不要盲目的扎进公司业</p>\n<p>技术之外</p>\n<p>这部分可能比上面九条加起来重要！</p>\n<p>1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS等</p>\n<p>2.了解互联网行业术语：B2B、B2C、C2C、O2O等</p>\n<p>3.掌握互联网行业沟通、问答、学习的</p>\n<p>4.有一定的”PPT”能力</p>\n<p>5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识</p>\n<p>6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系<br>.如何理解 JS 中的this关键字？</p>\n<ol>\n<li>由于 this 关键字很混乱，如何解决这个问题<br>3.什么是闭包<br>4.解释一下变量的提升</li>\n<li>JavaScript如何处理同步和异步情况</li>\n<li>如何理解事件委托</li>\n<li>如何理解高阶函数。</li>\n<li>如何区分声明函数和表达式函数</li>\n<li>解释一下严格模式(strict mode)</li>\n</ol>\n"},{"_content":"# 六大原则\n\n1.单一职责原则:只做一件事情\n2.里氏替换原则:同岗位人之间可以互相调换\n3.依赖倒转原则:应用层依赖底层，但是底层不依赖应用层\n4.接口隔离原则:模块只声明自己需要的接口\n5.迪米特法则:在你眼里，我应该是黑盒。\n6.开闭原则:你只能看，不能改\n\n\n\n1. 开闭原则： 对扩展开放，对修改关闭\n2. 里氏转换原则： 子类继承父类，单独完全可以运行\n3. 依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型\n4. 接口隔离原则： 每一个接口应该是一种角色\n5. 合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分\n6. 迪米特原则： 一个对象应对其他对象有尽可能少的了解\n\n> 我会在下面设计的模式中，声明使用到对应的原则\n\n# 为什么要尽量使用白话\n\n> 纯术语的文章太多，不利于归纳成记忆点，尤其是实际应用中。所以我尝试着能否使用白话或者极度精简的文字去分解这些复杂侃长的语句。\n\n# 为什么要使用设计模式\n > 开发人员A碰到了一个问题，就找开发B,开发B说用\"xxxx设计模式就行了\"，如果这个时候开发A不懂设计模式，那他们就无法交流了。就如同我们在汉语里使用成语一样，当你在交流中使用一个成语的时候，是不会去讲述这个成语背后的故事的。因此，一个合格的开发人员，必须掌握设计模式这个“标准词汇”\n > 但是过度复杂化的设计模式也不可取，保持一个代码与模式的平衡是一个非常重要的事情。\n >\n > <!-- more --> \n\n本质：将软件中变化的部分和不变的部分分开\n\n# 设计模式的类型\n\n# 1．创建型模式\n\n创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关系创建对象过程中的逻辑。\n\n社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：\n\n- 简单工厂模式（Simple Factory）\n- 工厂方法模式（Factory Method）\n- 抽象工厂模式（Abstract Factory）\n- 创建者模式（Builder）\n- 原型模式（Prototype）\n- 单例模式（Singleton）\n\n> 简单工厂模式不是GoF总结出来的23种设计模式之一\n\n# 2．结构型模式\n\n结构型模式是为解决怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）。\n\n在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：\n\n- 外观模式/门面模式（Facade门面模式）\n- 适配器模式（Adapter）\n- 代理模式（Proxy）\n- 装饰模式（Decorator）\n- 桥梁模式/桥接模式（Bridge）\n- 组合模式（Composite）\n- 享元模式（Flyweight）\n\n# 3．行为型模式\n\n行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式。1. 行为类模式使用继承机制在类间分派行为。2. 行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。\n\n在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：\n\n- 模板方法模式（Template Method）\n- 观察者模式（Observer）\n- 状态模式（State）\n- 策略模式（Strategy）\n- 职责链模式（Chain of Responsibility）\n- 命令模式（Command）\n- 访问者模式（Visitor）\n- 调停者模式（Mediator）\n- 备忘录模式（Memento）\n- 迭代器模式（Iterator）\n- 解释器模式（Interpreter）\n\n## 三者之间的区别和联系\n\n> 创建型模式提供生存环境，结构型模式提供生存理由，行为型模式提供如何生存。\n\n1. 创建型模式为其他两种模式使用提供了环境。\n2. 结构型模式侧重于接口的使用，它做的一切工作都是对象或是类之间的交互，提供一个门。\n3. 行为型模式顾名思义，侧重于具体行为，所以概念中才会出现职责分配和算法通信等内容。\n\n# 五大创建型模式\n\n> 关于创造型模式\n\n## 单例模式(Singleton Pattern)\n\n###一句话总结：虽然我有很多网名，但是全世界就一个我\n\n###代码\n\n```\nfunction Menu() {\n    // 判断是否存在实例\n    if (typeof Universe.instance === 'object') {\n        return Universe.instance;\n    }\n    // 其它内容\n    this.food =[\"hanbao\",\"kele\"];\n    // 缓存\n    Menu.instance = this;\n    // 隐式返回this\n}\n\n// 测试\nvar zhizhi = new Menu();\nvar qiantai=new Menu();\nconsole.log(uni === uni2); // true\n```\n\n###定义\n\n> 保证系统内部只有唯一一个对应的实例对象，又细分为最开始就实例化（简单粗暴），和第一次使用的时候实例化（可能需要额外的代码来实现这块功能）\n>\n> 单例模式在[多线程](https://zh.wikipedia.org/wiki/线程)的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。\n>\n> 通常单例模式在[Java语言](https://zh.wikipedia.org/wiki/Java语言)中，有两种构建方式：\n>\n> - 懒汉方式。指全局的单例实例在第一次被使用时构建。\n> - 饿汉方式。指全局的单例实例在类装载时构建。\n\n###应用\n\n* 就像KFC中的菜单，不管你在app还是前天，或者纸质菜单上查看，永远只有一份实例。\n\n\n## 简单工厂模式(Simple Factory)\n\n## 一句话就是 自动奶茶机\n\n## 代码\n\n```\n var request1 = ajax('cgi.xx.com/xxx' , ''get' );\n \nrequest1.start();\n \nrequest1.done( fn );\n \nvar request2 = ajax('cgi.xx.com/xxx' , ''jsonp' );\n \nrequest2.start();\n \nrequest2.done( fn );\n```\n\n\n\n## 定义\n\n> 这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况.说的通俗点，就像公司茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。\n>\n> 你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。\n>\n> 缺点也很明显，所有逻辑都封装在工厂类呢，但是根据场景使用 还是会很优雅。属于基础的设计模式\n\n## 应用\n\nKFC饮料机器\n\n\n\n## 抽象工厂(Abstract Factory)\n\n### 一句话 interface\n\n### 定义\n\n就是通过类的抽象使得业务适用于一个产品类簇的创建，而不负责某一类产品的实例。\n\nJS中是没有直接的抽象类的，abstract是个保留字，但是还没有实现，因此我们需要在类的方法中抛出错误来模拟抽象类，如果继承的子类中没有覆写该方法而调用，就会抛出错误。\n\n工厂是一个抽象类，它不能够直接被实例化，工厂的作用是制定产品族类的结构。土一点的理解方式就是，interface。\n\n### 代码\n\n```\n/**\n* 实现subType类对工厂类中的superType类型的抽象类的继承\n* @param subType 要继承的类\n* @param superType 工厂类中的抽象类type\n*/\nconst VehicleFactory = function(subType, superType) {\n  if (typeof VehicleFactory[superType] === 'function') {\n    function F() {\n      this.type = '车辆'\n    } \n    F.prototype = new VehicleFactory[superType]()\n    subType.constructor = subType\n    subType.prototype = new F()                // 因为子类subType不仅需要继承superType对应的类的原型方法，还要继承其对象属性\n  } else throw new Error('不存在该抽象类')\n}\n\nVehicleFactory.Car = function() {\n  this.type = 'car'\n}\nVehicleFactory.Car.prototype = {\n  getPrice: function() {\n    return new Error('抽象方法不可使用')\n  },\n  getSpeed: function() {\n    return new Error('抽象方法不可使用')\n  }\n}\n\nconst BMW = function(price, speed) {\n  this.price = price\n  this.speed = speed\n}\nVehicleFactory(BMW, 'Car')        // 继承Car抽象类\nBMW.prototype.getPrice = function() {        // 覆写getPrice方法\n  console.log(`BWM price is ${this.price}`)\n}\nBMW.prototype.getSpeed = function() {\n  console.log(`BWM speed is ${this.speed}`)\n}\n\nconst baomai5 = new BMW(30, 99)\nbaomai5.getPrice()                          // BWM price is 30\nbaomai5 instanceof VehicleFactory.Car     \n```\n\n### 应用\n\nKFC汉堡类型：面包片+调料+肉+蔬菜+面包片\n\n## 建造者模式（Builder Pattern）\n\n###一句话总结\n\n### 定义\n\n### 代码\n\n### 应用\n\n\n\n1.简述：将一个复杂对象的--构建--与它的表示分离，使得同样的构建过程可以创建.一步步构造一个复杂对象，返回一个完整的对象``\n2.代码\n\n```\n// #建造者模式 \n```\n\n\n// 抽象建造者\nvar Car = function (param) {\n    // 速度\n    this.speed = param && param.speed || '0';\n    // 重量\n    this.weight = param && param.weight || '0';\n}\n\n\nCar.prototype = {\n    // 获取速度\n    getSpeed: function () {\n        return this.speed;\n    },\n    // 获取重量\n    getWeight: function () {\n        return this.weight\n    }\n}\n\n// 轮胎部件类\nvar Tyre = function (type) {\n    var that = this;\n    // 构造器\n    // 构造函数中通过传入的type类型设置相对应的轮胎尺寸\n    (function (type,that) {\n        switch (type) {\n            case 'small':\n            that.tyre = '小号轮胎';\n            that.tyreIntro = '正在使用小号轮胎';\n            break;\n            case 'normal':\n            that.tyre = '中号轮胎';\n            that.tyreIntro = '正在使用中号轮胎';\n            break;\n            case 'big':\n            that.tyre = '大号轮胎';\n            that.tyreIntro = '正在使用大号轮胎';\n            break;\n        }\n    })(type,this);\n}\n\n\nTyre.prototype = {\n    // 更换轮胎的方法\n    changeType: function (type) {\n        that.tyre = type;\n        that.tyreIntro = '正在使用'+type;\n    }\n}\n\n\n// 发动机部件类\nvar Engine = function (type) {\n    var that = this;\n    // 构造器\n    // 构造函数中通过传入的type类型设置相对应的发动机类型\n    (function (type,that) {\n        switch (type) {\n            case 'small':\n            that.engine = '小号发动机';\n            that.engineIntro = '正在使用小号发动机';\n            break;\n            case 'normal':\n            that.engine = '中号发动机';\n            that.engineIntro = '正在使用中号发动机';\n            break;\n            case 'big':\n            that.engine = '大号发动机';\n            that.engineIntro = '正在使用大号发动机';\n            break;\n        }\n    })(type,this);\n}\n\n\nEngine.prototype = {\n    // 更换发动机的方法\n    changeType: function (type) {\n        that.engine = type;\n        that.engineIntro = '正在使用'+type;\n    }\n}\n\n/**\n * 指挥者,建造一个奔驰车的类\n * @param {*轮胎类型 small normal big} tyre \n * @param {*发动机类型 small normal big} engine \n * @param {*车辆基本属性 param.speed:速度 param.weight: 重量} param \n */\nvar BenChi = function (tyre,engine,param) {\n    // 创建一个车辆缓存对象\n    var _car = new Car(param);ckplayer 隐藏控制\n    // 创建车辆的轮胎\n    _car.tyreInfo = new Tyre(tyre);\n    // 创建车辆的发动机\n    _car.engineInfo = new Engine(engine);\n    // 将创建的车辆对象返回\n    return _car;\n}\n\n// 具体建造者 实例化奔驰车类\nvar benchi1 = new BenChi('small','big',{speed: 200,weight: '200'});\nconsole.log(benchi1.speed);// 200\nconsole.log(benchi1.weight);// 200\nconsole.log(benchi1.tyreInfo.tyre);// 小号轮胎\nconsole.log(benchi1.tyreInfo.tyreIntro);// 正在使用小号轮胎\nconsole.log(benchi1.engineInfo.engine);// 大号发动机\nconsole.log(benchi1.engineInfo.engineIntro);// 正在使用大号发动机\n  ```\n  3.优点:每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。\n  4.缺点\n  5.白话总结:建造者模式主要用于“分布构建一个复杂的对象”\n  ```\n\n## 原型模式\n\n减少new，使用create直接创建对象。\n\n# 行为型模式\n\n## 模版方式\n\n>类似管控的视频模块，应该要使用这个模式,就是预设好具体的口子给继承方使用。\n>\n>1.抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。\n>\n>2.模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。\n>\n>3.钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。\n\n  ```javascript\n/* 抽象父类：饮料 */\nvar Beverage = function(){};\n// (1) 把水煮沸\nBeverage.prototype.boilWater = function() {\n    console.log(\"把水煮沸\");\n};\n// (2) 沸水浸泡\nBeverage.prototype.brew = function() {\n    throw new Error(\"子类必须重写brew方法\");\n};\n// (3) 倒进杯子\nBeverage.prototype.pourInCup = function() {\n    throw new Error(\"子类必须重写pourInCup方法\");\n};\n// (4) 加调料\nBeverage.prototype.addCondiments = function() {\n    throw new Error(\"子类必须重写addCondiments方法\");\n};\n\n/* 模板方法 */\nBeverage.prototype.init = function() {\n    this.boilWater();\n    this.brew();\n    this.pourInCup();\n    this.addCondiments();\n}\n\n/* 实现子类 Coffee*/\nvar Coffee = function(){};\nCoffee.prototype = new Beverage();\n// 重写非公有方法\nCoffee.prototype.brew = function() {\n    console.log(\"用沸水冲泡咖啡\");\n};\nCoffee.prototype.pourInCup = function() {\n    console.log(\"把咖啡倒进杯子\");\n};\nCoffee.prototype.addCondiments = function() {\n    console.log(\"加牛奶\");\n};\nvar coffee = new Coffee();\ncoffee.init();\n\n  ```\n\n通过模板方法模式，在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用大多数子类的，但也会出现“个性”子类。\n如上述流程，加调料是可选的。\n钩子方法可以解决这个问题，放置钩子是隔离变化的一种常见手段。\n\n```javascript\n/* 添加钩子方法 */\nBeverage.prototype.customerWantsCondiments = function() {\n    return true;\n};\nBeverage.prototype.init = function() {\n    this.boilWater();\n    this.brew();\n    this.pourInCup();\n    if(this.customerWantsCondiments()) {\n        this.addCondiments();\n    }\n}\n\n/* 实现子类 Tea*/\nvar Tea = function(){};\nTea.prototype = new Beverage();\n// 重写非公有方法\nTea.prototype.brew = function() {\n    console.log(\"用沸水冲泡茶\");\n};\nTea.prototype.pourInCup = function() {\n    console.log(\"把茶倒进杯子\");\n};\nTea.prototype.addCondiments = function() {\n    console.log(\"加牛奶\");\n};\nTea.prototype.customerWantsCondiments = function() {\n    return window.confirm(\"需要添加调料吗？\");\n};\nvar tea = new Tea();\ntea.init();\n```\n\nJavaScript没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。\n\n## 中介者模式\n\n>面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性。但由于这些细粒度对象之间的联系激增，又可能反过来降低它们的可复用性。\n>中介者模式的作用就是解除对象与对象之间的紧耦合关系。\n>\n>之前卓锐的路网系统就是这样开发，但是和观察者好像有点雷同。查阅资料以后发现：\n>\n>**中介者(mediator)强调的是同事(colleague)类之间的交互**\n>\n>**而观察者(observer)中的目标类(subject)强调是目标改变后对观察者进行统一的通讯**\n>\n>**两者非常相同的一点就是:中介者需要持有并且知道所有的同事类,而目标类也必须持有所有的目标类,但是是一目标类的接口引用方式持有,所以说目标类是不知道观察者的,所有的观察者都是一样的**\n>\n>其实从名称考虑，确实相当于是房产中介在租房和房东之间的关系。\n\n## 命令模式\n\n> 命令模式比较容易设计一个命令队列( 容易AOP)，在需求的情况下比较容易将命令计入日志，并且允许接受请求的一方决定是否需要调用，而且可以实现对请求的撤销和重设，而且由于新增的具体类不影响其他的类，所以很容易实现。\n>\n> \n\n```javascript\n$(function () {\n\n    var CarManager = {\n\n        // 请求信息\n        requestInfo: function (model, id) {\n            return 'The information for ' + model +\n        ' with ID ' + id + ' is foobar';\n        },\n\n        // 购买汽车\n        buyVehicle: function (model, id) {\n            return 'You have successfully purchased Item '\n        + id + ', a ' + model;\n        },\n\n        // 组织view\n        arrangeViewing: function (model, id) {\n            return 'You have successfully booked a viewing of '\n        + model + ' ( ' + id + ' ) ';\n        }\n    };\n})();\n//来看一下上述代码，通过调用函数来简单执行manager的命令，然而在一些情况下，我们并不想直接调用对象内部的方法。这样会增加对象与对象间的依赖。现在我们来扩展一下这个CarManager 使其能够接受任何来自包括model和car ID 的CarManager对象的处理请求。根据命令模式的定义，我们希望实现如下这种功能的调用：\n\nCarManager.execute({ commandType: \"buyVehicle\", operand1: 'Ford Escort', operand2: '453543' });\n//根据这样的需求，我们可以这样啦实现CarManager.execute方法：\n\nCarManager.execute = function (command) {\n    return CarManager[command.request](command.model, command.carID);\n};\n//改造以后，调用就简单多了，如下调用都可以实现（当然有些异常细节还是需要再完善一下的）：\n\nCarManager.execute({ request: \"arrangeViewing\", model: 'Ferrari', carID: '145523' });\nCarManager.execute({ request: \"requestInfo\", model: 'Ford Mondeo', carID: '543434' });\nCarManager.execute({ request: \"requestInfo\", model: 'Ford Escort', carID: '543434' });\nCarManager.execute({ request: \"buyVehicle\", model: 'Ford Escort', carID: '543434' });\n```\n\n\n\n**设计模式的核心思想是不是都插入一个中间层，把业务集中到中间层去？**\n\n## 职责链模式\n\n### 定义\n\n职责连是由多个不同的对象组成的，有发送者跟接收者，分别负责信息的发送跟接收，其中，链中第一个对象是 职责连是由多个不同的对象组成的，发送者是发送请求的对象，接收者接收请求并且对其进行处理或传递的对象。基本流程如下：\n\n1. 发送者知道链中的第一个接收者，它向这个接收者发送该请求。\n2. 每一个接收者都对请求进行分析，然后要么处理它，要么它往下传递。\n3. 每一个接收者知道其他的对象只有一个，即它在链中的下家(successor)。\n4. 如果没有任何接收者处理请求，那么请求会从链中离开。\n\n职责链模式是个链式结构，请求在链中的节点之间依次传递，直到有一个对象能处理该请求为止。如果没有任何对象处理该请求的话，那么请求就会从链中离开\n\n### 事例代码\n\n>假设这么一个场景：\n>我们负责一个售卖手机的电商网站，经过分别缴纳500元定金和200元定金的两轮预定后，到了正式购买阶段。针对预定用户实行优惠，支付过500元定金的用户会收到100元的商城优惠券，支付过200元定金的用户会收到50元的商城优惠券，没有支付定金的用户归为普通购买，且在库存有限的情况下不一定保证买到。\n\n```\n/* 传统方式实现 */\n// orderType：[1:500, 2:200, 3:普通]，isPaid：true/false，stock：库存量\nvar order = function(orderType, isPaid, stock) {\n    if(orderType === 1) {\n        if(isPaid) {\n            console.log(\"500元定金预购，得到100优惠券\");\n        } else {\n            if(stock > 0) {\n                console.log(\"普通购买，无优惠券\");\n            }else {\n                console.log(\"库存不足\");\n            }\n        }\n    }else if(orderType === 2) {\n        if(isPaid) {\n            console.log(\"200元定金预购，得到50优惠券\");\n        } else {\n            if(stock > 0) {\n                console.log(\"普通购买，无优惠券\");\n            }else {\n                console.log(\"库存不足\");\n            }\n        }\n    }else if(orderType === 2) {\n        if(stock > 0) {\n            console.log(\"普通购买，无优惠券\");\n        }else {\n            console.log(\"库存不足\");\n        }\n    }\n}\n\norder(1, true, 500);\n\n/*职责链 */\nvar order500 = function(orderType, isPaid, stock) {\n    if(orderType === 1 && isPaid === true) {\n        console.log(\"500元定金预购，得到100优惠券\");\n    }else {\n        return \"nextSuccessor\";\n    }\n};\n\nvar order200 = function(orderType, isPaid, stock) {\n    if(orderType === 2 && isPaid === true) {\n        console.log(\"200元定金预购，得到50优惠券\");\n    }else {\n        return \"nextSuccessor\";\n    }\n};\n\nvar orderNormal = function(orderType, isPaid, stock) {\n    if(stock > 0) {\n        console.log(\"普通购买，无优惠券\");\n    }else {\n        console.log(\"库存不足\");\n    }\n};\n\nFunction.prototype.after = function(fn) {\n    var self = this;\n    return function() {\n        var ret = self.apply(this, arguments);\n        if(ret === \"nextSuccessor\") {\n            return fn.apply(this, arguments);\n        }\n        return ret;\n    };\n}\n\nvar order = order500.after(order200).after(orderNormal);\norder(1, true, 10);//结合AOP\n```\n\n\n\n### 延伸应用\n\n常见的做法其实是优惠卷的案例？\n\n## 策略模式\n\n### 定义\n\n定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。\n基于策略类模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，Context接收客户的请求，随后把请求委托给某一个策略类。\n\n### 事例\n\n```\nvar strategies = {\n    \"S\": function(salary) {\n        return salary * 4;\n    },\n    \"A\": function(salary) {\n        return salary * 3;\n    },\n    \"B\": function(salary) {\n        return salary * 2;\n    }\n};\n\n// 接收请求\nvar calculateBonus = function(level, salary) {\n    return strategies[level](salary);\n};\n\n// 测试\nconsole.log(calculateBonus(\"S\", 20000));\nconsole.log(calculateBonus(\"A\", 20000));\nconsole.log(calculateBonus(\"B\", 20000));\n```\n\n### 延伸应用\n\n常见的表单验证js,如：validator.js\n\n# 迭代器模式\n\n## 一句话总结：就是foreach\n\n##定义\n\n> 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n\n## 代码\n\n```js\nvar each = function(ary, callback) {\n    for(var i = 0, l = ary.length; i < l; i++) {\n        callback.call(ary[i], i, ary[i]);\n    }   \n};\neach([1, 2, 3], function(i, n) {\n    console.log(\"当前下标为：\"+ i + \" 当前元素为：\"+ n );\n});\n```\n\n\n\n##延伸应用\n\n文件上传，根据不同的浏览器获取相应的上传组件对象。(高阶用法，存疑)\n\n# 观察者模式\n\n## 一句话总结就是:就是vue里的emit/on\n\n## 定义\n\n> 观察者模式又叫做发布订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察着对象。 它是由两类对象组成，主题和观察者，主题负责发布事件，同时观察者通过订阅这些事件来观察该主体，发布者和订阅者是完全解耦的，彼此不知道对方的存在，两者仅仅共享一个自定义事件的名称。\n\n## 代码\n\n```\nvar p1 = new Pubsub();\n p1.on('mm', function (name) {\n     console.log('mm: '+ name);\n });\n p1.emit('mm','哈哈哈哈');\n```\n\n\n\n## 应用\n\nMQ\n\n# 状态模式\n\n## 一句话总结就是：有限状态机\n\n## 定义\n\n状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。\n\n## 代码\n\n```js\n// 关灯\nvar OffLightState = function(light) {\n    this.light = light;\n};\n// 弱光\nvar OffLightState = function(light) {\n    this.light = light;\n};\n// 强光\nvar StrongLightState = function(light) {\n    this.light = light;\n};\n\nvar Light = function(){\n    /* 开关状态 */\n    this.offLight = new OffLightState(this);\n    this.weakLight = new WeakLightState(this);\n    this.strongLight = new StrongLightState(this);\n    /* 快关按钮 */\n    this.button = null;\n};\nLight.prototype.init = function() {\n    var button = document.createElement(\"button\"),\n        self = this;\n    this.button = document.body.appendChild(button);\n    this.button.innerHTML = '开关';\n    this.currentState = this.offLight;\n    this.button.click = function() {\n        self.currentState.buttonWasPressed();\n    }\n};\n// 让抽象父类的抽象方法直接抛出一个异常（避免状态子类未实现buttonWasPressed方法）\nLight.prototype.buttonWasPressed = function() {\n    throw new Error(\"父类的buttonWasPressed方法必须被重写\");\n};\nLight.prototype.setState = function(newState) {\n    this.currentState = newState;\n};\n\n/* 关灯 */\nOffLightState.prototype = new Light();  // 继承抽象类\nOffLightState.prototype.buttonWasPressed = function() {\n    console.log(\"关灯！\");\n    this.light.setState(this.light.weakLight);\n}\n/* 弱光 */\nWeakLightState.prototype = new Light();\nWeakLightState.prototype.buttonWasPressed = function() {\n    console.log(\"弱光！\");\n    this.light.setState(this.light.strongLight);\n};\n/* 强光 */\nStrongLightState.prototype = new Light();\nStrongLightState.prototype.buttonWasPressed = function() {\n    console.log(\"强光！\");\n    this.light.setState(this.light.offLight);\n};\n```\n\n\n\n## 应用\n\n任意上层应用的状态显示\n\n# 备忘录模式\n\n##一句话总结就是：就是留个备份，出问题了就回滚\n\n## 定义\n\n暂无\n\n## 代码\n\n```js\n\nvar Page = function(){\n   var page = 1,\n      cache = {},\n      data;\n   return function( page ){\n      if ( cache[ page ] ){\n               data =  cache[ page ];\n               render( data );\n      }else{\n               Ajax.send( 'cgi.xx.com/xxx', function( data ){\n                   cache[ page ] = data;\n                   render( data );\n               })\n      }\n    }\n}()\n```\n\n## 应用\n\n操作回溯\n\n# 解释器模式\n\n##一句话总结就是：抽象语法树AST\n\n## 定义\n\n```\n如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n```\n\n##代码\n\n\n\n##应用\n\nSQL \n\n# 访问者模式\n\n## 一句话总结就是：我中有你 你中有我\n\n##定义\n\n访问者模式：针对于对象结构中的元素，定义在不改变对象的前提下访问结构中元素的方法\n\n在访问者模式中，主要包括下面几个角色\n\n1、抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。\n\n2、访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。\n\n3、抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。\n\n4、元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。\n\n5、结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。\n\n## 代码\n\n```\nfunction Visitor() {  \n  this.visit = function( concreteElement ) {  \n    concreteElement.doSomething();  \n  }  \n}  \n// 元素类  \nfunction ConceteElement() {  \n  this.doSomething = function() {  \n    console.log(\"这是一个具体元素\");  \n  }  \n  this.accept = function( visitor ) {  \n    visitor.visit(this);  \n  }  \n} \n// Client  \nvar ele = new ConceteElement();  \nvar v = new Visitor();  \nele.accept( v );  \n```\n\n\n\n## 应用\n\n无\n\n# 适配器模式\n\n##一句话就是：不同类型的数据线的转接器\n\n## 定义 \n\n将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。\n\n## 代码\n\n```\nfunction PhoneUSBTypecToMicroUSB(Phone) {\n  var _USBTypec = new ChargingCord('USBTypec');\n  var _MicroUSB = new ChargingCord('MicroUSB');\n  if (_USBTypec.check(Phone.getChargingCord())) {\n    Phone.charging = function () {\n      console.log(this.getName());\n      _USBTypec.work();\n      console.log('转接');\n      _MicroUSB.work();\n      console.log('接收');\n    }\n    Phone.getChargingCord = function () {\n      return _MicroUSB;\n    };\n    return Phone;\n  }\n  else {\n    console.log('接口不对无法转换');\n  }\n}\n\nfunction PhoneMicroUSBToUSBTypec(Phone) {\n  var _USBTypec = new ChargingCord('USBTypec');\n  var _MicroUSB = new ChargingCord('MicroUSB');\n  if (_MicroUSB.check(Phone.getChargingCord())) {\n    Phone.charging = function () {\n      console.log(this.getName());\n      _MicroUSB.work();\n      console.log('转接');\n      _USBTypec.work();\n      console.log('接收');\n    }\n    Phone.getChargingCord = function () {\n      return _USBTypec;\n    };\n    return Phone;\n  }\n  else {\n    console.log('接口不对无法转换');\n  }\n}\n\nfunction PhoneDeleteInterface(Phone){\n  delete Phone.charging;\n  delete Phone.getChargingCord;\n  return Phone;\n}\n```\n\n\n\n## 应用\n\n在不动应用层的情况下，切换底层、\n\n# 桥接模式\n\n## 一句话就是 中间夹了一个类\n\n## 定义\n\n用桥接模式联结多个类\n\n## 代码\n\n```\nvar Class1 =function(a,b,c){\n\tthis.a =a;\n\tthis.b = b;\n\tthis.c = c;\n}\nvar Class2 =function(d){\n\tthis.d = d;\n}\nvar BridgeClass =function(a,b,c,d){\n\t   this.one = new Class1(a,b,c);\n\t   this.two = new Class2(d);\n}\n```\n\n\n\n## 应用\n\n暂无\n\n# 组合模式\n\n## 一句话定义：树状结构，且行为递归执行\n\n##定义\n\n部分-整体模式，它将所有对象组合成树形结构。使得用户只需要操作最上层的接口，就可以对所有成员做相同的操作。\n\n## 代码\n\n```\n$( 'body' ).unbind( '*' );//触发所有的dom解绑定事件\n```\n\n\n\n## 应用\n\njqdom对象\n\n# 装饰模式\n\n## 一句话总结：珍珠奶茶\n\n## 定义\n\n** 装饰者(decorator) **模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。\n\n## 代码\n\n>\n\n```\nvar Plan1 = {\n    fire: function () {\n        console.log('发射普通的子弹');\n    }\n};\n\nvar missileDecorator= function () {\n    console.log('发射导弹!');\n};\n\nvar fire = Plan1.fire;\n\nPlan1.fire=function () {\n    fire();\n    missileDecorator();\n};\n\nPlan1.fire();\n```\n\n## 应用\n\nAOP\n\n# 外观模式\n\n## 一句话总结就是:减少外部需要记忆的api\n\n## 定义\n\n外观模式提供一个高层接口，这个接口使得客户端或子系统更加方便调用。\n\n## 代码\n\n> var getName = function(){\n>\n>   return ''svenzeng\"\n>\n> }\n>\n> var getSex = function(){\n>\n>    return 'man'\n>\n> }\n>\n> var getUserInfo = function(){\n>\n>   var info = a() + b();\n>\n>   return info;\n>\n> }\n\n## 应用\n\n快餐\n\n# 享元模式\n\n## 一句话总结就是：虚拟列表，只创建你看得见的dom\n\n## 定义\n\n提供一些共享的对象以便重复利用. \n\n## 代码\n\n```\n var getDiv = (function(){\n    var created = [];\n    var create = function(){\n          return document.body.appendChild( document.createElement( 'div' ) );\n    }\n    var get = function(){\n         if ( created.length ){\n              return created.shift();\n          }else{\n                return create();\n           }\n     }\n/* 一个假设的事件，用来监听刚消失在视线外的div，实际上可以通过监听滚                                     动条位置来实现 */\n      userInfoContainer.disappear(function( div ){\n              created.push( div );\n        })\n })()\n  var div = getDiv();\n  div.innerHTML = \"${userinfo}\";\n```\n\n\n\n##应用\n\n虚拟列表，只创建你看得见的dom\n\n# 代理模式\n\n## 一句话就是：代理人先整理需求\n\n## 定义\n\n代理模式的定义是把对一个对象的访问, 交给另一个代理对象来操作.\n\n## 代码\n\n```\nvar request = proxy.get( 'cgi.xx.com/xxx' );\n \nrequest.send();\n \nrequest.done(function(){\n \n});\n```\n\n\n\n## 应用\n\n实际的编程中， 这种因为性能问题使用代理模式的机会是非常多的。比如频繁的访问dom节点, 频繁的请求远程资源. 可以把操作先存到一个缓冲区, 然后自己选择真正的触发时机.\n\n","source":"_posts/设计模式.md","raw":"# 六大原则\n\n1.单一职责原则:只做一件事情\n2.里氏替换原则:同岗位人之间可以互相调换\n3.依赖倒转原则:应用层依赖底层，但是底层不依赖应用层\n4.接口隔离原则:模块只声明自己需要的接口\n5.迪米特法则:在你眼里，我应该是黑盒。\n6.开闭原则:你只能看，不能改\n\n\n\n1. 开闭原则： 对扩展开放，对修改关闭\n2. 里氏转换原则： 子类继承父类，单独完全可以运行\n3. 依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型\n4. 接口隔离原则： 每一个接口应该是一种角色\n5. 合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分\n6. 迪米特原则： 一个对象应对其他对象有尽可能少的了解\n\n> 我会在下面设计的模式中，声明使用到对应的原则\n\n# 为什么要尽量使用白话\n\n> 纯术语的文章太多，不利于归纳成记忆点，尤其是实际应用中。所以我尝试着能否使用白话或者极度精简的文字去分解这些复杂侃长的语句。\n\n# 为什么要使用设计模式\n > 开发人员A碰到了一个问题，就找开发B,开发B说用\"xxxx设计模式就行了\"，如果这个时候开发A不懂设计模式，那他们就无法交流了。就如同我们在汉语里使用成语一样，当你在交流中使用一个成语的时候，是不会去讲述这个成语背后的故事的。因此，一个合格的开发人员，必须掌握设计模式这个“标准词汇”\n > 但是过度复杂化的设计模式也不可取，保持一个代码与模式的平衡是一个非常重要的事情。\n >\n > <!-- more --> \n\n本质：将软件中变化的部分和不变的部分分开\n\n# 设计模式的类型\n\n# 1．创建型模式\n\n创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关系创建对象过程中的逻辑。\n\n社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：\n\n- 简单工厂模式（Simple Factory）\n- 工厂方法模式（Factory Method）\n- 抽象工厂模式（Abstract Factory）\n- 创建者模式（Builder）\n- 原型模式（Prototype）\n- 单例模式（Singleton）\n\n> 简单工厂模式不是GoF总结出来的23种设计模式之一\n\n# 2．结构型模式\n\n结构型模式是为解决怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）。\n\n在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：\n\n- 外观模式/门面模式（Facade门面模式）\n- 适配器模式（Adapter）\n- 代理模式（Proxy）\n- 装饰模式（Decorator）\n- 桥梁模式/桥接模式（Bridge）\n- 组合模式（Composite）\n- 享元模式（Flyweight）\n\n# 3．行为型模式\n\n行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式。1. 行为类模式使用继承机制在类间分派行为。2. 行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。\n\n在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：\n\n- 模板方法模式（Template Method）\n- 观察者模式（Observer）\n- 状态模式（State）\n- 策略模式（Strategy）\n- 职责链模式（Chain of Responsibility）\n- 命令模式（Command）\n- 访问者模式（Visitor）\n- 调停者模式（Mediator）\n- 备忘录模式（Memento）\n- 迭代器模式（Iterator）\n- 解释器模式（Interpreter）\n\n## 三者之间的区别和联系\n\n> 创建型模式提供生存环境，结构型模式提供生存理由，行为型模式提供如何生存。\n\n1. 创建型模式为其他两种模式使用提供了环境。\n2. 结构型模式侧重于接口的使用，它做的一切工作都是对象或是类之间的交互，提供一个门。\n3. 行为型模式顾名思义，侧重于具体行为，所以概念中才会出现职责分配和算法通信等内容。\n\n# 五大创建型模式\n\n> 关于创造型模式\n\n## 单例模式(Singleton Pattern)\n\n###一句话总结：虽然我有很多网名，但是全世界就一个我\n\n###代码\n\n```\nfunction Menu() {\n    // 判断是否存在实例\n    if (typeof Universe.instance === 'object') {\n        return Universe.instance;\n    }\n    // 其它内容\n    this.food =[\"hanbao\",\"kele\"];\n    // 缓存\n    Menu.instance = this;\n    // 隐式返回this\n}\n\n// 测试\nvar zhizhi = new Menu();\nvar qiantai=new Menu();\nconsole.log(uni === uni2); // true\n```\n\n###定义\n\n> 保证系统内部只有唯一一个对应的实例对象，又细分为最开始就实例化（简单粗暴），和第一次使用的时候实例化（可能需要额外的代码来实现这块功能）\n>\n> 单例模式在[多线程](https://zh.wikipedia.org/wiki/线程)的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。\n>\n> 通常单例模式在[Java语言](https://zh.wikipedia.org/wiki/Java语言)中，有两种构建方式：\n>\n> - 懒汉方式。指全局的单例实例在第一次被使用时构建。\n> - 饿汉方式。指全局的单例实例在类装载时构建。\n\n###应用\n\n* 就像KFC中的菜单，不管你在app还是前天，或者纸质菜单上查看，永远只有一份实例。\n\n\n## 简单工厂模式(Simple Factory)\n\n## 一句话就是 自动奶茶机\n\n## 代码\n\n```\n var request1 = ajax('cgi.xx.com/xxx' , ''get' );\n \nrequest1.start();\n \nrequest1.done( fn );\n \nvar request2 = ajax('cgi.xx.com/xxx' , ''jsonp' );\n \nrequest2.start();\n \nrequest2.done( fn );\n```\n\n\n\n## 定义\n\n> 这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况.说的通俗点，就像公司茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。\n>\n> 你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。\n>\n> 缺点也很明显，所有逻辑都封装在工厂类呢，但是根据场景使用 还是会很优雅。属于基础的设计模式\n\n## 应用\n\nKFC饮料机器\n\n\n\n## 抽象工厂(Abstract Factory)\n\n### 一句话 interface\n\n### 定义\n\n就是通过类的抽象使得业务适用于一个产品类簇的创建，而不负责某一类产品的实例。\n\nJS中是没有直接的抽象类的，abstract是个保留字，但是还没有实现，因此我们需要在类的方法中抛出错误来模拟抽象类，如果继承的子类中没有覆写该方法而调用，就会抛出错误。\n\n工厂是一个抽象类，它不能够直接被实例化，工厂的作用是制定产品族类的结构。土一点的理解方式就是，interface。\n\n### 代码\n\n```\n/**\n* 实现subType类对工厂类中的superType类型的抽象类的继承\n* @param subType 要继承的类\n* @param superType 工厂类中的抽象类type\n*/\nconst VehicleFactory = function(subType, superType) {\n  if (typeof VehicleFactory[superType] === 'function') {\n    function F() {\n      this.type = '车辆'\n    } \n    F.prototype = new VehicleFactory[superType]()\n    subType.constructor = subType\n    subType.prototype = new F()                // 因为子类subType不仅需要继承superType对应的类的原型方法，还要继承其对象属性\n  } else throw new Error('不存在该抽象类')\n}\n\nVehicleFactory.Car = function() {\n  this.type = 'car'\n}\nVehicleFactory.Car.prototype = {\n  getPrice: function() {\n    return new Error('抽象方法不可使用')\n  },\n  getSpeed: function() {\n    return new Error('抽象方法不可使用')\n  }\n}\n\nconst BMW = function(price, speed) {\n  this.price = price\n  this.speed = speed\n}\nVehicleFactory(BMW, 'Car')        // 继承Car抽象类\nBMW.prototype.getPrice = function() {        // 覆写getPrice方法\n  console.log(`BWM price is ${this.price}`)\n}\nBMW.prototype.getSpeed = function() {\n  console.log(`BWM speed is ${this.speed}`)\n}\n\nconst baomai5 = new BMW(30, 99)\nbaomai5.getPrice()                          // BWM price is 30\nbaomai5 instanceof VehicleFactory.Car     \n```\n\n### 应用\n\nKFC汉堡类型：面包片+调料+肉+蔬菜+面包片\n\n## 建造者模式（Builder Pattern）\n\n###一句话总结\n\n### 定义\n\n### 代码\n\n### 应用\n\n\n\n1.简述：将一个复杂对象的--构建--与它的表示分离，使得同样的构建过程可以创建.一步步构造一个复杂对象，返回一个完整的对象``\n2.代码\n\n```\n// #建造者模式 \n```\n\n\n// 抽象建造者\nvar Car = function (param) {\n    // 速度\n    this.speed = param && param.speed || '0';\n    // 重量\n    this.weight = param && param.weight || '0';\n}\n\n\nCar.prototype = {\n    // 获取速度\n    getSpeed: function () {\n        return this.speed;\n    },\n    // 获取重量\n    getWeight: function () {\n        return this.weight\n    }\n}\n\n// 轮胎部件类\nvar Tyre = function (type) {\n    var that = this;\n    // 构造器\n    // 构造函数中通过传入的type类型设置相对应的轮胎尺寸\n    (function (type,that) {\n        switch (type) {\n            case 'small':\n            that.tyre = '小号轮胎';\n            that.tyreIntro = '正在使用小号轮胎';\n            break;\n            case 'normal':\n            that.tyre = '中号轮胎';\n            that.tyreIntro = '正在使用中号轮胎';\n            break;\n            case 'big':\n            that.tyre = '大号轮胎';\n            that.tyreIntro = '正在使用大号轮胎';\n            break;\n        }\n    })(type,this);\n}\n\n\nTyre.prototype = {\n    // 更换轮胎的方法\n    changeType: function (type) {\n        that.tyre = type;\n        that.tyreIntro = '正在使用'+type;\n    }\n}\n\n\n// 发动机部件类\nvar Engine = function (type) {\n    var that = this;\n    // 构造器\n    // 构造函数中通过传入的type类型设置相对应的发动机类型\n    (function (type,that) {\n        switch (type) {\n            case 'small':\n            that.engine = '小号发动机';\n            that.engineIntro = '正在使用小号发动机';\n            break;\n            case 'normal':\n            that.engine = '中号发动机';\n            that.engineIntro = '正在使用中号发动机';\n            break;\n            case 'big':\n            that.engine = '大号发动机';\n            that.engineIntro = '正在使用大号发动机';\n            break;\n        }\n    })(type,this);\n}\n\n\nEngine.prototype = {\n    // 更换发动机的方法\n    changeType: function (type) {\n        that.engine = type;\n        that.engineIntro = '正在使用'+type;\n    }\n}\n\n/**\n * 指挥者,建造一个奔驰车的类\n * @param {*轮胎类型 small normal big} tyre \n * @param {*发动机类型 small normal big} engine \n * @param {*车辆基本属性 param.speed:速度 param.weight: 重量} param \n */\nvar BenChi = function (tyre,engine,param) {\n    // 创建一个车辆缓存对象\n    var _car = new Car(param);ckplayer 隐藏控制\n    // 创建车辆的轮胎\n    _car.tyreInfo = new Tyre(tyre);\n    // 创建车辆的发动机\n    _car.engineInfo = new Engine(engine);\n    // 将创建的车辆对象返回\n    return _car;\n}\n\n// 具体建造者 实例化奔驰车类\nvar benchi1 = new BenChi('small','big',{speed: 200,weight: '200'});\nconsole.log(benchi1.speed);// 200\nconsole.log(benchi1.weight);// 200\nconsole.log(benchi1.tyreInfo.tyre);// 小号轮胎\nconsole.log(benchi1.tyreInfo.tyreIntro);// 正在使用小号轮胎\nconsole.log(benchi1.engineInfo.engine);// 大号发动机\nconsole.log(benchi1.engineInfo.engineIntro);// 正在使用大号发动机\n  ```\n  3.优点:每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。\n  4.缺点\n  5.白话总结:建造者模式主要用于“分布构建一个复杂的对象”\n  ```\n\n## 原型模式\n\n减少new，使用create直接创建对象。\n\n# 行为型模式\n\n## 模版方式\n\n>类似管控的视频模块，应该要使用这个模式,就是预设好具体的口子给继承方使用。\n>\n>1.抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。\n>\n>2.模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。\n>\n>3.钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。\n\n  ```javascript\n/* 抽象父类：饮料 */\nvar Beverage = function(){};\n// (1) 把水煮沸\nBeverage.prototype.boilWater = function() {\n    console.log(\"把水煮沸\");\n};\n// (2) 沸水浸泡\nBeverage.prototype.brew = function() {\n    throw new Error(\"子类必须重写brew方法\");\n};\n// (3) 倒进杯子\nBeverage.prototype.pourInCup = function() {\n    throw new Error(\"子类必须重写pourInCup方法\");\n};\n// (4) 加调料\nBeverage.prototype.addCondiments = function() {\n    throw new Error(\"子类必须重写addCondiments方法\");\n};\n\n/* 模板方法 */\nBeverage.prototype.init = function() {\n    this.boilWater();\n    this.brew();\n    this.pourInCup();\n    this.addCondiments();\n}\n\n/* 实现子类 Coffee*/\nvar Coffee = function(){};\nCoffee.prototype = new Beverage();\n// 重写非公有方法\nCoffee.prototype.brew = function() {\n    console.log(\"用沸水冲泡咖啡\");\n};\nCoffee.prototype.pourInCup = function() {\n    console.log(\"把咖啡倒进杯子\");\n};\nCoffee.prototype.addCondiments = function() {\n    console.log(\"加牛奶\");\n};\nvar coffee = new Coffee();\ncoffee.init();\n\n  ```\n\n通过模板方法模式，在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用大多数子类的，但也会出现“个性”子类。\n如上述流程，加调料是可选的。\n钩子方法可以解决这个问题，放置钩子是隔离变化的一种常见手段。\n\n```javascript\n/* 添加钩子方法 */\nBeverage.prototype.customerWantsCondiments = function() {\n    return true;\n};\nBeverage.prototype.init = function() {\n    this.boilWater();\n    this.brew();\n    this.pourInCup();\n    if(this.customerWantsCondiments()) {\n        this.addCondiments();\n    }\n}\n\n/* 实现子类 Tea*/\nvar Tea = function(){};\nTea.prototype = new Beverage();\n// 重写非公有方法\nTea.prototype.brew = function() {\n    console.log(\"用沸水冲泡茶\");\n};\nTea.prototype.pourInCup = function() {\n    console.log(\"把茶倒进杯子\");\n};\nTea.prototype.addCondiments = function() {\n    console.log(\"加牛奶\");\n};\nTea.prototype.customerWantsCondiments = function() {\n    return window.confirm(\"需要添加调料吗？\");\n};\nvar tea = new Tea();\ntea.init();\n```\n\nJavaScript没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。\n\n## 中介者模式\n\n>面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性。但由于这些细粒度对象之间的联系激增，又可能反过来降低它们的可复用性。\n>中介者模式的作用就是解除对象与对象之间的紧耦合关系。\n>\n>之前卓锐的路网系统就是这样开发，但是和观察者好像有点雷同。查阅资料以后发现：\n>\n>**中介者(mediator)强调的是同事(colleague)类之间的交互**\n>\n>**而观察者(observer)中的目标类(subject)强调是目标改变后对观察者进行统一的通讯**\n>\n>**两者非常相同的一点就是:中介者需要持有并且知道所有的同事类,而目标类也必须持有所有的目标类,但是是一目标类的接口引用方式持有,所以说目标类是不知道观察者的,所有的观察者都是一样的**\n>\n>其实从名称考虑，确实相当于是房产中介在租房和房东之间的关系。\n\n## 命令模式\n\n> 命令模式比较容易设计一个命令队列( 容易AOP)，在需求的情况下比较容易将命令计入日志，并且允许接受请求的一方决定是否需要调用，而且可以实现对请求的撤销和重设，而且由于新增的具体类不影响其他的类，所以很容易实现。\n>\n> \n\n```javascript\n$(function () {\n\n    var CarManager = {\n\n        // 请求信息\n        requestInfo: function (model, id) {\n            return 'The information for ' + model +\n        ' with ID ' + id + ' is foobar';\n        },\n\n        // 购买汽车\n        buyVehicle: function (model, id) {\n            return 'You have successfully purchased Item '\n        + id + ', a ' + model;\n        },\n\n        // 组织view\n        arrangeViewing: function (model, id) {\n            return 'You have successfully booked a viewing of '\n        + model + ' ( ' + id + ' ) ';\n        }\n    };\n})();\n//来看一下上述代码，通过调用函数来简单执行manager的命令，然而在一些情况下，我们并不想直接调用对象内部的方法。这样会增加对象与对象间的依赖。现在我们来扩展一下这个CarManager 使其能够接受任何来自包括model和car ID 的CarManager对象的处理请求。根据命令模式的定义，我们希望实现如下这种功能的调用：\n\nCarManager.execute({ commandType: \"buyVehicle\", operand1: 'Ford Escort', operand2: '453543' });\n//根据这样的需求，我们可以这样啦实现CarManager.execute方法：\n\nCarManager.execute = function (command) {\n    return CarManager[command.request](command.model, command.carID);\n};\n//改造以后，调用就简单多了，如下调用都可以实现（当然有些异常细节还是需要再完善一下的）：\n\nCarManager.execute({ request: \"arrangeViewing\", model: 'Ferrari', carID: '145523' });\nCarManager.execute({ request: \"requestInfo\", model: 'Ford Mondeo', carID: '543434' });\nCarManager.execute({ request: \"requestInfo\", model: 'Ford Escort', carID: '543434' });\nCarManager.execute({ request: \"buyVehicle\", model: 'Ford Escort', carID: '543434' });\n```\n\n\n\n**设计模式的核心思想是不是都插入一个中间层，把业务集中到中间层去？**\n\n## 职责链模式\n\n### 定义\n\n职责连是由多个不同的对象组成的，有发送者跟接收者，分别负责信息的发送跟接收，其中，链中第一个对象是 职责连是由多个不同的对象组成的，发送者是发送请求的对象，接收者接收请求并且对其进行处理或传递的对象。基本流程如下：\n\n1. 发送者知道链中的第一个接收者，它向这个接收者发送该请求。\n2. 每一个接收者都对请求进行分析，然后要么处理它，要么它往下传递。\n3. 每一个接收者知道其他的对象只有一个，即它在链中的下家(successor)。\n4. 如果没有任何接收者处理请求，那么请求会从链中离开。\n\n职责链模式是个链式结构，请求在链中的节点之间依次传递，直到有一个对象能处理该请求为止。如果没有任何对象处理该请求的话，那么请求就会从链中离开\n\n### 事例代码\n\n>假设这么一个场景：\n>我们负责一个售卖手机的电商网站，经过分别缴纳500元定金和200元定金的两轮预定后，到了正式购买阶段。针对预定用户实行优惠，支付过500元定金的用户会收到100元的商城优惠券，支付过200元定金的用户会收到50元的商城优惠券，没有支付定金的用户归为普通购买，且在库存有限的情况下不一定保证买到。\n\n```\n/* 传统方式实现 */\n// orderType：[1:500, 2:200, 3:普通]，isPaid：true/false，stock：库存量\nvar order = function(orderType, isPaid, stock) {\n    if(orderType === 1) {\n        if(isPaid) {\n            console.log(\"500元定金预购，得到100优惠券\");\n        } else {\n            if(stock > 0) {\n                console.log(\"普通购买，无优惠券\");\n            }else {\n                console.log(\"库存不足\");\n            }\n        }\n    }else if(orderType === 2) {\n        if(isPaid) {\n            console.log(\"200元定金预购，得到50优惠券\");\n        } else {\n            if(stock > 0) {\n                console.log(\"普通购买，无优惠券\");\n            }else {\n                console.log(\"库存不足\");\n            }\n        }\n    }else if(orderType === 2) {\n        if(stock > 0) {\n            console.log(\"普通购买，无优惠券\");\n        }else {\n            console.log(\"库存不足\");\n        }\n    }\n}\n\norder(1, true, 500);\n\n/*职责链 */\nvar order500 = function(orderType, isPaid, stock) {\n    if(orderType === 1 && isPaid === true) {\n        console.log(\"500元定金预购，得到100优惠券\");\n    }else {\n        return \"nextSuccessor\";\n    }\n};\n\nvar order200 = function(orderType, isPaid, stock) {\n    if(orderType === 2 && isPaid === true) {\n        console.log(\"200元定金预购，得到50优惠券\");\n    }else {\n        return \"nextSuccessor\";\n    }\n};\n\nvar orderNormal = function(orderType, isPaid, stock) {\n    if(stock > 0) {\n        console.log(\"普通购买，无优惠券\");\n    }else {\n        console.log(\"库存不足\");\n    }\n};\n\nFunction.prototype.after = function(fn) {\n    var self = this;\n    return function() {\n        var ret = self.apply(this, arguments);\n        if(ret === \"nextSuccessor\") {\n            return fn.apply(this, arguments);\n        }\n        return ret;\n    };\n}\n\nvar order = order500.after(order200).after(orderNormal);\norder(1, true, 10);//结合AOP\n```\n\n\n\n### 延伸应用\n\n常见的做法其实是优惠卷的案例？\n\n## 策略模式\n\n### 定义\n\n定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。\n基于策略类模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，Context接收客户的请求，随后把请求委托给某一个策略类。\n\n### 事例\n\n```\nvar strategies = {\n    \"S\": function(salary) {\n        return salary * 4;\n    },\n    \"A\": function(salary) {\n        return salary * 3;\n    },\n    \"B\": function(salary) {\n        return salary * 2;\n    }\n};\n\n// 接收请求\nvar calculateBonus = function(level, salary) {\n    return strategies[level](salary);\n};\n\n// 测试\nconsole.log(calculateBonus(\"S\", 20000));\nconsole.log(calculateBonus(\"A\", 20000));\nconsole.log(calculateBonus(\"B\", 20000));\n```\n\n### 延伸应用\n\n常见的表单验证js,如：validator.js\n\n# 迭代器模式\n\n## 一句话总结：就是foreach\n\n##定义\n\n> 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n\n## 代码\n\n```js\nvar each = function(ary, callback) {\n    for(var i = 0, l = ary.length; i < l; i++) {\n        callback.call(ary[i], i, ary[i]);\n    }   \n};\neach([1, 2, 3], function(i, n) {\n    console.log(\"当前下标为：\"+ i + \" 当前元素为：\"+ n );\n});\n```\n\n\n\n##延伸应用\n\n文件上传，根据不同的浏览器获取相应的上传组件对象。(高阶用法，存疑)\n\n# 观察者模式\n\n## 一句话总结就是:就是vue里的emit/on\n\n## 定义\n\n> 观察者模式又叫做发布订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察着对象。 它是由两类对象组成，主题和观察者，主题负责发布事件，同时观察者通过订阅这些事件来观察该主体，发布者和订阅者是完全解耦的，彼此不知道对方的存在，两者仅仅共享一个自定义事件的名称。\n\n## 代码\n\n```\nvar p1 = new Pubsub();\n p1.on('mm', function (name) {\n     console.log('mm: '+ name);\n });\n p1.emit('mm','哈哈哈哈');\n```\n\n\n\n## 应用\n\nMQ\n\n# 状态模式\n\n## 一句话总结就是：有限状态机\n\n## 定义\n\n状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。\n\n## 代码\n\n```js\n// 关灯\nvar OffLightState = function(light) {\n    this.light = light;\n};\n// 弱光\nvar OffLightState = function(light) {\n    this.light = light;\n};\n// 强光\nvar StrongLightState = function(light) {\n    this.light = light;\n};\n\nvar Light = function(){\n    /* 开关状态 */\n    this.offLight = new OffLightState(this);\n    this.weakLight = new WeakLightState(this);\n    this.strongLight = new StrongLightState(this);\n    /* 快关按钮 */\n    this.button = null;\n};\nLight.prototype.init = function() {\n    var button = document.createElement(\"button\"),\n        self = this;\n    this.button = document.body.appendChild(button);\n    this.button.innerHTML = '开关';\n    this.currentState = this.offLight;\n    this.button.click = function() {\n        self.currentState.buttonWasPressed();\n    }\n};\n// 让抽象父类的抽象方法直接抛出一个异常（避免状态子类未实现buttonWasPressed方法）\nLight.prototype.buttonWasPressed = function() {\n    throw new Error(\"父类的buttonWasPressed方法必须被重写\");\n};\nLight.prototype.setState = function(newState) {\n    this.currentState = newState;\n};\n\n/* 关灯 */\nOffLightState.prototype = new Light();  // 继承抽象类\nOffLightState.prototype.buttonWasPressed = function() {\n    console.log(\"关灯！\");\n    this.light.setState(this.light.weakLight);\n}\n/* 弱光 */\nWeakLightState.prototype = new Light();\nWeakLightState.prototype.buttonWasPressed = function() {\n    console.log(\"弱光！\");\n    this.light.setState(this.light.strongLight);\n};\n/* 强光 */\nStrongLightState.prototype = new Light();\nStrongLightState.prototype.buttonWasPressed = function() {\n    console.log(\"强光！\");\n    this.light.setState(this.light.offLight);\n};\n```\n\n\n\n## 应用\n\n任意上层应用的状态显示\n\n# 备忘录模式\n\n##一句话总结就是：就是留个备份，出问题了就回滚\n\n## 定义\n\n暂无\n\n## 代码\n\n```js\n\nvar Page = function(){\n   var page = 1,\n      cache = {},\n      data;\n   return function( page ){\n      if ( cache[ page ] ){\n               data =  cache[ page ];\n               render( data );\n      }else{\n               Ajax.send( 'cgi.xx.com/xxx', function( data ){\n                   cache[ page ] = data;\n                   render( data );\n               })\n      }\n    }\n}()\n```\n\n## 应用\n\n操作回溯\n\n# 解释器模式\n\n##一句话总结就是：抽象语法树AST\n\n## 定义\n\n```\n如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n```\n\n##代码\n\n\n\n##应用\n\nSQL \n\n# 访问者模式\n\n## 一句话总结就是：我中有你 你中有我\n\n##定义\n\n访问者模式：针对于对象结构中的元素，定义在不改变对象的前提下访问结构中元素的方法\n\n在访问者模式中，主要包括下面几个角色\n\n1、抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。\n\n2、访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。\n\n3、抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。\n\n4、元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。\n\n5、结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。\n\n## 代码\n\n```\nfunction Visitor() {  \n  this.visit = function( concreteElement ) {  \n    concreteElement.doSomething();  \n  }  \n}  \n// 元素类  \nfunction ConceteElement() {  \n  this.doSomething = function() {  \n    console.log(\"这是一个具体元素\");  \n  }  \n  this.accept = function( visitor ) {  \n    visitor.visit(this);  \n  }  \n} \n// Client  \nvar ele = new ConceteElement();  \nvar v = new Visitor();  \nele.accept( v );  \n```\n\n\n\n## 应用\n\n无\n\n# 适配器模式\n\n##一句话就是：不同类型的数据线的转接器\n\n## 定义 \n\n将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。\n\n## 代码\n\n```\nfunction PhoneUSBTypecToMicroUSB(Phone) {\n  var _USBTypec = new ChargingCord('USBTypec');\n  var _MicroUSB = new ChargingCord('MicroUSB');\n  if (_USBTypec.check(Phone.getChargingCord())) {\n    Phone.charging = function () {\n      console.log(this.getName());\n      _USBTypec.work();\n      console.log('转接');\n      _MicroUSB.work();\n      console.log('接收');\n    }\n    Phone.getChargingCord = function () {\n      return _MicroUSB;\n    };\n    return Phone;\n  }\n  else {\n    console.log('接口不对无法转换');\n  }\n}\n\nfunction PhoneMicroUSBToUSBTypec(Phone) {\n  var _USBTypec = new ChargingCord('USBTypec');\n  var _MicroUSB = new ChargingCord('MicroUSB');\n  if (_MicroUSB.check(Phone.getChargingCord())) {\n    Phone.charging = function () {\n      console.log(this.getName());\n      _MicroUSB.work();\n      console.log('转接');\n      _USBTypec.work();\n      console.log('接收');\n    }\n    Phone.getChargingCord = function () {\n      return _USBTypec;\n    };\n    return Phone;\n  }\n  else {\n    console.log('接口不对无法转换');\n  }\n}\n\nfunction PhoneDeleteInterface(Phone){\n  delete Phone.charging;\n  delete Phone.getChargingCord;\n  return Phone;\n}\n```\n\n\n\n## 应用\n\n在不动应用层的情况下，切换底层、\n\n# 桥接模式\n\n## 一句话就是 中间夹了一个类\n\n## 定义\n\n用桥接模式联结多个类\n\n## 代码\n\n```\nvar Class1 =function(a,b,c){\n\tthis.a =a;\n\tthis.b = b;\n\tthis.c = c;\n}\nvar Class2 =function(d){\n\tthis.d = d;\n}\nvar BridgeClass =function(a,b,c,d){\n\t   this.one = new Class1(a,b,c);\n\t   this.two = new Class2(d);\n}\n```\n\n\n\n## 应用\n\n暂无\n\n# 组合模式\n\n## 一句话定义：树状结构，且行为递归执行\n\n##定义\n\n部分-整体模式，它将所有对象组合成树形结构。使得用户只需要操作最上层的接口，就可以对所有成员做相同的操作。\n\n## 代码\n\n```\n$( 'body' ).unbind( '*' );//触发所有的dom解绑定事件\n```\n\n\n\n## 应用\n\njqdom对象\n\n# 装饰模式\n\n## 一句话总结：珍珠奶茶\n\n## 定义\n\n** 装饰者(decorator) **模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。\n\n## 代码\n\n>\n\n```\nvar Plan1 = {\n    fire: function () {\n        console.log('发射普通的子弹');\n    }\n};\n\nvar missileDecorator= function () {\n    console.log('发射导弹!');\n};\n\nvar fire = Plan1.fire;\n\nPlan1.fire=function () {\n    fire();\n    missileDecorator();\n};\n\nPlan1.fire();\n```\n\n## 应用\n\nAOP\n\n# 外观模式\n\n## 一句话总结就是:减少外部需要记忆的api\n\n## 定义\n\n外观模式提供一个高层接口，这个接口使得客户端或子系统更加方便调用。\n\n## 代码\n\n> var getName = function(){\n>\n>   return ''svenzeng\"\n>\n> }\n>\n> var getSex = function(){\n>\n>    return 'man'\n>\n> }\n>\n> var getUserInfo = function(){\n>\n>   var info = a() + b();\n>\n>   return info;\n>\n> }\n\n## 应用\n\n快餐\n\n# 享元模式\n\n## 一句话总结就是：虚拟列表，只创建你看得见的dom\n\n## 定义\n\n提供一些共享的对象以便重复利用. \n\n## 代码\n\n```\n var getDiv = (function(){\n    var created = [];\n    var create = function(){\n          return document.body.appendChild( document.createElement( 'div' ) );\n    }\n    var get = function(){\n         if ( created.length ){\n              return created.shift();\n          }else{\n                return create();\n           }\n     }\n/* 一个假设的事件，用来监听刚消失在视线外的div，实际上可以通过监听滚                                     动条位置来实现 */\n      userInfoContainer.disappear(function( div ){\n              created.push( div );\n        })\n })()\n  var div = getDiv();\n  div.innerHTML = \"${userinfo}\";\n```\n\n\n\n##应用\n\n虚拟列表，只创建你看得见的dom\n\n# 代理模式\n\n## 一句话就是：代理人先整理需求\n\n## 定义\n\n代理模式的定义是把对一个对象的访问, 交给另一个代理对象来操作.\n\n## 代码\n\n```\nvar request = proxy.get( 'cgi.xx.com/xxx' );\n \nrequest.send();\n \nrequest.done(function(){\n \n});\n```\n\n\n\n## 应用\n\n实际的编程中， 这种因为性能问题使用代理模式的机会是非常多的。比如频繁的访问dom节点, 频繁的请求远程资源. 可以把操作先存到一个缓冲区, 然后自己选择真正的触发时机.\n\n","slug":"设计模式","published":1,"date":"2020-10-10T05:21:37.320Z","updated":"2020-10-10T05:38:28.791Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckg39jbn700068ovphyslah1v","content":"<h1 id=\"六大原则\"><a href=\"#六大原则\" class=\"headerlink\" title=\"六大原则\"></a>六大原则</h1><p>1.单一职责原则:只做一件事情<br>2.里氏替换原则:同岗位人之间可以互相调换<br>3.依赖倒转原则:应用层依赖底层，但是底层不依赖应用层<br>4.接口隔离原则:模块只声明自己需要的接口<br>5.迪米特法则:在你眼里，我应该是黑盒。<br>6.开闭原则:你只能看，不能改</p>\n<ol>\n<li>开闭原则： 对扩展开放，对修改关闭</li>\n<li>里氏转换原则： 子类继承父类，单独完全可以运行</li>\n<li>依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型</li>\n<li>接口隔离原则： 每一个接口应该是一种角色</li>\n<li>合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分</li>\n<li>迪米特原则： 一个对象应对其他对象有尽可能少的了解</li>\n</ol>\n<blockquote>\n<p>我会在下面设计的模式中，声明使用到对应的原则</p>\n</blockquote>\n<h1 id=\"为什么要尽量使用白话\"><a href=\"#为什么要尽量使用白话\" class=\"headerlink\" title=\"为什么要尽量使用白话\"></a>为什么要尽量使用白话</h1><blockquote>\n<p>纯术语的文章太多，不利于归纳成记忆点，尤其是实际应用中。所以我尝试着能否使用白话或者极度精简的文字去分解这些复杂侃长的语句。</p>\n</blockquote>\n<h1 id=\"为什么要使用设计模式\"><a href=\"#为什么要使用设计模式\" class=\"headerlink\" title=\"为什么要使用设计模式\"></a>为什么要使用设计模式</h1><blockquote>\n<p>开发人员A碰到了一个问题，就找开发B,开发B说用”xxxx设计模式就行了”，如果这个时候开发A不懂设计模式，那他们就无法交流了。就如同我们在汉语里使用成语一样，当你在交流中使用一个成语的时候，是不会去讲述这个成语背后的故事的。因此，一个合格的开发人员，必须掌握设计模式这个“标准词汇”<br>但是过度复杂化的设计模式也不可取，保持一个代码与模式的平衡是一个非常重要的事情。</p>\n<a id=\"more\"></a> \n</blockquote>\n<p>本质：将软件中变化的部分和不变的部分分开</p>\n<h1 id=\"设计模式的类型\"><a href=\"#设计模式的类型\" class=\"headerlink\" title=\"设计模式的类型\"></a>设计模式的类型</h1><h1 id=\"1．创建型模式\"><a href=\"#1．创建型模式\" class=\"headerlink\" title=\"1．创建型模式\"></a>1．创建型模式</h1><p>创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关系创建对象过程中的逻辑。</p>\n<p>社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：</p>\n<ul>\n<li>简单工厂模式（Simple Factory）</li>\n<li>工厂方法模式（Factory Method）</li>\n<li>抽象工厂模式（Abstract Factory）</li>\n<li>创建者模式（Builder）</li>\n<li>原型模式（Prototype）</li>\n<li>单例模式（Singleton）</li>\n</ul>\n<blockquote>\n<p>简单工厂模式不是GoF总结出来的23种设计模式之一</p>\n</blockquote>\n<h1 id=\"2．结构型模式\"><a href=\"#2．结构型模式\" class=\"headerlink\" title=\"2．结构型模式\"></a>2．结构型模式</h1><p>结构型模式是为解决怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）。</p>\n<p>在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：</p>\n<ul>\n<li>外观模式/门面模式（Facade门面模式）</li>\n<li>适配器模式（Adapter）</li>\n<li>代理模式（Proxy）</li>\n<li>装饰模式（Decorator）</li>\n<li>桥梁模式/桥接模式（Bridge）</li>\n<li>组合模式（Composite）</li>\n<li>享元模式（Flyweight）</li>\n</ul>\n<h1 id=\"3．行为型模式\"><a href=\"#3．行为型模式\" class=\"headerlink\" title=\"3．行为型模式\"></a>3．行为型模式</h1><p>行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式。1. 行为类模式使用继承机制在类间分派行为。2. 行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。</p>\n<p>在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：</p>\n<ul>\n<li>模板方法模式（Template Method）</li>\n<li>观察者模式（Observer）</li>\n<li>状态模式（State）</li>\n<li>策略模式（Strategy）</li>\n<li>职责链模式（Chain of Responsibility）</li>\n<li>命令模式（Command）</li>\n<li>访问者模式（Visitor）</li>\n<li>调停者模式（Mediator）</li>\n<li>备忘录模式（Memento）</li>\n<li>迭代器模式（Iterator）</li>\n<li>解释器模式（Interpreter）</li>\n</ul>\n<h2 id=\"三者之间的区别和联系\"><a href=\"#三者之间的区别和联系\" class=\"headerlink\" title=\"三者之间的区别和联系\"></a>三者之间的区别和联系</h2><blockquote>\n<p>创建型模式提供生存环境，结构型模式提供生存理由，行为型模式提供如何生存。</p>\n</blockquote>\n<ol>\n<li>创建型模式为其他两种模式使用提供了环境。</li>\n<li>结构型模式侧重于接口的使用，它做的一切工作都是对象或是类之间的交互，提供一个门。</li>\n<li>行为型模式顾名思义，侧重于具体行为，所以概念中才会出现职责分配和算法通信等内容。</li>\n</ol>\n<h1 id=\"五大创建型模式\"><a href=\"#五大创建型模式\" class=\"headerlink\" title=\"五大创建型模式\"></a>五大创建型模式</h1><blockquote>\n<p>关于创造型模式</p>\n</blockquote>\n<h2 id=\"单例模式-Singleton-Pattern\"><a href=\"#单例模式-Singleton-Pattern\" class=\"headerlink\" title=\"单例模式(Singleton Pattern)\"></a>单例模式(Singleton Pattern)</h2><p>###一句话总结：虽然我有很多网名，但是全世界就一个我</p>\n<p>###代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Menu() &#123;</span><br><span class=\"line\">    // 判断是否存在实例</span><br><span class=\"line\">    if (typeof Universe.instance === &apos;object&apos;) &#123;</span><br><span class=\"line\">        return Universe.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 其它内容</span><br><span class=\"line\">    this.food =[&quot;hanbao&quot;,&quot;kele&quot;];</span><br><span class=\"line\">    // 缓存</span><br><span class=\"line\">    Menu.instance = this;</span><br><span class=\"line\">    // 隐式返回this</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 测试</span><br><span class=\"line\">var zhizhi = new Menu();</span><br><span class=\"line\">var qiantai=new Menu();</span><br><span class=\"line\">console.log(uni === uni2); // true</span><br></pre></td></tr></table></figure>\n\n<p>###定义</p>\n<blockquote>\n<p>保证系统内部只有唯一一个对应的实例对象，又细分为最开始就实例化（简单粗暴），和第一次使用的时候实例化（可能需要额外的代码来实现这块功能）</p>\n<p>单例模式在<a href=\"https://zh.wikipedia.org/wiki/线程\" target=\"_blank\" rel=\"noopener\">多线程</a>的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>\n<p>通常单例模式在<a href=\"https://zh.wikipedia.org/wiki/Java语言\" target=\"_blank\" rel=\"noopener\">Java语言</a>中，有两种构建方式：</p>\n<ul>\n<li>懒汉方式。指全局的单例实例在第一次被使用时构建。</li>\n<li>饿汉方式。指全局的单例实例在类装载时构建。</li>\n</ul>\n</blockquote>\n<p>###应用</p>\n<ul>\n<li>就像KFC中的菜单，不管你在app还是前天，或者纸质菜单上查看，永远只有一份实例。</li>\n</ul>\n<h2 id=\"简单工厂模式-Simple-Factory\"><a href=\"#简单工厂模式-Simple-Factory\" class=\"headerlink\" title=\"简单工厂模式(Simple Factory)\"></a>简单工厂模式(Simple Factory)</h2><h2 id=\"一句话就是-自动奶茶机\"><a href=\"#一句话就是-自动奶茶机\" class=\"headerlink\" title=\"一句话就是 自动奶茶机\"></a>一句话就是 自动奶茶机</h2><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var request1 = ajax(&apos;cgi.xx.com/xxx&apos; , &apos;&apos;get&apos; );</span><br><span class=\"line\"> </span><br><span class=\"line\">request1.start();</span><br><span class=\"line\"> </span><br><span class=\"line\">request1.done( fn );</span><br><span class=\"line\"> </span><br><span class=\"line\">var request2 = ajax(&apos;cgi.xx.com/xxx&apos; , &apos;&apos;jsonp&apos; );</span><br><span class=\"line\"> </span><br><span class=\"line\">request2.start();</span><br><span class=\"line\"> </span><br><span class=\"line\">request2.done( fn );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况.说的通俗点，就像公司茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。</p>\n<p>你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。</p>\n<p>缺点也很明显，所有逻辑都封装在工厂类呢，但是根据场景使用 还是会很优雅。属于基础的设计模式</p>\n</blockquote>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>KFC饮料机器</p>\n<h2 id=\"抽象工厂-Abstract-Factory\"><a href=\"#抽象工厂-Abstract-Factory\" class=\"headerlink\" title=\"抽象工厂(Abstract Factory)\"></a>抽象工厂(Abstract Factory)</h2><h3 id=\"一句话-interface\"><a href=\"#一句话-interface\" class=\"headerlink\" title=\"一句话 interface\"></a>一句话 interface</h3><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>就是通过类的抽象使得业务适用于一个产品类簇的创建，而不负责某一类产品的实例。</p>\n<p>JS中是没有直接的抽象类的，abstract是个保留字，但是还没有实现，因此我们需要在类的方法中抛出错误来模拟抽象类，如果继承的子类中没有覆写该方法而调用，就会抛出错误。</p>\n<p>工厂是一个抽象类，它不能够直接被实例化，工厂的作用是制定产品族类的结构。土一点的理解方式就是，interface。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 实现subType类对工厂类中的superType类型的抽象类的继承</span><br><span class=\"line\">* @param subType 要继承的类</span><br><span class=\"line\">* @param superType 工厂类中的抽象类type</span><br><span class=\"line\">*/</span><br><span class=\"line\">const VehicleFactory = function(subType, superType) &#123;</span><br><span class=\"line\">  if (typeof VehicleFactory[superType] === &apos;function&apos;) &#123;</span><br><span class=\"line\">    function F() &#123;</span><br><span class=\"line\">      this.type = &apos;车辆&apos;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    F.prototype = new VehicleFactory[superType]()</span><br><span class=\"line\">    subType.constructor = subType</span><br><span class=\"line\">    subType.prototype = new F()                // 因为子类subType不仅需要继承superType对应的类的原型方法，还要继承其对象属性</span><br><span class=\"line\">  &#125; else throw new Error(&apos;不存在该抽象类&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">VehicleFactory.Car = function() &#123;</span><br><span class=\"line\">  this.type = &apos;car&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VehicleFactory.Car.prototype = &#123;</span><br><span class=\"line\">  getPrice: function() &#123;</span><br><span class=\"line\">    return new Error(&apos;抽象方法不可使用&apos;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getSpeed: function() &#123;</span><br><span class=\"line\">    return new Error(&apos;抽象方法不可使用&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const BMW = function(price, speed) &#123;</span><br><span class=\"line\">  this.price = price</span><br><span class=\"line\">  this.speed = speed</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VehicleFactory(BMW, &apos;Car&apos;)        // 继承Car抽象类</span><br><span class=\"line\">BMW.prototype.getPrice = function() &#123;        // 覆写getPrice方法</span><br><span class=\"line\">  console.log(`BWM price is $&#123;this.price&#125;`)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BMW.prototype.getSpeed = function() &#123;</span><br><span class=\"line\">  console.log(`BWM speed is $&#123;this.speed&#125;`)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const baomai5 = new BMW(30, 99)</span><br><span class=\"line\">baomai5.getPrice()                          // BWM price is 30</span><br><span class=\"line\">baomai5 instanceof VehicleFactory.Car</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>KFC汉堡类型：面包片+调料+肉+蔬菜+面包片</p>\n<h2 id=\"建造者模式（Builder-Pattern）\"><a href=\"#建造者模式（Builder-Pattern）\" class=\"headerlink\" title=\"建造者模式（Builder Pattern）\"></a>建造者模式（Builder Pattern）</h2><p>###一句话总结</p>\n<h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h3 id=\"应用-2\"><a href=\"#应用-2\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>1.简述：将一个复杂对象的–构建–与它的表示分离，使得同样的构建过程可以创建.一步步构造一个复杂对象，返回一个完整的对象``<br>2.代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// #建造者模式</span><br></pre></td></tr></table></figure>\n\n<p>// 抽象建造者<br>var Car = function (param) {<br>    // 速度<br>    this.speed = param &amp;&amp; param.speed || ‘0’;<br>    // 重量<br>    this.weight = param &amp;&amp; param.weight || ‘0’;<br>}</p>\n<p>Car.prototype = {<br>    // 获取速度<br>    getSpeed: function () {<br>        return this.speed;<br>    },<br>    // 获取重量<br>    getWeight: function () {<br>        return this.weight<br>    }<br>}</p>\n<p>// 轮胎部件类<br>var Tyre = function (type) {<br>    var that = this;<br>    // 构造器<br>    // 构造函数中通过传入的type类型设置相对应的轮胎尺寸<br>    (function (type,that) {<br>        switch (type) {<br>            case ‘small’:<br>            that.tyre = ‘小号轮胎’;<br>            that.tyreIntro = ‘正在使用小号轮胎’;<br>            break;<br>            case ‘normal’:<br>            that.tyre = ‘中号轮胎’;<br>            that.tyreIntro = ‘正在使用中号轮胎’;<br>            break;<br>            case ‘big’:<br>            that.tyre = ‘大号轮胎’;<br>            that.tyreIntro = ‘正在使用大号轮胎’;<br>            break;<br>        }<br>    })(type,this);<br>}</p>\n<p>Tyre.prototype = {<br>    // 更换轮胎的方法<br>    changeType: function (type) {<br>        that.tyre = type;<br>        that.tyreIntro = ‘正在使用’+type;<br>    }<br>}</p>\n<p>// 发动机部件类<br>var Engine = function (type) {<br>    var that = this;<br>    // 构造器<br>    // 构造函数中通过传入的type类型设置相对应的发动机类型<br>    (function (type,that) {<br>        switch (type) {<br>            case ‘small’:<br>            that.engine = ‘小号发动机’;<br>            that.engineIntro = ‘正在使用小号发动机’;<br>            break;<br>            case ‘normal’:<br>            that.engine = ‘中号发动机’;<br>            that.engineIntro = ‘正在使用中号发动机’;<br>            break;<br>            case ‘big’:<br>            that.engine = ‘大号发动机’;<br>            that.engineIntro = ‘正在使用大号发动机’;<br>            break;<br>        }<br>    })(type,this);<br>}</p>\n<p>Engine.prototype = {<br>    // 更换发动机的方法<br>    changeType: function (type) {<br>        that.engine = type;<br>        that.engineIntro = ‘正在使用’+type;<br>    }<br>}</p>\n<p>/**</p>\n<ul>\n<li>指挥者,建造一个奔驰车的类</li>\n<li>@param {*轮胎类型 small normal big} tyre </li>\n<li>@param {*发动机类型 small normal big} engine </li>\n<li>@param {*车辆基本属性 param.speed:速度 param.weight: 重量} param </li>\n<li>/<br>var BenChi = function (tyre,engine,param) {<br>  // 创建一个车辆缓存对象<br>  var _car = new Car(param);ckplayer 隐藏控制<br>  // 创建车辆的轮胎<br>  _car.tyreInfo = new Tyre(tyre);<br>  // 创建车辆的发动机<br>  _car.engineInfo = new Engine(engine);<br>  // 将创建的车辆对象返回<br>  return _car;<br>}</li>\n</ul>\n<p>// 具体建造者 实例化奔驰车类<br>var benchi1 = new BenChi(‘small’,’big’,{speed: 200,weight: ‘200’});<br>console.log(benchi1.speed);// 200<br>console.log(benchi1.weight);// 200<br>console.log(benchi1.tyreInfo.tyre);// 小号轮胎<br>console.log(benchi1.tyreInfo.tyreIntro);// 正在使用小号轮胎<br>console.log(benchi1.engineInfo.engine);// 大号发动机<br>console.log(benchi1.engineInfo.engineIntro);// 正在使用大号发动机<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3.优点:每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</span><br><span class=\"line\">4.缺点</span><br><span class=\"line\">5.白话总结:建造者模式主要用于“分布构建一个复杂的对象”</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h2><p>减少new，使用create直接创建对象。</p>\n<h1 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h1><h2 id=\"模版方式\"><a href=\"#模版方式\" class=\"headerlink\" title=\"模版方式\"></a>模版方式</h2><blockquote>\n<p>类似管控的视频模块，应该要使用这个模式,就是预设好具体的口子给继承方使用。</p>\n<p>1.抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。</p>\n<p>2.模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。</p>\n<p>3.钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。</p>\n</blockquote>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 抽象父类：饮料 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Beverage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// (1) 把水煮沸</span></span><br><span class=\"line\">Beverage.prototype.boilWater = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"把水煮沸\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// (2) 沸水浸泡</span></span><br><span class=\"line\">Beverage.prototype.brew = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"子类必须重写brew方法\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// (3) 倒进杯子</span></span><br><span class=\"line\">Beverage.prototype.pourInCup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"子类必须重写pourInCup方法\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// (4) 加调料</span></span><br><span class=\"line\">Beverage.prototype.addCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"子类必须重写addCondiments方法\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 模板方法 */</span></span><br><span class=\"line\">Beverage.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.boilWater();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.brew();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pourInCup();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addCondiments();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现子类 Coffee*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Coffee = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Coffee.prototype = <span class=\"keyword\">new</span> Beverage();</span><br><span class=\"line\"><span class=\"comment\">// 重写非公有方法</span></span><br><span class=\"line\">Coffee.prototype.brew = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"用沸水冲泡咖啡\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Coffee.prototype.pourInCup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"把咖啡倒进杯子\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Coffee.prototype.addCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"加牛奶\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffee = <span class=\"keyword\">new</span> Coffee();</span><br><span class=\"line\">coffee.init();</span><br></pre></td></tr></table></figure>\n\n<p>通过模板方法模式，在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用大多数子类的，但也会出现“个性”子类。<br>如上述流程，加调料是可选的。<br>钩子方法可以解决这个问题，放置钩子是隔离变化的一种常见手段。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 添加钩子方法 */</span></span><br><span class=\"line\">Beverage.prototype.customerWantsCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Beverage.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.boilWater();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.brew();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pourInCup();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.customerWantsCondiments()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.addCondiments();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现子类 Tea*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Tea = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Tea.prototype = <span class=\"keyword\">new</span> Beverage();</span><br><span class=\"line\"><span class=\"comment\">// 重写非公有方法</span></span><br><span class=\"line\">Tea.prototype.brew = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"用沸水冲泡茶\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Tea.prototype.pourInCup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"把茶倒进杯子\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Tea.prototype.addCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"加牛奶\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Tea.prototype.customerWantsCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.confirm(<span class=\"string\">\"需要添加调料吗？\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> tea = <span class=\"keyword\">new</span> Tea();</span><br><span class=\"line\">tea.init();</span><br></pre></td></tr></table></figure>\n\n<p>JavaScript没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。</p>\n<h2 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h2><blockquote>\n<p>面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性。但由于这些细粒度对象之间的联系激增，又可能反过来降低它们的可复用性。<br>中介者模式的作用就是解除对象与对象之间的紧耦合关系。</p>\n<p>之前卓锐的路网系统就是这样开发，但是和观察者好像有点雷同。查阅资料以后发现：</p>\n<p><strong>中介者(mediator)强调的是同事(colleague)类之间的交互</strong></p>\n<p><strong>而观察者(observer)中的目标类(subject)强调是目标改变后对观察者进行统一的通讯</strong></p>\n<p><strong>两者非常相同的一点就是:中介者需要持有并且知道所有的同事类,而目标类也必须持有所有的目标类,但是是一目标类的接口引用方式持有,所以说目标类是不知道观察者的,所有的观察者都是一样的</strong></p>\n<p>其实从名称考虑，确实相当于是房产中介在租房和房东之间的关系。</p>\n</blockquote>\n<h2 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h2><blockquote>\n<p>命令模式比较容易设计一个命令队列( 容易AOP)，在需求的情况下比较容易将命令计入日志，并且允许接受请求的一方决定是否需要调用，而且可以实现对请求的撤销和重设，而且由于新增的具体类不影响其他的类，所以很容易实现。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> CarManager = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 请求信息</span></span><br><span class=\"line\">        requestInfo: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">model, id</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'The information for '</span> + model +</span><br><span class=\"line\">        <span class=\"string\">' with ID '</span> + id + <span class=\"string\">' is foobar'</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 购买汽车</span></span><br><span class=\"line\">        buyVehicle: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">model, id</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'You have successfully purchased Item '</span></span><br><span class=\"line\">        + id + <span class=\"string\">', a '</span> + model;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 组织view</span></span><br><span class=\"line\">        arrangeViewing: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">model, id</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'You have successfully booked a viewing of '</span></span><br><span class=\"line\">        + model + <span class=\"string\">' ( '</span> + id + <span class=\"string\">' ) '</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">//来看一下上述代码，通过调用函数来简单执行manager的命令，然而在一些情况下，我们并不想直接调用对象内部的方法。这样会增加对象与对象间的依赖。现在我们来扩展一下这个CarManager 使其能够接受任何来自包括model和car ID 的CarManager对象的处理请求。根据命令模式的定义，我们希望实现如下这种功能的调用：</span></span><br><span class=\"line\"></span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">commandType</span>: <span class=\"string\">\"buyVehicle\"</span>, <span class=\"attr\">operand1</span>: <span class=\"string\">'Ford Escort'</span>, <span class=\"attr\">operand2</span>: <span class=\"string\">'453543'</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">//根据这样的需求，我们可以这样啦实现CarManager.execute方法：</span></span><br><span class=\"line\"></span><br><span class=\"line\">CarManager.execute = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">command</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CarManager[command.request](command.model, command.carID);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//改造以后，调用就简单多了，如下调用都可以实现（当然有些异常细节还是需要再完善一下的）：</span></span><br><span class=\"line\"></span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">request</span>: <span class=\"string\">\"arrangeViewing\"</span>, <span class=\"attr\">model</span>: <span class=\"string\">'Ferrari'</span>, <span class=\"attr\">carID</span>: <span class=\"string\">'145523'</span> &#125;);</span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">request</span>: <span class=\"string\">\"requestInfo\"</span>, <span class=\"attr\">model</span>: <span class=\"string\">'Ford Mondeo'</span>, <span class=\"attr\">carID</span>: <span class=\"string\">'543434'</span> &#125;);</span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">request</span>: <span class=\"string\">\"requestInfo\"</span>, <span class=\"attr\">model</span>: <span class=\"string\">'Ford Escort'</span>, <span class=\"attr\">carID</span>: <span class=\"string\">'543434'</span> &#125;);</span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">request</span>: <span class=\"string\">\"buyVehicle\"</span>, <span class=\"attr\">model</span>: <span class=\"string\">'Ford Escort'</span>, <span class=\"attr\">carID</span>: <span class=\"string\">'543434'</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>设计模式的核心思想是不是都插入一个中间层，把业务集中到中间层去？</strong></p>\n<h2 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h2><h3 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>职责连是由多个不同的对象组成的，有发送者跟接收者，分别负责信息的发送跟接收，其中，链中第一个对象是 职责连是由多个不同的对象组成的，发送者是发送请求的对象，接收者接收请求并且对其进行处理或传递的对象。基本流程如下：</p>\n<ol>\n<li>发送者知道链中的第一个接收者，它向这个接收者发送该请求。</li>\n<li>每一个接收者都对请求进行分析，然后要么处理它，要么它往下传递。</li>\n<li>每一个接收者知道其他的对象只有一个，即它在链中的下家(successor)。</li>\n<li>如果没有任何接收者处理请求，那么请求会从链中离开。</li>\n</ol>\n<p>职责链模式是个链式结构，请求在链中的节点之间依次传递，直到有一个对象能处理该请求为止。如果没有任何对象处理该请求的话，那么请求就会从链中离开</p>\n<h3 id=\"事例代码\"><a href=\"#事例代码\" class=\"headerlink\" title=\"事例代码\"></a>事例代码</h3><blockquote>\n<p>假设这么一个场景：<br>我们负责一个售卖手机的电商网站，经过分别缴纳500元定金和200元定金的两轮预定后，到了正式购买阶段。针对预定用户实行优惠，支付过500元定金的用户会收到100元的商城优惠券，支付过200元定金的用户会收到50元的商城优惠券，没有支付定金的用户归为普通购买，且在库存有限的情况下不一定保证买到。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 传统方式实现 */</span><br><span class=\"line\">// orderType：[1:500, 2:200, 3:普通]，isPaid：true/false，stock：库存量</span><br><span class=\"line\">var order = function(orderType, isPaid, stock) &#123;</span><br><span class=\"line\">    if(orderType === 1) &#123;</span><br><span class=\"line\">        if(isPaid) &#123;</span><br><span class=\"line\">            console.log(&quot;500元定金预购，得到100优惠券&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if(stock &gt; 0) &#123;</span><br><span class=\"line\">                console.log(&quot;普通购买，无优惠券&quot;);</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                console.log(&quot;库存不足&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else if(orderType === 2) &#123;</span><br><span class=\"line\">        if(isPaid) &#123;</span><br><span class=\"line\">            console.log(&quot;200元定金预购，得到50优惠券&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if(stock &gt; 0) &#123;</span><br><span class=\"line\">                console.log(&quot;普通购买，无优惠券&quot;);</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                console.log(&quot;库存不足&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else if(orderType === 2) &#123;</span><br><span class=\"line\">        if(stock &gt; 0) &#123;</span><br><span class=\"line\">            console.log(&quot;普通购买，无优惠券&quot;);</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            console.log(&quot;库存不足&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">order(1, true, 500);</span><br><span class=\"line\"></span><br><span class=\"line\">/*职责链 */</span><br><span class=\"line\">var order500 = function(orderType, isPaid, stock) &#123;</span><br><span class=\"line\">    if(orderType === 1 &amp;&amp; isPaid === true) &#123;</span><br><span class=\"line\">        console.log(&quot;500元定金预购，得到100优惠券&quot;);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        return &quot;nextSuccessor&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var order200 = function(orderType, isPaid, stock) &#123;</span><br><span class=\"line\">    if(orderType === 2 &amp;&amp; isPaid === true) &#123;</span><br><span class=\"line\">        console.log(&quot;200元定金预购，得到50优惠券&quot;);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        return &quot;nextSuccessor&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var orderNormal = function(orderType, isPaid, stock) &#123;</span><br><span class=\"line\">    if(stock &gt; 0) &#123;</span><br><span class=\"line\">        console.log(&quot;普通购买，无优惠券&quot;);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        console.log(&quot;库存不足&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.after = function(fn) &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        var ret = self.apply(this, arguments);</span><br><span class=\"line\">        if(ret === &quot;nextSuccessor&quot;) &#123;</span><br><span class=\"line\">            return fn.apply(this, arguments);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var order = order500.after(order200).after(orderNormal);</span><br><span class=\"line\">order(1, true, 10);//结合AOP</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延伸应用\"><a href=\"#延伸应用\" class=\"headerlink\" title=\"延伸应用\"></a>延伸应用</h3><p>常见的做法其实是优惠卷的案例？</p>\n<h2 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><h3 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。<br>基于策略类模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，Context接收客户的请求，随后把请求委托给某一个策略类。</p>\n<h3 id=\"事例\"><a href=\"#事例\" class=\"headerlink\" title=\"事例\"></a>事例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var strategies = &#123;</span><br><span class=\"line\">    &quot;S&quot;: function(salary) &#123;</span><br><span class=\"line\">        return salary * 4;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;A&quot;: function(salary) &#123;</span><br><span class=\"line\">        return salary * 3;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;B&quot;: function(salary) &#123;</span><br><span class=\"line\">        return salary * 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收请求</span><br><span class=\"line\">var calculateBonus = function(level, salary) &#123;</span><br><span class=\"line\">    return strategies[level](salary);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 测试</span><br><span class=\"line\">console.log(calculateBonus(&quot;S&quot;, 20000));</span><br><span class=\"line\">console.log(calculateBonus(&quot;A&quot;, 20000));</span><br><span class=\"line\">console.log(calculateBonus(&quot;B&quot;, 20000));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延伸应用-1\"><a href=\"#延伸应用-1\" class=\"headerlink\" title=\"延伸应用\"></a>延伸应用</h3><p>常见的表单验证js,如：validator.js</p>\n<h1 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h1><h2 id=\"一句话总结：就是foreach\"><a href=\"#一句话总结：就是foreach\" class=\"headerlink\" title=\"一句话总结：就是foreach\"></a>一句话总结：就是foreach</h2><p>##定义</p>\n<blockquote>\n<p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>\n</blockquote>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> each = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ary, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = ary.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        callback.call(ary[i], i, ary[i]);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">each([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"当前下标为：\"</span>+ i + <span class=\"string\">\" 当前元素为：\"</span>+ n );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>##延伸应用</p>\n<p>文件上传，根据不同的浏览器获取相应的上传组件对象。(高阶用法，存疑)</p>\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><h2 id=\"一句话总结就是-就是vue里的emit-on\"><a href=\"#一句话总结就是-就是vue里的emit-on\" class=\"headerlink\" title=\"一句话总结就是:就是vue里的emit/on\"></a>一句话总结就是:就是vue里的emit/on</h2><h2 id=\"定义-5\"><a href=\"#定义-5\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>观察者模式又叫做发布订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察着对象。 它是由两类对象组成，主题和观察者，主题负责发布事件，同时观察者通过订阅这些事件来观察该主体，发布者和订阅者是完全解耦的，彼此不知道对方的存在，两者仅仅共享一个自定义事件的名称。</p>\n</blockquote>\n<h2 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = new Pubsub();</span><br><span class=\"line\"> p1.on(&apos;mm&apos;, function (name) &#123;</span><br><span class=\"line\">     console.log(&apos;mm: &apos;+ name);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> p1.emit(&apos;mm&apos;,&apos;哈哈哈哈&apos;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-3\"><a href=\"#应用-3\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>MQ</p>\n<h1 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h1><h2 id=\"一句话总结就是：有限状态机\"><a href=\"#一句话总结就是：有限状态机\" class=\"headerlink\" title=\"一句话总结就是：有限状态机\"></a>一句话总结就是：有限状态机</h2><h2 id=\"定义-6\"><a href=\"#定义-6\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。</p>\n<h2 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关灯</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> OffLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light = light;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 弱光</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> OffLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light = light;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 强光</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> StrongLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light = light;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Light = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 开关状态 */</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.offLight = <span class=\"keyword\">new</span> OffLightState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weakLight = <span class=\"keyword\">new</span> WeakLightState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strongLight = <span class=\"keyword\">new</span> StrongLightState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 快关按钮 */</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.button = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Light.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"button\"</span>),</span><br><span class=\"line\">        self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.button = <span class=\"built_in\">document</span>.body.appendChild(button);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.button.innerHTML = <span class=\"string\">'开关'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = <span class=\"keyword\">this</span>.offLight;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.button.click = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        self.currentState.buttonWasPressed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 让抽象父类的抽象方法直接抛出一个异常（避免状态子类未实现buttonWasPressed方法）</span></span><br><span class=\"line\">Light.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"父类的buttonWasPressed方法必须被重写\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Light.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newState</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = newState;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 关灯 */</span></span><br><span class=\"line\">OffLightState.prototype = <span class=\"keyword\">new</span> Light();  <span class=\"comment\">// 继承抽象类</span></span><br><span class=\"line\">OffLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"关灯！\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.weakLight);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 弱光 */</span></span><br><span class=\"line\">WeakLightState.prototype = <span class=\"keyword\">new</span> Light();</span><br><span class=\"line\">WeakLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"弱光！\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.strongLight);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/* 强光 */</span></span><br><span class=\"line\">StrongLightState.prototype = <span class=\"keyword\">new</span> Light();</span><br><span class=\"line\">StrongLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"强光！\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.offLight);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-4\"><a href=\"#应用-4\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>任意上层应用的状态显示</p>\n<h1 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h1><p>##一句话总结就是：就是留个备份，出问题了就回滚</p>\n<h2 id=\"定义-7\"><a href=\"#定义-7\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>暂无</p>\n<h2 id=\"代码-6\"><a href=\"#代码-6\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Page = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> page = <span class=\"number\">1</span>,</span><br><span class=\"line\">      cache = &#123;&#125;,</span><br><span class=\"line\">      data;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> page </span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( cache[ page ] )&#123;</span><br><span class=\"line\">               data =  cache[ page ];</span><br><span class=\"line\">               render( data );</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               Ajax.send( <span class=\"string\">'cgi.xx.com/xxx'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> data </span>)</span>&#123;</span><br><span class=\"line\">                   cache[ page ] = data;</span><br><span class=\"line\">                   render( data );</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-5\"><a href=\"#应用-5\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>操作回溯</p>\n<h1 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h1><p>##一句话总结就是：抽象语法树AST</p>\n<h2 id=\"定义-8\"><a href=\"#定义-8\" class=\"headerlink\" title=\"定义\"></a>定义</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</span><br></pre></td></tr></table></figure>\n\n<p>##代码</p>\n<p>##应用</p>\n<p>SQL </p>\n<h1 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h1><h2 id=\"一句话总结就是：我中有你-你中有我\"><a href=\"#一句话总结就是：我中有你-你中有我\" class=\"headerlink\" title=\"一句话总结就是：我中有你 你中有我\"></a>一句话总结就是：我中有你 你中有我</h2><p>##定义</p>\n<p>访问者模式：针对于对象结构中的元素，定义在不改变对象的前提下访问结构中元素的方法</p>\n<p>在访问者模式中，主要包括下面几个角色</p>\n<p>1、抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。</p>\n<p>2、访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。</p>\n<p>3、抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。</p>\n<p>4、元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。</p>\n<p>5、结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。</p>\n<h2 id=\"代码-7\"><a href=\"#代码-7\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Visitor() &#123;  </span><br><span class=\"line\">  this.visit = function( concreteElement ) &#123;  </span><br><span class=\"line\">    concreteElement.doSomething();  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">// 元素类  </span><br><span class=\"line\">function ConceteElement() &#123;  </span><br><span class=\"line\">  this.doSomething = function() &#123;  </span><br><span class=\"line\">    console.log(&quot;这是一个具体元素&quot;);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  this.accept = function( visitor ) &#123;  </span><br><span class=\"line\">    visitor.visit(this);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">// Client  </span><br><span class=\"line\">var ele = new ConceteElement();  </span><br><span class=\"line\">var v = new Visitor();  </span><br><span class=\"line\">ele.accept( v );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-6\"><a href=\"#应用-6\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>无</p>\n<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><p>##一句话就是：不同类型的数据线的转接器</p>\n<h2 id=\"定义-9\"><a href=\"#定义-9\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>\n<h2 id=\"代码-8\"><a href=\"#代码-8\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function PhoneUSBTypecToMicroUSB(Phone) &#123;</span><br><span class=\"line\">  var _USBTypec = new ChargingCord(&apos;USBTypec&apos;);</span><br><span class=\"line\">  var _MicroUSB = new ChargingCord(&apos;MicroUSB&apos;);</span><br><span class=\"line\">  if (_USBTypec.check(Phone.getChargingCord())) &#123;</span><br><span class=\"line\">    Phone.charging = function () &#123;</span><br><span class=\"line\">      console.log(this.getName());</span><br><span class=\"line\">      _USBTypec.work();</span><br><span class=\"line\">      console.log(&apos;转接&apos;);</span><br><span class=\"line\">      _MicroUSB.work();</span><br><span class=\"line\">      console.log(&apos;接收&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Phone.getChargingCord = function () &#123;</span><br><span class=\"line\">      return _MicroUSB;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return Phone;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else &#123;</span><br><span class=\"line\">    console.log(&apos;接口不对无法转换&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function PhoneMicroUSBToUSBTypec(Phone) &#123;</span><br><span class=\"line\">  var _USBTypec = new ChargingCord(&apos;USBTypec&apos;);</span><br><span class=\"line\">  var _MicroUSB = new ChargingCord(&apos;MicroUSB&apos;);</span><br><span class=\"line\">  if (_MicroUSB.check(Phone.getChargingCord())) &#123;</span><br><span class=\"line\">    Phone.charging = function () &#123;</span><br><span class=\"line\">      console.log(this.getName());</span><br><span class=\"line\">      _MicroUSB.work();</span><br><span class=\"line\">      console.log(&apos;转接&apos;);</span><br><span class=\"line\">      _USBTypec.work();</span><br><span class=\"line\">      console.log(&apos;接收&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Phone.getChargingCord = function () &#123;</span><br><span class=\"line\">      return _USBTypec;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return Phone;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else &#123;</span><br><span class=\"line\">    console.log(&apos;接口不对无法转换&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function PhoneDeleteInterface(Phone)&#123;</span><br><span class=\"line\">  delete Phone.charging;</span><br><span class=\"line\">  delete Phone.getChargingCord;</span><br><span class=\"line\">  return Phone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-7\"><a href=\"#应用-7\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>在不动应用层的情况下，切换底层、</p>\n<h1 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h1><h2 id=\"一句话就是-中间夹了一个类\"><a href=\"#一句话就是-中间夹了一个类\" class=\"headerlink\" title=\"一句话就是 中间夹了一个类\"></a>一句话就是 中间夹了一个类</h2><h2 id=\"定义-10\"><a href=\"#定义-10\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>用桥接模式联结多个类</p>\n<h2 id=\"代码-9\"><a href=\"#代码-9\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Class1 =function(a,b,c)&#123;</span><br><span class=\"line\">\tthis.a =a;</span><br><span class=\"line\">\tthis.b = b;</span><br><span class=\"line\">\tthis.c = c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var Class2 =function(d)&#123;</span><br><span class=\"line\">\tthis.d = d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var BridgeClass =function(a,b,c,d)&#123;</span><br><span class=\"line\">\t   this.one = new Class1(a,b,c);</span><br><span class=\"line\">\t   this.two = new Class2(d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-8\"><a href=\"#应用-8\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>暂无</p>\n<h1 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h1><h2 id=\"一句话定义：树状结构，且行为递归执行\"><a href=\"#一句话定义：树状结构，且行为递归执行\" class=\"headerlink\" title=\"一句话定义：树状结构，且行为递归执行\"></a>一句话定义：树状结构，且行为递归执行</h2><p>##定义</p>\n<p>部分-整体模式，它将所有对象组合成树形结构。使得用户只需要操作最上层的接口，就可以对所有成员做相同的操作。</p>\n<h2 id=\"代码-10\"><a href=\"#代码-10\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$( &apos;body&apos; ).unbind( &apos;*&apos; );//触发所有的dom解绑定事件</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-9\"><a href=\"#应用-9\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>jqdom对象</p>\n<h1 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h1><h2 id=\"一句话总结：珍珠奶茶\"><a href=\"#一句话总结：珍珠奶茶\" class=\"headerlink\" title=\"一句话总结：珍珠奶茶\"></a>一句话总结：珍珠奶茶</h2><h2 id=\"定义-11\"><a href=\"#定义-11\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>** 装饰者(decorator) **模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。</p>\n<h2 id=\"代码-11\"><a href=\"#代码-11\" class=\"headerlink\" title=\"代码\"></a>代码</h2><blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Plan1 = &#123;</span><br><span class=\"line\">    fire: function () &#123;</span><br><span class=\"line\">        console.log(&apos;发射普通的子弹&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var missileDecorator= function () &#123;</span><br><span class=\"line\">    console.log(&apos;发射导弹!&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var fire = Plan1.fire;</span><br><span class=\"line\"></span><br><span class=\"line\">Plan1.fire=function () &#123;</span><br><span class=\"line\">    fire();</span><br><span class=\"line\">    missileDecorator();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Plan1.fire();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-10\"><a href=\"#应用-10\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>AOP</p>\n<h1 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h1><h2 id=\"一句话总结就是-减少外部需要记忆的api\"><a href=\"#一句话总结就是-减少外部需要记忆的api\" class=\"headerlink\" title=\"一句话总结就是:减少外部需要记忆的api\"></a>一句话总结就是:减少外部需要记忆的api</h2><h2 id=\"定义-12\"><a href=\"#定义-12\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>外观模式提供一个高层接口，这个接口使得客户端或子系统更加方便调用。</p>\n<h2 id=\"代码-12\"><a href=\"#代码-12\" class=\"headerlink\" title=\"代码\"></a>代码</h2><blockquote>\n<p>var getName = function(){</p>\n<p>  return ‘’svenzeng”</p>\n<p>}</p>\n<p>var getSex = function(){</p>\n<p>   return ‘man’</p>\n<p>}</p>\n<p>var getUserInfo = function(){</p>\n<p>  var info = a() + b();</p>\n<p>  return info;</p>\n<p>}</p>\n</blockquote>\n<h2 id=\"应用-11\"><a href=\"#应用-11\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>快餐</p>\n<h1 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h1><h2 id=\"一句话总结就是：虚拟列表，只创建你看得见的dom\"><a href=\"#一句话总结就是：虚拟列表，只创建你看得见的dom\" class=\"headerlink\" title=\"一句话总结就是：虚拟列表，只创建你看得见的dom\"></a>一句话总结就是：虚拟列表，只创建你看得见的dom</h2><h2 id=\"定义-13\"><a href=\"#定义-13\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>提供一些共享的对象以便重复利用. </p>\n<h2 id=\"代码-13\"><a href=\"#代码-13\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var getDiv = (function()&#123;</span><br><span class=\"line\">    var created = [];</span><br><span class=\"line\">    var create = function()&#123;</span><br><span class=\"line\">          return document.body.appendChild( document.createElement( &apos;div&apos; ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var get = function()&#123;</span><br><span class=\"line\">         if ( created.length )&#123;</span><br><span class=\"line\">              return created.shift();</span><br><span class=\"line\">          &#125;else&#123;</span><br><span class=\"line\">                return create();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">/* 一个假设的事件，用来监听刚消失在视线外的div，实际上可以通过监听滚                                     动条位置来实现 */</span><br><span class=\"line\">      userInfoContainer.disappear(function( div )&#123;</span><br><span class=\"line\">              created.push( div );</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"> &#125;)()</span><br><span class=\"line\">  var div = getDiv();</span><br><span class=\"line\">  div.innerHTML = &quot;$&#123;userinfo&#125;&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>##应用</p>\n<p>虚拟列表，只创建你看得见的dom</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h2 id=\"一句话就是：代理人先整理需求\"><a href=\"#一句话就是：代理人先整理需求\" class=\"headerlink\" title=\"一句话就是：代理人先整理需求\"></a>一句话就是：代理人先整理需求</h2><h2 id=\"定义-14\"><a href=\"#定义-14\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>代理模式的定义是把对一个对象的访问, 交给另一个代理对象来操作.</p>\n<h2 id=\"代码-14\"><a href=\"#代码-14\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = proxy.get( &apos;cgi.xx.com/xxx&apos; );</span><br><span class=\"line\"> </span><br><span class=\"line\">request.send();</span><br><span class=\"line\"> </span><br><span class=\"line\">request.done(function()&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-12\"><a href=\"#应用-12\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>实际的编程中， 这种因为性能问题使用代理模式的机会是非常多的。比如频繁的访问dom节点, 频繁的请求远程资源. 可以把操作先存到一个缓冲区, 然后自己选择真正的触发时机.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"六大原则\"><a href=\"#六大原则\" class=\"headerlink\" title=\"六大原则\"></a>六大原则</h1><p>1.单一职责原则:只做一件事情<br>2.里氏替换原则:同岗位人之间可以互相调换<br>3.依赖倒转原则:应用层依赖底层，但是底层不依赖应用层<br>4.接口隔离原则:模块只声明自己需要的接口<br>5.迪米特法则:在你眼里，我应该是黑盒。<br>6.开闭原则:你只能看，不能改</p>\n<ol>\n<li>开闭原则： 对扩展开放，对修改关闭</li>\n<li>里氏转换原则： 子类继承父类，单独完全可以运行</li>\n<li>依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型</li>\n<li>接口隔离原则： 每一个接口应该是一种角色</li>\n<li>合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分</li>\n<li>迪米特原则： 一个对象应对其他对象有尽可能少的了解</li>\n</ol>\n<blockquote>\n<p>我会在下面设计的模式中，声明使用到对应的原则</p>\n</blockquote>\n<h1 id=\"为什么要尽量使用白话\"><a href=\"#为什么要尽量使用白话\" class=\"headerlink\" title=\"为什么要尽量使用白话\"></a>为什么要尽量使用白话</h1><blockquote>\n<p>纯术语的文章太多，不利于归纳成记忆点，尤其是实际应用中。所以我尝试着能否使用白话或者极度精简的文字去分解这些复杂侃长的语句。</p>\n</blockquote>\n<h1 id=\"为什么要使用设计模式\"><a href=\"#为什么要使用设计模式\" class=\"headerlink\" title=\"为什么要使用设计模式\"></a>为什么要使用设计模式</h1><blockquote>\n<p>开发人员A碰到了一个问题，就找开发B,开发B说用”xxxx设计模式就行了”，如果这个时候开发A不懂设计模式，那他们就无法交流了。就如同我们在汉语里使用成语一样，当你在交流中使用一个成语的时候，是不会去讲述这个成语背后的故事的。因此，一个合格的开发人员，必须掌握设计模式这个“标准词汇”<br>但是过度复杂化的设计模式也不可取，保持一个代码与模式的平衡是一个非常重要的事情。</p>","more":"</blockquote>\n<p>本质：将软件中变化的部分和不变的部分分开</p>\n<h1 id=\"设计模式的类型\"><a href=\"#设计模式的类型\" class=\"headerlink\" title=\"设计模式的类型\"></a>设计模式的类型</h1><h1 id=\"1．创建型模式\"><a href=\"#1．创建型模式\" class=\"headerlink\" title=\"1．创建型模式\"></a>1．创建型模式</h1><p>创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关系创建对象过程中的逻辑。</p>\n<p>社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：</p>\n<ul>\n<li>简单工厂模式（Simple Factory）</li>\n<li>工厂方法模式（Factory Method）</li>\n<li>抽象工厂模式（Abstract Factory）</li>\n<li>创建者模式（Builder）</li>\n<li>原型模式（Prototype）</li>\n<li>单例模式（Singleton）</li>\n</ul>\n<blockquote>\n<p>简单工厂模式不是GoF总结出来的23种设计模式之一</p>\n</blockquote>\n<h1 id=\"2．结构型模式\"><a href=\"#2．结构型模式\" class=\"headerlink\" title=\"2．结构型模式\"></a>2．结构型模式</h1><p>结构型模式是为解决怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）。</p>\n<p>在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：</p>\n<ul>\n<li>外观模式/门面模式（Facade门面模式）</li>\n<li>适配器模式（Adapter）</li>\n<li>代理模式（Proxy）</li>\n<li>装饰模式（Decorator）</li>\n<li>桥梁模式/桥接模式（Bridge）</li>\n<li>组合模式（Composite）</li>\n<li>享元模式（Flyweight）</li>\n</ul>\n<h1 id=\"3．行为型模式\"><a href=\"#3．行为型模式\" class=\"headerlink\" title=\"3．行为型模式\"></a>3．行为型模式</h1><p>行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式。1. 行为类模式使用继承机制在类间分派行为。2. 行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。</p>\n<p>在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：</p>\n<ul>\n<li>模板方法模式（Template Method）</li>\n<li>观察者模式（Observer）</li>\n<li>状态模式（State）</li>\n<li>策略模式（Strategy）</li>\n<li>职责链模式（Chain of Responsibility）</li>\n<li>命令模式（Command）</li>\n<li>访问者模式（Visitor）</li>\n<li>调停者模式（Mediator）</li>\n<li>备忘录模式（Memento）</li>\n<li>迭代器模式（Iterator）</li>\n<li>解释器模式（Interpreter）</li>\n</ul>\n<h2 id=\"三者之间的区别和联系\"><a href=\"#三者之间的区别和联系\" class=\"headerlink\" title=\"三者之间的区别和联系\"></a>三者之间的区别和联系</h2><blockquote>\n<p>创建型模式提供生存环境，结构型模式提供生存理由，行为型模式提供如何生存。</p>\n</blockquote>\n<ol>\n<li>创建型模式为其他两种模式使用提供了环境。</li>\n<li>结构型模式侧重于接口的使用，它做的一切工作都是对象或是类之间的交互，提供一个门。</li>\n<li>行为型模式顾名思义，侧重于具体行为，所以概念中才会出现职责分配和算法通信等内容。</li>\n</ol>\n<h1 id=\"五大创建型模式\"><a href=\"#五大创建型模式\" class=\"headerlink\" title=\"五大创建型模式\"></a>五大创建型模式</h1><blockquote>\n<p>关于创造型模式</p>\n</blockquote>\n<h2 id=\"单例模式-Singleton-Pattern\"><a href=\"#单例模式-Singleton-Pattern\" class=\"headerlink\" title=\"单例模式(Singleton Pattern)\"></a>单例模式(Singleton Pattern)</h2><p>###一句话总结：虽然我有很多网名，但是全世界就一个我</p>\n<p>###代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Menu() &#123;</span><br><span class=\"line\">    // 判断是否存在实例</span><br><span class=\"line\">    if (typeof Universe.instance === &apos;object&apos;) &#123;</span><br><span class=\"line\">        return Universe.instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 其它内容</span><br><span class=\"line\">    this.food =[&quot;hanbao&quot;,&quot;kele&quot;];</span><br><span class=\"line\">    // 缓存</span><br><span class=\"line\">    Menu.instance = this;</span><br><span class=\"line\">    // 隐式返回this</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 测试</span><br><span class=\"line\">var zhizhi = new Menu();</span><br><span class=\"line\">var qiantai=new Menu();</span><br><span class=\"line\">console.log(uni === uni2); // true</span><br></pre></td></tr></table></figure>\n\n<p>###定义</p>\n<blockquote>\n<p>保证系统内部只有唯一一个对应的实例对象，又细分为最开始就实例化（简单粗暴），和第一次使用的时候实例化（可能需要额外的代码来实现这块功能）</p>\n<p>单例模式在<a href=\"https://zh.wikipedia.org/wiki/线程\" target=\"_blank\" rel=\"noopener\">多线程</a>的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>\n<p>通常单例模式在<a href=\"https://zh.wikipedia.org/wiki/Java语言\" target=\"_blank\" rel=\"noopener\">Java语言</a>中，有两种构建方式：</p>\n<ul>\n<li>懒汉方式。指全局的单例实例在第一次被使用时构建。</li>\n<li>饿汉方式。指全局的单例实例在类装载时构建。</li>\n</ul>\n</blockquote>\n<p>###应用</p>\n<ul>\n<li>就像KFC中的菜单，不管你在app还是前天，或者纸质菜单上查看，永远只有一份实例。</li>\n</ul>\n<h2 id=\"简单工厂模式-Simple-Factory\"><a href=\"#简单工厂模式-Simple-Factory\" class=\"headerlink\" title=\"简单工厂模式(Simple Factory)\"></a>简单工厂模式(Simple Factory)</h2><h2 id=\"一句话就是-自动奶茶机\"><a href=\"#一句话就是-自动奶茶机\" class=\"headerlink\" title=\"一句话就是 自动奶茶机\"></a>一句话就是 自动奶茶机</h2><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var request1 = ajax(&apos;cgi.xx.com/xxx&apos; , &apos;&apos;get&apos; );</span><br><span class=\"line\"> </span><br><span class=\"line\">request1.start();</span><br><span class=\"line\"> </span><br><span class=\"line\">request1.done( fn );</span><br><span class=\"line\"> </span><br><span class=\"line\">var request2 = ajax(&apos;cgi.xx.com/xxx&apos; , &apos;&apos;jsonp&apos; );</span><br><span class=\"line\"> </span><br><span class=\"line\">request2.start();</span><br><span class=\"line\"> </span><br><span class=\"line\">request2.done( fn );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况.说的通俗点，就像公司茶水间的饮料机，要咖啡还是牛奶取决于你按哪个按钮。</p>\n<p>你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。</p>\n<p>缺点也很明显，所有逻辑都封装在工厂类呢，但是根据场景使用 还是会很优雅。属于基础的设计模式</p>\n</blockquote>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>KFC饮料机器</p>\n<h2 id=\"抽象工厂-Abstract-Factory\"><a href=\"#抽象工厂-Abstract-Factory\" class=\"headerlink\" title=\"抽象工厂(Abstract Factory)\"></a>抽象工厂(Abstract Factory)</h2><h3 id=\"一句话-interface\"><a href=\"#一句话-interface\" class=\"headerlink\" title=\"一句话 interface\"></a>一句话 interface</h3><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>就是通过类的抽象使得业务适用于一个产品类簇的创建，而不负责某一类产品的实例。</p>\n<p>JS中是没有直接的抽象类的，abstract是个保留字，但是还没有实现，因此我们需要在类的方法中抛出错误来模拟抽象类，如果继承的子类中没有覆写该方法而调用，就会抛出错误。</p>\n<p>工厂是一个抽象类，它不能够直接被实例化，工厂的作用是制定产品族类的结构。土一点的理解方式就是，interface。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 实现subType类对工厂类中的superType类型的抽象类的继承</span><br><span class=\"line\">* @param subType 要继承的类</span><br><span class=\"line\">* @param superType 工厂类中的抽象类type</span><br><span class=\"line\">*/</span><br><span class=\"line\">const VehicleFactory = function(subType, superType) &#123;</span><br><span class=\"line\">  if (typeof VehicleFactory[superType] === &apos;function&apos;) &#123;</span><br><span class=\"line\">    function F() &#123;</span><br><span class=\"line\">      this.type = &apos;车辆&apos;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    F.prototype = new VehicleFactory[superType]()</span><br><span class=\"line\">    subType.constructor = subType</span><br><span class=\"line\">    subType.prototype = new F()                // 因为子类subType不仅需要继承superType对应的类的原型方法，还要继承其对象属性</span><br><span class=\"line\">  &#125; else throw new Error(&apos;不存在该抽象类&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">VehicleFactory.Car = function() &#123;</span><br><span class=\"line\">  this.type = &apos;car&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VehicleFactory.Car.prototype = &#123;</span><br><span class=\"line\">  getPrice: function() &#123;</span><br><span class=\"line\">    return new Error(&apos;抽象方法不可使用&apos;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getSpeed: function() &#123;</span><br><span class=\"line\">    return new Error(&apos;抽象方法不可使用&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const BMW = function(price, speed) &#123;</span><br><span class=\"line\">  this.price = price</span><br><span class=\"line\">  this.speed = speed</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VehicleFactory(BMW, &apos;Car&apos;)        // 继承Car抽象类</span><br><span class=\"line\">BMW.prototype.getPrice = function() &#123;        // 覆写getPrice方法</span><br><span class=\"line\">  console.log(`BWM price is $&#123;this.price&#125;`)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BMW.prototype.getSpeed = function() &#123;</span><br><span class=\"line\">  console.log(`BWM speed is $&#123;this.speed&#125;`)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const baomai5 = new BMW(30, 99)</span><br><span class=\"line\">baomai5.getPrice()                          // BWM price is 30</span><br><span class=\"line\">baomai5 instanceof VehicleFactory.Car</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>KFC汉堡类型：面包片+调料+肉+蔬菜+面包片</p>\n<h2 id=\"建造者模式（Builder-Pattern）\"><a href=\"#建造者模式（Builder-Pattern）\" class=\"headerlink\" title=\"建造者模式（Builder Pattern）\"></a>建造者模式（Builder Pattern）</h2><p>###一句话总结</p>\n<h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h3 id=\"应用-2\"><a href=\"#应用-2\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>1.简述：将一个复杂对象的–构建–与它的表示分离，使得同样的构建过程可以创建.一步步构造一个复杂对象，返回一个完整的对象``<br>2.代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// #建造者模式</span><br></pre></td></tr></table></figure>\n\n<p>// 抽象建造者<br>var Car = function (param) {<br>    // 速度<br>    this.speed = param &amp;&amp; param.speed || ‘0’;<br>    // 重量<br>    this.weight = param &amp;&amp; param.weight || ‘0’;<br>}</p>\n<p>Car.prototype = {<br>    // 获取速度<br>    getSpeed: function () {<br>        return this.speed;<br>    },<br>    // 获取重量<br>    getWeight: function () {<br>        return this.weight<br>    }<br>}</p>\n<p>// 轮胎部件类<br>var Tyre = function (type) {<br>    var that = this;<br>    // 构造器<br>    // 构造函数中通过传入的type类型设置相对应的轮胎尺寸<br>    (function (type,that) {<br>        switch (type) {<br>            case ‘small’:<br>            that.tyre = ‘小号轮胎’;<br>            that.tyreIntro = ‘正在使用小号轮胎’;<br>            break;<br>            case ‘normal’:<br>            that.tyre = ‘中号轮胎’;<br>            that.tyreIntro = ‘正在使用中号轮胎’;<br>            break;<br>            case ‘big’:<br>            that.tyre = ‘大号轮胎’;<br>            that.tyreIntro = ‘正在使用大号轮胎’;<br>            break;<br>        }<br>    })(type,this);<br>}</p>\n<p>Tyre.prototype = {<br>    // 更换轮胎的方法<br>    changeType: function (type) {<br>        that.tyre = type;<br>        that.tyreIntro = ‘正在使用’+type;<br>    }<br>}</p>\n<p>// 发动机部件类<br>var Engine = function (type) {<br>    var that = this;<br>    // 构造器<br>    // 构造函数中通过传入的type类型设置相对应的发动机类型<br>    (function (type,that) {<br>        switch (type) {<br>            case ‘small’:<br>            that.engine = ‘小号发动机’;<br>            that.engineIntro = ‘正在使用小号发动机’;<br>            break;<br>            case ‘normal’:<br>            that.engine = ‘中号发动机’;<br>            that.engineIntro = ‘正在使用中号发动机’;<br>            break;<br>            case ‘big’:<br>            that.engine = ‘大号发动机’;<br>            that.engineIntro = ‘正在使用大号发动机’;<br>            break;<br>        }<br>    })(type,this);<br>}</p>\n<p>Engine.prototype = {<br>    // 更换发动机的方法<br>    changeType: function (type) {<br>        that.engine = type;<br>        that.engineIntro = ‘正在使用’+type;<br>    }<br>}</p>\n<p>/**</p>\n<ul>\n<li>指挥者,建造一个奔驰车的类</li>\n<li>@param {*轮胎类型 small normal big} tyre </li>\n<li>@param {*发动机类型 small normal big} engine </li>\n<li>@param {*车辆基本属性 param.speed:速度 param.weight: 重量} param </li>\n<li>/<br>var BenChi = function (tyre,engine,param) {<br>  // 创建一个车辆缓存对象<br>  var _car = new Car(param);ckplayer 隐藏控制<br>  // 创建车辆的轮胎<br>  _car.tyreInfo = new Tyre(tyre);<br>  // 创建车辆的发动机<br>  _car.engineInfo = new Engine(engine);<br>  // 将创建的车辆对象返回<br>  return _car;<br>}</li>\n</ul>\n<p>// 具体建造者 实例化奔驰车类<br>var benchi1 = new BenChi(‘small’,’big’,{speed: 200,weight: ‘200’});<br>console.log(benchi1.speed);// 200<br>console.log(benchi1.weight);// 200<br>console.log(benchi1.tyreInfo.tyre);// 小号轮胎<br>console.log(benchi1.tyreInfo.tyreIntro);// 正在使用小号轮胎<br>console.log(benchi1.engineInfo.engine);// 大号发动机<br>console.log(benchi1.engineInfo.engineIntro);// 正在使用大号发动机<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3.优点:每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</span><br><span class=\"line\">4.缺点</span><br><span class=\"line\">5.白话总结:建造者模式主要用于“分布构建一个复杂的对象”</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h2><p>减少new，使用create直接创建对象。</p>\n<h1 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h1><h2 id=\"模版方式\"><a href=\"#模版方式\" class=\"headerlink\" title=\"模版方式\"></a>模版方式</h2><blockquote>\n<p>类似管控的视频模块，应该要使用这个模式,就是预设好具体的口子给继承方使用。</p>\n<p>1.抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。</p>\n<p>2.模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。</p>\n<p>3.钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。</p>\n</blockquote>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 抽象父类：饮料 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Beverage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// (1) 把水煮沸</span></span><br><span class=\"line\">Beverage.prototype.boilWater = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"把水煮沸\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// (2) 沸水浸泡</span></span><br><span class=\"line\">Beverage.prototype.brew = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"子类必须重写brew方法\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// (3) 倒进杯子</span></span><br><span class=\"line\">Beverage.prototype.pourInCup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"子类必须重写pourInCup方法\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// (4) 加调料</span></span><br><span class=\"line\">Beverage.prototype.addCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"子类必须重写addCondiments方法\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 模板方法 */</span></span><br><span class=\"line\">Beverage.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.boilWater();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.brew();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pourInCup();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addCondiments();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现子类 Coffee*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Coffee = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Coffee.prototype = <span class=\"keyword\">new</span> Beverage();</span><br><span class=\"line\"><span class=\"comment\">// 重写非公有方法</span></span><br><span class=\"line\">Coffee.prototype.brew = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"用沸水冲泡咖啡\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Coffee.prototype.pourInCup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"把咖啡倒进杯子\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Coffee.prototype.addCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"加牛奶\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffee = <span class=\"keyword\">new</span> Coffee();</span><br><span class=\"line\">coffee.init();</span><br></pre></td></tr></table></figure>\n\n<p>通过模板方法模式，在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用大多数子类的，但也会出现“个性”子类。<br>如上述流程，加调料是可选的。<br>钩子方法可以解决这个问题，放置钩子是隔离变化的一种常见手段。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 添加钩子方法 */</span></span><br><span class=\"line\">Beverage.prototype.customerWantsCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Beverage.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.boilWater();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.brew();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pourInCup();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.customerWantsCondiments()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.addCondiments();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现子类 Tea*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Tea = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Tea.prototype = <span class=\"keyword\">new</span> Beverage();</span><br><span class=\"line\"><span class=\"comment\">// 重写非公有方法</span></span><br><span class=\"line\">Tea.prototype.brew = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"用沸水冲泡茶\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Tea.prototype.pourInCup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"把茶倒进杯子\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Tea.prototype.addCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"加牛奶\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Tea.prototype.customerWantsCondiments = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.confirm(<span class=\"string\">\"需要添加调料吗？\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> tea = <span class=\"keyword\">new</span> Tea();</span><br><span class=\"line\">tea.init();</span><br></pre></td></tr></table></figure>\n\n<p>JavaScript没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。</p>\n<h2 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h2><blockquote>\n<p>面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性。但由于这些细粒度对象之间的联系激增，又可能反过来降低它们的可复用性。<br>中介者模式的作用就是解除对象与对象之间的紧耦合关系。</p>\n<p>之前卓锐的路网系统就是这样开发，但是和观察者好像有点雷同。查阅资料以后发现：</p>\n<p><strong>中介者(mediator)强调的是同事(colleague)类之间的交互</strong></p>\n<p><strong>而观察者(observer)中的目标类(subject)强调是目标改变后对观察者进行统一的通讯</strong></p>\n<p><strong>两者非常相同的一点就是:中介者需要持有并且知道所有的同事类,而目标类也必须持有所有的目标类,但是是一目标类的接口引用方式持有,所以说目标类是不知道观察者的,所有的观察者都是一样的</strong></p>\n<p>其实从名称考虑，确实相当于是房产中介在租房和房东之间的关系。</p>\n</blockquote>\n<h2 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h2><blockquote>\n<p>命令模式比较容易设计一个命令队列( 容易AOP)，在需求的情况下比较容易将命令计入日志，并且允许接受请求的一方决定是否需要调用，而且可以实现对请求的撤销和重设，而且由于新增的具体类不影响其他的类，所以很容易实现。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> CarManager = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 请求信息</span></span><br><span class=\"line\">        requestInfo: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">model, id</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'The information for '</span> + model +</span><br><span class=\"line\">        <span class=\"string\">' with ID '</span> + id + <span class=\"string\">' is foobar'</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 购买汽车</span></span><br><span class=\"line\">        buyVehicle: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">model, id</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'You have successfully purchased Item '</span></span><br><span class=\"line\">        + id + <span class=\"string\">', a '</span> + model;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 组织view</span></span><br><span class=\"line\">        arrangeViewing: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">model, id</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'You have successfully booked a viewing of '</span></span><br><span class=\"line\">        + model + <span class=\"string\">' ( '</span> + id + <span class=\"string\">' ) '</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">//来看一下上述代码，通过调用函数来简单执行manager的命令，然而在一些情况下，我们并不想直接调用对象内部的方法。这样会增加对象与对象间的依赖。现在我们来扩展一下这个CarManager 使其能够接受任何来自包括model和car ID 的CarManager对象的处理请求。根据命令模式的定义，我们希望实现如下这种功能的调用：</span></span><br><span class=\"line\"></span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">commandType</span>: <span class=\"string\">\"buyVehicle\"</span>, <span class=\"attr\">operand1</span>: <span class=\"string\">'Ford Escort'</span>, <span class=\"attr\">operand2</span>: <span class=\"string\">'453543'</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">//根据这样的需求，我们可以这样啦实现CarManager.execute方法：</span></span><br><span class=\"line\"></span><br><span class=\"line\">CarManager.execute = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">command</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CarManager[command.request](command.model, command.carID);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//改造以后，调用就简单多了，如下调用都可以实现（当然有些异常细节还是需要再完善一下的）：</span></span><br><span class=\"line\"></span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">request</span>: <span class=\"string\">\"arrangeViewing\"</span>, <span class=\"attr\">model</span>: <span class=\"string\">'Ferrari'</span>, <span class=\"attr\">carID</span>: <span class=\"string\">'145523'</span> &#125;);</span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">request</span>: <span class=\"string\">\"requestInfo\"</span>, <span class=\"attr\">model</span>: <span class=\"string\">'Ford Mondeo'</span>, <span class=\"attr\">carID</span>: <span class=\"string\">'543434'</span> &#125;);</span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">request</span>: <span class=\"string\">\"requestInfo\"</span>, <span class=\"attr\">model</span>: <span class=\"string\">'Ford Escort'</span>, <span class=\"attr\">carID</span>: <span class=\"string\">'543434'</span> &#125;);</span><br><span class=\"line\">CarManager.execute(&#123; <span class=\"attr\">request</span>: <span class=\"string\">\"buyVehicle\"</span>, <span class=\"attr\">model</span>: <span class=\"string\">'Ford Escort'</span>, <span class=\"attr\">carID</span>: <span class=\"string\">'543434'</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>设计模式的核心思想是不是都插入一个中间层，把业务集中到中间层去？</strong></p>\n<h2 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h2><h3 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>职责连是由多个不同的对象组成的，有发送者跟接收者，分别负责信息的发送跟接收，其中，链中第一个对象是 职责连是由多个不同的对象组成的，发送者是发送请求的对象，接收者接收请求并且对其进行处理或传递的对象。基本流程如下：</p>\n<ol>\n<li>发送者知道链中的第一个接收者，它向这个接收者发送该请求。</li>\n<li>每一个接收者都对请求进行分析，然后要么处理它，要么它往下传递。</li>\n<li>每一个接收者知道其他的对象只有一个，即它在链中的下家(successor)。</li>\n<li>如果没有任何接收者处理请求，那么请求会从链中离开。</li>\n</ol>\n<p>职责链模式是个链式结构，请求在链中的节点之间依次传递，直到有一个对象能处理该请求为止。如果没有任何对象处理该请求的话，那么请求就会从链中离开</p>\n<h3 id=\"事例代码\"><a href=\"#事例代码\" class=\"headerlink\" title=\"事例代码\"></a>事例代码</h3><blockquote>\n<p>假设这么一个场景：<br>我们负责一个售卖手机的电商网站，经过分别缴纳500元定金和200元定金的两轮预定后，到了正式购买阶段。针对预定用户实行优惠，支付过500元定金的用户会收到100元的商城优惠券，支付过200元定金的用户会收到50元的商城优惠券，没有支付定金的用户归为普通购买，且在库存有限的情况下不一定保证买到。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 传统方式实现 */</span><br><span class=\"line\">// orderType：[1:500, 2:200, 3:普通]，isPaid：true/false，stock：库存量</span><br><span class=\"line\">var order = function(orderType, isPaid, stock) &#123;</span><br><span class=\"line\">    if(orderType === 1) &#123;</span><br><span class=\"line\">        if(isPaid) &#123;</span><br><span class=\"line\">            console.log(&quot;500元定金预购，得到100优惠券&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if(stock &gt; 0) &#123;</span><br><span class=\"line\">                console.log(&quot;普通购买，无优惠券&quot;);</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                console.log(&quot;库存不足&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else if(orderType === 2) &#123;</span><br><span class=\"line\">        if(isPaid) &#123;</span><br><span class=\"line\">            console.log(&quot;200元定金预购，得到50优惠券&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if(stock &gt; 0) &#123;</span><br><span class=\"line\">                console.log(&quot;普通购买，无优惠券&quot;);</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                console.log(&quot;库存不足&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else if(orderType === 2) &#123;</span><br><span class=\"line\">        if(stock &gt; 0) &#123;</span><br><span class=\"line\">            console.log(&quot;普通购买，无优惠券&quot;);</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            console.log(&quot;库存不足&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">order(1, true, 500);</span><br><span class=\"line\"></span><br><span class=\"line\">/*职责链 */</span><br><span class=\"line\">var order500 = function(orderType, isPaid, stock) &#123;</span><br><span class=\"line\">    if(orderType === 1 &amp;&amp; isPaid === true) &#123;</span><br><span class=\"line\">        console.log(&quot;500元定金预购，得到100优惠券&quot;);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        return &quot;nextSuccessor&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var order200 = function(orderType, isPaid, stock) &#123;</span><br><span class=\"line\">    if(orderType === 2 &amp;&amp; isPaid === true) &#123;</span><br><span class=\"line\">        console.log(&quot;200元定金预购，得到50优惠券&quot;);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        return &quot;nextSuccessor&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var orderNormal = function(orderType, isPaid, stock) &#123;</span><br><span class=\"line\">    if(stock &gt; 0) &#123;</span><br><span class=\"line\">        console.log(&quot;普通购买，无优惠券&quot;);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        console.log(&quot;库存不足&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.after = function(fn) &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        var ret = self.apply(this, arguments);</span><br><span class=\"line\">        if(ret === &quot;nextSuccessor&quot;) &#123;</span><br><span class=\"line\">            return fn.apply(this, arguments);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var order = order500.after(order200).after(orderNormal);</span><br><span class=\"line\">order(1, true, 10);//结合AOP</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延伸应用\"><a href=\"#延伸应用\" class=\"headerlink\" title=\"延伸应用\"></a>延伸应用</h3><p>常见的做法其实是优惠卷的案例？</p>\n<h2 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><h3 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。<br>基于策略类模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，Context接收客户的请求，随后把请求委托给某一个策略类。</p>\n<h3 id=\"事例\"><a href=\"#事例\" class=\"headerlink\" title=\"事例\"></a>事例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var strategies = &#123;</span><br><span class=\"line\">    &quot;S&quot;: function(salary) &#123;</span><br><span class=\"line\">        return salary * 4;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;A&quot;: function(salary) &#123;</span><br><span class=\"line\">        return salary * 3;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;B&quot;: function(salary) &#123;</span><br><span class=\"line\">        return salary * 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收请求</span><br><span class=\"line\">var calculateBonus = function(level, salary) &#123;</span><br><span class=\"line\">    return strategies[level](salary);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 测试</span><br><span class=\"line\">console.log(calculateBonus(&quot;S&quot;, 20000));</span><br><span class=\"line\">console.log(calculateBonus(&quot;A&quot;, 20000));</span><br><span class=\"line\">console.log(calculateBonus(&quot;B&quot;, 20000));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延伸应用-1\"><a href=\"#延伸应用-1\" class=\"headerlink\" title=\"延伸应用\"></a>延伸应用</h3><p>常见的表单验证js,如：validator.js</p>\n<h1 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h1><h2 id=\"一句话总结：就是foreach\"><a href=\"#一句话总结：就是foreach\" class=\"headerlink\" title=\"一句话总结：就是foreach\"></a>一句话总结：就是foreach</h2><p>##定义</p>\n<blockquote>\n<p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>\n</blockquote>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> each = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ary, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = ary.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        callback.call(ary[i], i, ary[i]);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">each([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"当前下标为：\"</span>+ i + <span class=\"string\">\" 当前元素为：\"</span>+ n );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>##延伸应用</p>\n<p>文件上传，根据不同的浏览器获取相应的上传组件对象。(高阶用法，存疑)</p>\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><h2 id=\"一句话总结就是-就是vue里的emit-on\"><a href=\"#一句话总结就是-就是vue里的emit-on\" class=\"headerlink\" title=\"一句话总结就是:就是vue里的emit/on\"></a>一句话总结就是:就是vue里的emit/on</h2><h2 id=\"定义-5\"><a href=\"#定义-5\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>观察者模式又叫做发布订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察着对象。 它是由两类对象组成，主题和观察者，主题负责发布事件，同时观察者通过订阅这些事件来观察该主体，发布者和订阅者是完全解耦的，彼此不知道对方的存在，两者仅仅共享一个自定义事件的名称。</p>\n</blockquote>\n<h2 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = new Pubsub();</span><br><span class=\"line\"> p1.on(&apos;mm&apos;, function (name) &#123;</span><br><span class=\"line\">     console.log(&apos;mm: &apos;+ name);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> p1.emit(&apos;mm&apos;,&apos;哈哈哈哈&apos;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-3\"><a href=\"#应用-3\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>MQ</p>\n<h1 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h1><h2 id=\"一句话总结就是：有限状态机\"><a href=\"#一句话总结就是：有限状态机\" class=\"headerlink\" title=\"一句话总结就是：有限状态机\"></a>一句话总结就是：有限状态机</h2><h2 id=\"定义-6\"><a href=\"#定义-6\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。</p>\n<h2 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关灯</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> OffLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light = light;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 弱光</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> OffLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light = light;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 强光</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> StrongLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light = light;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Light = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 开关状态 */</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.offLight = <span class=\"keyword\">new</span> OffLightState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weakLight = <span class=\"keyword\">new</span> WeakLightState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strongLight = <span class=\"keyword\">new</span> StrongLightState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 快关按钮 */</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.button = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Light.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"button\"</span>),</span><br><span class=\"line\">        self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.button = <span class=\"built_in\">document</span>.body.appendChild(button);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.button.innerHTML = <span class=\"string\">'开关'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = <span class=\"keyword\">this</span>.offLight;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.button.click = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        self.currentState.buttonWasPressed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 让抽象父类的抽象方法直接抛出一个异常（避免状态子类未实现buttonWasPressed方法）</span></span><br><span class=\"line\">Light.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"父类的buttonWasPressed方法必须被重写\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Light.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newState</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = newState;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 关灯 */</span></span><br><span class=\"line\">OffLightState.prototype = <span class=\"keyword\">new</span> Light();  <span class=\"comment\">// 继承抽象类</span></span><br><span class=\"line\">OffLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"关灯！\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.weakLight);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 弱光 */</span></span><br><span class=\"line\">WeakLightState.prototype = <span class=\"keyword\">new</span> Light();</span><br><span class=\"line\">WeakLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"弱光！\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.strongLight);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/* 强光 */</span></span><br><span class=\"line\">StrongLightState.prototype = <span class=\"keyword\">new</span> Light();</span><br><span class=\"line\">StrongLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"强光！\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.offLight);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-4\"><a href=\"#应用-4\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>任意上层应用的状态显示</p>\n<h1 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h1><p>##一句话总结就是：就是留个备份，出问题了就回滚</p>\n<h2 id=\"定义-7\"><a href=\"#定义-7\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>暂无</p>\n<h2 id=\"代码-6\"><a href=\"#代码-6\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Page = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> page = <span class=\"number\">1</span>,</span><br><span class=\"line\">      cache = &#123;&#125;,</span><br><span class=\"line\">      data;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> page </span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( cache[ page ] )&#123;</span><br><span class=\"line\">               data =  cache[ page ];</span><br><span class=\"line\">               render( data );</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               Ajax.send( <span class=\"string\">'cgi.xx.com/xxx'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> data </span>)</span>&#123;</span><br><span class=\"line\">                   cache[ page ] = data;</span><br><span class=\"line\">                   render( data );</span><br><span class=\"line\">               &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-5\"><a href=\"#应用-5\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>操作回溯</p>\n<h1 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h1><p>##一句话总结就是：抽象语法树AST</p>\n<h2 id=\"定义-8\"><a href=\"#定义-8\" class=\"headerlink\" title=\"定义\"></a>定义</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</span><br></pre></td></tr></table></figure>\n\n<p>##代码</p>\n<p>##应用</p>\n<p>SQL </p>\n<h1 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h1><h2 id=\"一句话总结就是：我中有你-你中有我\"><a href=\"#一句话总结就是：我中有你-你中有我\" class=\"headerlink\" title=\"一句话总结就是：我中有你 你中有我\"></a>一句话总结就是：我中有你 你中有我</h2><p>##定义</p>\n<p>访问者模式：针对于对象结构中的元素，定义在不改变对象的前提下访问结构中元素的方法</p>\n<p>在访问者模式中，主要包括下面几个角色</p>\n<p>1、抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。</p>\n<p>2、访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。</p>\n<p>3、抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。</p>\n<p>4、元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。</p>\n<p>5、结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。</p>\n<h2 id=\"代码-7\"><a href=\"#代码-7\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Visitor() &#123;  </span><br><span class=\"line\">  this.visit = function( concreteElement ) &#123;  </span><br><span class=\"line\">    concreteElement.doSomething();  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">// 元素类  </span><br><span class=\"line\">function ConceteElement() &#123;  </span><br><span class=\"line\">  this.doSomething = function() &#123;  </span><br><span class=\"line\">    console.log(&quot;这是一个具体元素&quot;);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  this.accept = function( visitor ) &#123;  </span><br><span class=\"line\">    visitor.visit(this);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">// Client  </span><br><span class=\"line\">var ele = new ConceteElement();  </span><br><span class=\"line\">var v = new Visitor();  </span><br><span class=\"line\">ele.accept( v );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-6\"><a href=\"#应用-6\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>无</p>\n<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><p>##一句话就是：不同类型的数据线的转接器</p>\n<h2 id=\"定义-9\"><a href=\"#定义-9\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>\n<h2 id=\"代码-8\"><a href=\"#代码-8\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function PhoneUSBTypecToMicroUSB(Phone) &#123;</span><br><span class=\"line\">  var _USBTypec = new ChargingCord(&apos;USBTypec&apos;);</span><br><span class=\"line\">  var _MicroUSB = new ChargingCord(&apos;MicroUSB&apos;);</span><br><span class=\"line\">  if (_USBTypec.check(Phone.getChargingCord())) &#123;</span><br><span class=\"line\">    Phone.charging = function () &#123;</span><br><span class=\"line\">      console.log(this.getName());</span><br><span class=\"line\">      _USBTypec.work();</span><br><span class=\"line\">      console.log(&apos;转接&apos;);</span><br><span class=\"line\">      _MicroUSB.work();</span><br><span class=\"line\">      console.log(&apos;接收&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Phone.getChargingCord = function () &#123;</span><br><span class=\"line\">      return _MicroUSB;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return Phone;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else &#123;</span><br><span class=\"line\">    console.log(&apos;接口不对无法转换&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function PhoneMicroUSBToUSBTypec(Phone) &#123;</span><br><span class=\"line\">  var _USBTypec = new ChargingCord(&apos;USBTypec&apos;);</span><br><span class=\"line\">  var _MicroUSB = new ChargingCord(&apos;MicroUSB&apos;);</span><br><span class=\"line\">  if (_MicroUSB.check(Phone.getChargingCord())) &#123;</span><br><span class=\"line\">    Phone.charging = function () &#123;</span><br><span class=\"line\">      console.log(this.getName());</span><br><span class=\"line\">      _MicroUSB.work();</span><br><span class=\"line\">      console.log(&apos;转接&apos;);</span><br><span class=\"line\">      _USBTypec.work();</span><br><span class=\"line\">      console.log(&apos;接收&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Phone.getChargingCord = function () &#123;</span><br><span class=\"line\">      return _USBTypec;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return Phone;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else &#123;</span><br><span class=\"line\">    console.log(&apos;接口不对无法转换&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function PhoneDeleteInterface(Phone)&#123;</span><br><span class=\"line\">  delete Phone.charging;</span><br><span class=\"line\">  delete Phone.getChargingCord;</span><br><span class=\"line\">  return Phone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-7\"><a href=\"#应用-7\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>在不动应用层的情况下，切换底层、</p>\n<h1 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h1><h2 id=\"一句话就是-中间夹了一个类\"><a href=\"#一句话就是-中间夹了一个类\" class=\"headerlink\" title=\"一句话就是 中间夹了一个类\"></a>一句话就是 中间夹了一个类</h2><h2 id=\"定义-10\"><a href=\"#定义-10\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>用桥接模式联结多个类</p>\n<h2 id=\"代码-9\"><a href=\"#代码-9\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Class1 =function(a,b,c)&#123;</span><br><span class=\"line\">\tthis.a =a;</span><br><span class=\"line\">\tthis.b = b;</span><br><span class=\"line\">\tthis.c = c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var Class2 =function(d)&#123;</span><br><span class=\"line\">\tthis.d = d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var BridgeClass =function(a,b,c,d)&#123;</span><br><span class=\"line\">\t   this.one = new Class1(a,b,c);</span><br><span class=\"line\">\t   this.two = new Class2(d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-8\"><a href=\"#应用-8\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>暂无</p>\n<h1 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h1><h2 id=\"一句话定义：树状结构，且行为递归执行\"><a href=\"#一句话定义：树状结构，且行为递归执行\" class=\"headerlink\" title=\"一句话定义：树状结构，且行为递归执行\"></a>一句话定义：树状结构，且行为递归执行</h2><p>##定义</p>\n<p>部分-整体模式，它将所有对象组合成树形结构。使得用户只需要操作最上层的接口，就可以对所有成员做相同的操作。</p>\n<h2 id=\"代码-10\"><a href=\"#代码-10\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$( &apos;body&apos; ).unbind( &apos;*&apos; );//触发所有的dom解绑定事件</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-9\"><a href=\"#应用-9\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>jqdom对象</p>\n<h1 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h1><h2 id=\"一句话总结：珍珠奶茶\"><a href=\"#一句话总结：珍珠奶茶\" class=\"headerlink\" title=\"一句话总结：珍珠奶茶\"></a>一句话总结：珍珠奶茶</h2><h2 id=\"定义-11\"><a href=\"#定义-11\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>** 装饰者(decorator) **模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。</p>\n<h2 id=\"代码-11\"><a href=\"#代码-11\" class=\"headerlink\" title=\"代码\"></a>代码</h2><blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Plan1 = &#123;</span><br><span class=\"line\">    fire: function () &#123;</span><br><span class=\"line\">        console.log(&apos;发射普通的子弹&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var missileDecorator= function () &#123;</span><br><span class=\"line\">    console.log(&apos;发射导弹!&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var fire = Plan1.fire;</span><br><span class=\"line\"></span><br><span class=\"line\">Plan1.fire=function () &#123;</span><br><span class=\"line\">    fire();</span><br><span class=\"line\">    missileDecorator();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Plan1.fire();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-10\"><a href=\"#应用-10\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>AOP</p>\n<h1 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h1><h2 id=\"一句话总结就是-减少外部需要记忆的api\"><a href=\"#一句话总结就是-减少外部需要记忆的api\" class=\"headerlink\" title=\"一句话总结就是:减少外部需要记忆的api\"></a>一句话总结就是:减少外部需要记忆的api</h2><h2 id=\"定义-12\"><a href=\"#定义-12\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>外观模式提供一个高层接口，这个接口使得客户端或子系统更加方便调用。</p>\n<h2 id=\"代码-12\"><a href=\"#代码-12\" class=\"headerlink\" title=\"代码\"></a>代码</h2><blockquote>\n<p>var getName = function(){</p>\n<p>  return ‘’svenzeng”</p>\n<p>}</p>\n<p>var getSex = function(){</p>\n<p>   return ‘man’</p>\n<p>}</p>\n<p>var getUserInfo = function(){</p>\n<p>  var info = a() + b();</p>\n<p>  return info;</p>\n<p>}</p>\n</blockquote>\n<h2 id=\"应用-11\"><a href=\"#应用-11\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>快餐</p>\n<h1 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h1><h2 id=\"一句话总结就是：虚拟列表，只创建你看得见的dom\"><a href=\"#一句话总结就是：虚拟列表，只创建你看得见的dom\" class=\"headerlink\" title=\"一句话总结就是：虚拟列表，只创建你看得见的dom\"></a>一句话总结就是：虚拟列表，只创建你看得见的dom</h2><h2 id=\"定义-13\"><a href=\"#定义-13\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>提供一些共享的对象以便重复利用. </p>\n<h2 id=\"代码-13\"><a href=\"#代码-13\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var getDiv = (function()&#123;</span><br><span class=\"line\">    var created = [];</span><br><span class=\"line\">    var create = function()&#123;</span><br><span class=\"line\">          return document.body.appendChild( document.createElement( &apos;div&apos; ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var get = function()&#123;</span><br><span class=\"line\">         if ( created.length )&#123;</span><br><span class=\"line\">              return created.shift();</span><br><span class=\"line\">          &#125;else&#123;</span><br><span class=\"line\">                return create();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">/* 一个假设的事件，用来监听刚消失在视线外的div，实际上可以通过监听滚                                     动条位置来实现 */</span><br><span class=\"line\">      userInfoContainer.disappear(function( div )&#123;</span><br><span class=\"line\">              created.push( div );</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"> &#125;)()</span><br><span class=\"line\">  var div = getDiv();</span><br><span class=\"line\">  div.innerHTML = &quot;$&#123;userinfo&#125;&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>##应用</p>\n<p>虚拟列表，只创建你看得见的dom</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h2 id=\"一句话就是：代理人先整理需求\"><a href=\"#一句话就是：代理人先整理需求\" class=\"headerlink\" title=\"一句话就是：代理人先整理需求\"></a>一句话就是：代理人先整理需求</h2><h2 id=\"定义-14\"><a href=\"#定义-14\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>代理模式的定义是把对一个对象的访问, 交给另一个代理对象来操作.</p>\n<h2 id=\"代码-14\"><a href=\"#代码-14\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = proxy.get( &apos;cgi.xx.com/xxx&apos; );</span><br><span class=\"line\"> </span><br><span class=\"line\">request.send();</span><br><span class=\"line\"> </span><br><span class=\"line\">request.done(function()&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"应用-12\"><a href=\"#应用-12\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>实际的编程中， 这种因为性能问题使用代理模式的机会是非常多的。比如频繁的访问dom节点, 频繁的请求远程资源. 可以把操作先存到一个缓冲区, 然后自己选择真正的触发时机.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}